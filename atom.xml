<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>6 + 7</title>
  
  <subtitle>无</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-09-14T12:44:10.341Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>愚人丶不愚</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>servlet和jsp笔记</title>
    <link href="http://example.com/2021/09/14/servlet%E5%92%8Cjsp%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/09/14/servlet%E5%92%8Cjsp%E7%AC%94%E8%AE%B0/</id>
    <published>2021-09-14T07:07:00.000Z</published>
    <updated>2021-09-14T12:44:10.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="servlet和jsp笔记"><a href="#servlet和jsp笔记" class="headerlink" title="servlet和jsp笔记"></a>servlet和jsp笔记</h1><span id="more"></span><h1 id="《《文章很长，目录在右下角》》"><a href="#《《文章很长，目录在右下角》》" class="headerlink" title="《《文章很长，目录在右下角》》"></a>《《文章很长，目录在右下角》》</h1><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="应用程序分层开发（MVC）"><a href="#应用程序分层开发（MVC）" class="headerlink" title="应用程序分层开发（MVC）"></a>应用程序分层开发（MVC）</h3><p><img src="https://s3.bmp.ovh/imgs/2021/09/898dbdb996412b9a.png"></p><h3 id="Servlet简介"><a href="#Servlet简介" class="headerlink" title="Servlet简介"></a>Servlet简介</h3><p>server  applet（服务端应用小程序）<br><img src="https://s3.bmp.ovh/imgs/2021/09/9a937530ed18959a.png"></p><h3 id="Eclipse中创建服务器-略"><a href="#Eclipse中创建服务器-略" class="headerlink" title="Eclipse中创建服务器(略)"></a>Eclipse中创建服务器(略)</h3><h3 id="Eclipse创建Web项目（略）"><a href="#Eclipse创建Web项目（略）" class="headerlink" title="Eclipse创建Web项目（略）"></a>Eclipse创建Web项目（略）</h3><h3 id="使用Servlet基本步骤"><a href="#使用Servlet基本步骤" class="headerlink" title="使用Servlet基本步骤"></a>使用Servlet基本步骤</h3><ol><li>创建一个类，并继承HttpServlet类</li><li>重写HttpServlet类中的二个方法doPost()和doGet()，并在其中编写处理请求的代码</li><li>配置项目WEB-INF\web.xml  a、servlet元素中的servlet-name和servlet-mapping中的servlet-name的内容一致 b、url-pattern的内容要和页面form元素的action属性的值一致（不含斜杠）<br><img src="https://s3.bmp.ovh/imgs/2021/09/2c91521ff1d13b29.png"></li><li>创建JSP页面，编写form表单</li><li>部署项目：将web项目部署到Tomcat服务器上<br><img src="https://s3.bmp.ovh/imgs/2021/09/efda014c0b5ef62b.png"><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><h3 id="访问：http-127-0-0-1-8080-项目名-页面-html"><a href="#访问：http-127-0-0-1-8080-项目名-页面-html" class="headerlink" title="访问：http://127.0.0.1:8080/项目名/页面.html"></a>访问：<a href="http://127.0.0.1:8080/%E9%A1%B9%E7%9B%AE%E5%90%8D/%E9%A1%B5%E9%9D%A2.html">http://127.0.0.1:8080/项目名/页面.html</a></h3><h3 id="GET和POST方式请求的区别"><a href="#GET和POST方式请求的区别" class="headerlink" title="GET和POST方式请求的区别"></a>GET和POST方式请求的区别</h3>携带数据的方式 GET： URL（网址）?key=value&amp;key=value<pre><code> 会将数据以键值对的方式拼接在URL之后（会显示在地址栏中），并且是将所有数据一次性提交到后台，对数据长度有限制 缺点：不安全（如果包含敏感数据，如密码，都会显示在地址栏中），很难实现文件上传</code></pre> POST：将数据以数据包的形式提交到后台（至少是一个数据包），理论上对数据长度无限制<h3 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h3></li></ol><ul><li>生命周期的三个阶段</li></ul><p>创建对象并初始化、为项目提供服务、销毁</p><ol><li>服务器（Tomcat）启动时，不会创建Servlet对象</li><li>当请求Servlet时，Servlet对象才被创建</li><li>一个生命周期中，init方法只会被执行一次</li><li>默认情况下，Servlet是单例模式的</li><li>由于Servlet对象可能会被多线程同时访问，所以Servlet是线程不安全的</li><li>Servlet对象销毁时会调用destroy()方法（回收资源），但调用destroy()方法不会销毁Servlet对象</li></ol><ul><li>生命周期中的三个方法</li></ul><ol><li>初始化方法：init</li><li>提供服务的方法：service</li><li>销毁的方法：destroy</li></ol><ul><li><p>提供服务的三个方法<br><img src="https://s3.bmp.ovh/imgs/2021/09/78c9b8ce551c28bd.png"></p><h3 id="通配符映射"><a href="#通配符映射" class="headerlink" title="通配符映射"></a>通配符映射</h3><p><img src="https://s3.bmp.ovh/imgs/2021/09/7070a34d5cde1559.png"></p><h3 id="处理中文乱码问题"><a href="#处理中文乱码问题" class="headerlink" title="处理中文乱码问题"></a>处理中文乱码问题</h3><p>  // 设置Post方式请求内容的编码<br>  request.setCharacterEncoding(“utf-8”);<br>  // 设置响应的内容类型<br>  response.setContentType(“text/html; charset=UTF-8”);<br>  // 设置响应的编码<br>  response.setCharacterEncoding(“utf-8”);</p>  <!-- tomcat\config\server.xml    URIEncoding：用于设置get方式请求数据的编码 --><p>  &lt;Connector port=”8080” protocol=”HTTP/1.1”</p><pre><code>          connectionTimeout=&quot;20000&quot;          redirectPort=&quot;8443&quot; URIEncoding=&quot;utf-8&quot;/&gt;</code></pre><h3 id="老师的代码"><a href="#老师的代码" class="headerlink" title="老师的代码"></a>老师的代码</h3><p>  package com.servlet;</p><p>  import java.io.IOException;<br>  import java.io.PrintWriter;</p><p>  import javax.servlet.ServletException;<br>  import javax.servlet.http.HttpServlet;<br>  import javax.servlet.http.HttpServletRequest;<br>  import javax.servlet.http.HttpServletResponse;<br>  /*</p><ul><li>1、创建类并继承HttpServlet类</li><li>2、实现处理请求的方法 doGet、doPost、doDelete、doPut  （提交表单的四种方式get post delete  put）</li><li>/<br>public class LoginServlet extends HttpServlet {<br>   public LoginServlet() {<pre><code>   System.out.println(&quot;LoginServlet对象被创建！&quot;);</code></pre>   }<br>   // 初始化当前Servlet对象的方法（不需要重写）<br>   // 只有在第一次请求该Servlet时，被执行一次<br>   @Override<br>   public void init() throws ServletException {<pre><code>   System.out.println(&quot;init方法被执行了！&quot;);   super.init();</code></pre>   }<br>   // 提供服务的方法（不需要重写）<br>   // 每请求一次会被执行一次<br>   @Override<br>   protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<pre><code>   System.out.println(&quot;service方法被执行了！&quot;);   String method = req.getMethod();   System.out.println(&quot;method = &quot; + method);</code></pre>//        if (“GET”.equals(method)) {<br>//            doGet(req, resp);<br>//        } else if (“POST”.equals(method)) {<br>//            doPost(req, resp);<br>//        }<pre><code>   super.service(req, resp);</code></pre>   }<br>   // 销毁当前Servlet对象的方法（不需要重写）<br>   // 只有Tomcat服务结束时，被执行一次<br>   @Override<br>   public void destroy() {<pre><code>   System.out.println(&quot;destroy方法被执行了！&quot;);   super.destroy();</code></pre>   }<br>   /*<ul><li>参数一：请求对象，请求对象中保存着客户端的所有信息</li><li>参数二：响应对象，向客户端响应的内容以及一些设置，都在响应对象中</li><li>/<br>@Override<br>protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br>   System.out.println(“get请求成功”);   // 解决响应的乱码问题<br>   resp.setCharacterEncoding(“utf-8”);<br>   resp.setContentType(“text/html; charset=UTF-8”);   // 获取客户端提交的表单中的数据<br>   String phone = req.getParameter(“phone”);<br>   String password = req.getParameter(“password”);<br>   System.out.println(“Get获取的手机号：” + phone);<br>   System.out.println(“Get获取的密码：” + password);</li></ul></li></ul><p>  //        byte[] data = phone.getBytes(“ISO-8859-1”);<br>  //        String result = new String(data,”utf-8”);</p><pre><code>      // 获取响应的输出流</code></pre><p>  //        resp.getOutputStream();</p><pre><code>      PrintWriter writer = resp.getWriter();      writer.write(&quot;登录成功&quot;);      // 刷新缓冲区（清空缓冲区）      writer.flush();      // 关闭流      writer.close();  &#125;    @Override  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;      System.out.println(&quot;post请求成功&quot;);            // 解决POST方式请求的乱码（获取请求的数据之前）      req.setCharacterEncoding(&quot;UTF-8&quot;);      // 解决响应乱码问题(响应的内容被转换成二进制时使用的字符集)      resp.setCharacterEncoding(&quot;UTF-8&quot;);      // 告诉浏览器，应该以什么字符集解析响应内容      resp.setContentType(&quot;text/html;charset=UTF-8&quot;);            // 获取客户端提交的表单中的数据      String phone = req.getParameter(&quot;phone&quot;);      String password = req.getParameter(&quot;password&quot;);      System.out.println(&quot;post获取的手机号：&quot; + phone);      System.out.println(&quot;post获取的密码：&quot; + password);            // 获取响应的输出流</code></pre><p>  //        resp.getOutputStream();</p><pre><code>      PrintWriter writer = resp.getWriter();      writer.write(&quot;&lt;font color=&#39;green&#39;&gt;登录成功&lt;/font&gt;&quot;);      // 刷新缓冲区（清空缓冲区）      writer.flush();      // 关闭流      writer.close();  &#125;</code></pre><p>  }</p></li></ul><hr><pre><code>package com.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class UserServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doPost(req, resp);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        // 处理乱码        req.setCharacterEncoding(&quot;utf-8&quot;);        resp.setCharacterEncoding(&quot;utf-8&quot;);        resp.setContentType(&quot;text/html;charset=utf-8&quot;);                // 获取当前要执行的操作        String operation = req.getParameter(&quot;operation&quot;);        switch(operation) &#123;        case &quot;login&quot;:            // 执行登录操作            login(req,resp);            break;        case &quot;register&quot;:            // 执行注册操作            register(req,resp);            break;        case &quot;update&quot;:            // 执行更新用户信息            update(req,resp);            break;        case &quot;delete&quot;:            // 执行删除用户操作            delete(req,resp);            break;        &#125;    &#125;    private void delete(HttpServletRequest req, HttpServletResponse resp) &#123;        System.out.println(&quot;删除用户&quot;);    &#125;    private void update(HttpServletRequest req, HttpServletResponse resp) &#123;        System.out.println(&quot;更新用户&quot;);            &#125;    private void register(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;        System.out.println(&quot;注册用户&quot;);        // 获取客户端的值        String username = req.getParameter(&quot;username&quot;);        String password = req.getParameter(&quot;password&quot;);        String repassword = req.getParameter(&quot;repassword&quot;);        PrintWriter writer = resp.getWriter();                if (username==null || &quot;&quot;.equals(username)) &#123;            writer.write(&quot;用户名不能为空&quot;);        &#125;else &#123;            writer.write(&quot;您输入的用户名：&quot; + username + &quot; 密码：&quot; + password);        &#125;        writer.flush();        writer.close();    &#125;    private void login(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;        System.out.println(&quot;登录系统&quot;);        // 获取客户端的值        String username = req.getParameter(&quot;username&quot;);        String password = req.getParameter(&quot;password&quot;);                PrintWriter writer = resp.getWriter();        writer.write(&quot;您输入的用户名：&quot; + username + &quot; 密码：&quot; + password);        writer.flush();        writer.close();    &#125;&#125;</code></pre><hr><p>（这个界面就写一个）</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!--         action：url        method：提交表单的四种方式get（默认值） post delete  put     --&gt;    &lt;form action=&quot;user&quot; method=&quot;post&quot;&gt;        &lt;!-- 隐藏域 --&gt;        &lt;input type=&quot;hidden&quot; name=&quot;operation&quot; value=&quot;login&quot;&gt;         手机号：&lt;input name=&quot;phone&quot; type=&quot;text&quot;/&gt;&lt;br/&gt;        密 码：&lt;input name=&quot;password&quot; type=&quot;password&quot;/&gt;&lt;br/&gt;        &lt;input value=&quot;POST登录&quot; type=&quot;submit&quot;/&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;4.0&quot;&gt;&lt;display-name&gt;day26-servlet01&lt;/display-name&gt;&lt;!-- 配置Servlet和URL之间的映射关系 --&gt;&lt;servlet&gt;    &lt;servlet-name&gt;loginServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.servlet.LoginServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;loginServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/login&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet&gt;    &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.servlet.UserServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/html/user&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/user&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;welcome-file-list&gt;    &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;    &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;    &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;    &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;servlet和jsp笔记&quot;&gt;&lt;a href=&quot;#servlet和jsp笔记&quot; class=&quot;headerlink&quot; title=&quot;servlet和jsp笔记&quot;&gt;&lt;/a&gt;servlet和jsp笔记&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>xml笔记</title>
    <link href="http://example.com/2021/09/14/xml%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/09/14/xml%E7%AC%94%E8%AE%B0/</id>
    <published>2021-09-14T06:58:00.000Z</published>
    <updated>2021-09-14T07:02:48.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xml笔记"><a href="#xml笔记" class="headerlink" title="xml笔记"></a>xml笔记</h1><span id="more"></span><h1 id="《《文章很长，目录在右下角》》"><a href="#《《文章很长，目录在右下角》》" class="headerlink" title="《《文章很长，目录在右下角》》"></a>《《文章很长，目录在右下角》》</h1><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><pre><code>package com.util;import java.io.File;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.NamedNodeMap;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import com.sun.org.apache.xerces.internal.dom.DeferredElementImpl;import com.sun.org.apache.xerces.internal.dom.DeferredNotationImpl;/** 解析xml的两种方式*     DOM（Document Object Model）方式：*         首先将整个xml文档加载到内存中，并将文档转换成文档对象，文档中的元素也会被分别转换成对象*         优点：读写方便，查找元素对象也更加的方便快捷*         缺点：太消耗内存，只适合小文件，不适合大文件*     SAX方法：*         事件驱动的方式进行文档的解析*         优点：消耗内存很少，适合处理大文件*         缺点：读写查找元素没有DOM方式快捷方便* * JDK提供了DOM和SAX方式* 常用第三方提供的xml解析的类库：JDOM、DOM4J、XPath* */public class DomParseXML &#123;    public static void main(String[] args) &#123;        try &#123;            /******************** JDK提供的DOM方式解析XML的实现 **********************/            // 1、常见DOM方式解析XML的工厂类的对象            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();            // 2、创建文档对象的建造者对象（建造者模式）            DocumentBuilder docBuilder = factory.newDocumentBuilder();                        // 创建文件对象            File xml = new File(&quot;config/users.xml&quot;);            System.out.println(xml.exists());            // 3、通过文档建造者创建文档对象            Document doc = docBuilder.parse(xml);                        // 4、通过文档对象获取元素对象或属性值或元素内容。。。            // 必须在xml的验证文件(DTD/XSD)中，将id属性设置为ID            Element userElement = doc.getElementById(&quot;id1&quot;);            System.out.println(&quot;class = &quot; + userElement.getAttribute(&quot;class&quot;));            // 根据标签的名称获取节点对象的集合            NodeList userList = doc.getElementsByTagName(&quot;user&quot;);                        for (int i = 0; i &lt; userList.getLength(); i++) &#123;                Node user = userList.item(i);                // Node.getAttributes()：获取所有属性的集合                NamedNodeMap attrs = user.getAttributes();                // 根据属性的名称，获取属性的节点对象                Node attrClass = attrs.getNamedItem(&quot;class&quot;);                // 获取属性的值                String classValue = attrClass.getNodeValue();                System.out.println(classValue);                // 获取属性id的值                System.out.println(attrs.getNamedItem(&quot;id&quot;).getNodeValue());                                // 获取所有子元素的集合                NodeList childNodes = user.getChildNodes();                for (int j = 0; j &lt; childNodes.getLength(); j++) &#123;                    Node child = childNodes.item(j);                    // 判断节点的类型，筛选出需要的元素对象（文本节点不是我们需要的）                    // 元素对象的类型：DeferredElementImpl                    // 文本节点的类型：DeferredTextImpl                    if (child instanceof DeferredElementImpl) &#123;//                        child.getAttributes().getNamedItem(&quot;value&quot;).getNodeValue();                        // 获取元素的内容                        String textContent = child.getTextContent();                        System.out.println(textContent);                    &#125;                &#125;            &#125;                    &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h2 id="SAX"><a href="#SAX" class="headerlink" title="SAX"></a>SAX</h2><pre><code>package com.util;import java.io.File;import javax.xml.parsers.SAXParser;import javax.xml.parsers.SAXParserFactory;import org.xml.sax.Attributes;import org.xml.sax.SAXException;import org.xml.sax.helpers.DefaultHandler;public class SaxParseXML &#123;    public static void main(String[] args) &#123;        try &#123;            // 1、创建SAX解析工厂            SAXParserFactory factory = SAXParserFactory.newInstance();            // 2、创建SAX解析器的对象            SAXParser parser = factory.newSAXParser();            // 创建xml文件对象            File xml = new File(&quot;config/users.xml&quot;);            // 通过自定义Handler类，创建handler对象//            SaxParseXMLHandler handler = new SaxParseXMLHandler();            // 通过匿名内部类的方式，创建Handler对象            DefaultHandler handler = new DefaultHandler() &#123;                @Override                public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123;                    // 如果开始标签的名称是user                    if (&quot;user&quot;.equals(qName)) &#123;                        // 根据属性的名称，获取属性的值                        String classValue = attributes.getValue(&quot;class&quot;);                        System.out.println(classValue);                    &#125; else if (&quot;id&quot;.equals(qName)) &#123;                        // 输出id标签中value属性的值                        System.out.println(attributes.getValue(&quot;value&quot;));                    &#125;                &#125;                                // 读取到元素内容时，调用此方法                @Override                public void characters(char[] ch, int start, int length) throws SAXException &#123;                    System.out.println(new String(ch,start,length).trim());                &#125;                        &#125;;            // 解析xml            parser.parse(xml, handler);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;package com.util;import org.xml.sax.Attributes;import org.xml.sax.SAXException;import org.xml.sax.helpers.DefaultHandler;public class SaxParseXMLHandler extends DefaultHandler &#123;    // 读取文档开始标签，会调用该方法    @Override    public void startDocument() throws SAXException &#123;    &#125;    // 读取文档结束标签，会调用该方法    @Override    public void endDocument() throws SAXException &#123;    &#125;        // 读取到一个元素的开始标签，会调用该方法    @Override    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123;        // 如果开始标签的名称是user        if (&quot;user&quot;.equals(qName)) &#123;            // 根据属性的名称，获取属性的值            String classValue = attributes.getValue(&quot;class&quot;);            System.out.println(classValue);        &#125;    &#125;    // 读取到元素内容时，调用此方法    // 参数一：是整个文档的内容（不含&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;）    // 参数二：当前读取的内容的偏移量（起始下标）    // 参数三：内容的长度    @Override    public void characters(char[] ch, int start, int length) throws SAXException &#123;            &#125;        // 读取到一个元素的结束标签，会调用该方法    @Override    public void endElement(String uri, String localName, String qName) throws SAXException &#123;            &#125;    &#125;</code></pre><h2 id="JDOM"><a href="#JDOM" class="headerlink" title="JDOM"></a>JDOM</h2><pre><code>package com.util;import java.io.File;import java.io.IOException;import java.util.List;import org.jdom2.Document;import org.jdom2.Element;import org.jdom2.JDOMException;import org.jdom2.input.DOMBuilder;import org.jdom2.input.SAXBuilder;import org.w3c.dom.Attr;import org.w3c.dom.CDATASection;import org.w3c.dom.Comment;import org.w3c.dom.DOMConfiguration;import org.w3c.dom.DOMException;import org.w3c.dom.DOMImplementation;import org.w3c.dom.DocumentFragment;import org.w3c.dom.DocumentType;import org.w3c.dom.EntityReference;import org.w3c.dom.NamedNodeMap;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.w3c.dom.ProcessingInstruction;import org.w3c.dom.Text;import org.w3c.dom.UserDataHandler;public class JDomParseXML &#123;    public static void main(String[] args) &#123;        try &#123;            SAXBuilder builder = new SAXBuilder();            Document doc = builder.build(new File(&quot;config/users.xml&quot;));            // 获取根元素（users）            Element root = doc.getRootElement();            // 根据标签名获取子元素            Element user = root.getChild(&quot;user&quot;);            // 根据属性名，获取属性值            System.out.println(user.getAttributeValue(&quot;class&quot;));            // 获取所有子元素的集合            List&lt;Element&gt; children = user.getChildren();            for (Element element : children) &#123;                // 获取元素的内容                System.out.println(element.getText());            &#125;                    &#125; catch (JDOMException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h2 id="DOM4J"><a href="#DOM4J" class="headerlink" title="DOM4J"></a>DOM4J</h2><pre><code>package com.util;import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.util.List;import org.dom4j.Attribute;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.Node;import org.dom4j.io.SAXReader;public class DOM4jParseXML &#123;    public static void main(String[] args) &#123;        try &#123;            // 创建读取文件的阅读器对象            SAXReader reader = new SAXReader();            // 读取xml文件            Document doc = reader.read(new File(&quot;config/users.xml&quot;));                        // 通过XPath查找username元素对象            Node node = doc.selectSingleNode(&quot;/users/user/username&quot;);            System.out.println(node);            System.out.println(node.getName());            System.out.println(node.getText());                                                // 获取根元素            Element root = doc.getRootElement();                        // 根据元素的ID属性获取元素对象（要求ID必须大写）//            Element user = root.elementByID(&quot;1&quot;);//            System.out.println(user);                        // 获取所有标签为user的子元素（获取所有指定标签名的子元素）            List&lt;Element&gt; childrens = root.elements(&quot;user&quot;);            for (Element child : childrens) &#123;                // getParent():获取父元素对象                System.out.println(child.getParent().getName());                // 根据属性名称，获取属性对象//                Attribute attr = child.attribute(&quot;class&quot;);//                // Attribute.getStringValue()：获取属性值//                System.out.println(attr.getStringValue());//                System.out.println(attr.getValue());                                // 获取属性值                System.out.println(child.attributeValue(&quot;class&quot;));                                // 获取user元素下的所有子元素                List&lt;Element&gt; userChildrens = child.elements();                for (Element ele : userChildrens) &#123;                    // Element.getStringValue()：获取元素的内容                    System.out.println(ele.getStringValue());                    System.out.println(ele.getText());                    System.out.println(ele.getTextTrim());                &#125;            &#125;                        /********************* 生成xml文件 **********************/            // 追加一个属性            root.addAttribute(&quot;class&quot;, &quot;com.entity.User&quot;);            // 新建一个Element对象            Element user = root.addElement(&quot;user&quot;);            Element id = user.addElement(&quot;id&quot;);            Element username = user.addElement(&quot;username&quot;);            Element password = user.addElement(&quot;password&quot;);            id.addText(&quot;2&quot;);            username.addText(&quot;李四&quot;);            password.addText(&quot;abc&quot;);            // 新建一个文件输出流            FileWriter writer = new FileWriter(&quot;E:/user.xml&quot;);            // 写出到新的xml文件中            root.write(writer);            writer.close();                    &#125; catch (DocumentException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;     &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;xml笔记&quot;&gt;&lt;a href=&quot;#xml笔记&quot; class=&quot;headerlink&quot; title=&quot;xml笔记&quot;&gt;&lt;/a&gt;xml笔记&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>DOM</title>
    <link href="http://example.com/2021/09/02/DOM/"/>
    <id>http://example.com/2021/09/02/DOM/</id>
    <published>2021-09-02T11:32:00.000Z</published>
    <updated>2021-09-05T02:02:18.454Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript笔记</title>
    <link href="http://example.com/2021/08/31/JavaScript%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/08/31/JavaScript%E7%AC%94%E8%AE%B0/</id>
    <published>2021-08-31T09:42:57.000Z</published>
    <updated>2021-09-06T23:46:17.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript笔记"><a href="#JavaScript笔记" class="headerlink" title="JavaScript笔记"></a>JavaScript笔记</h1><span id="more"></span><h1 id="《《文章很长，目录在右下角》》"><a href="#《《文章很长，目录在右下角》》" class="headerlink" title="《《文章很长，目录在右下角》》"></a>《《文章很长，目录在右下角》》</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><ul><li><p>JavaScript是一种弱类型的语言：变量的类型可以随着赋值的类型不同而发生变化</p></li><li><p>强类型的语言：一个变量一旦声明为某种类型，该变量的数据类型就不可再变</p></li><li><p>JavaScript是解释型的语言</p></li><li><p>动态的语言：可以在程序运行的过程中，给对象增加或删除成员（属性、方法）</p><h2 id="使用JavaScript的三种形式"><a href="#使用JavaScript的三种形式" class="headerlink" title="使用JavaScript的三种形式"></a>使用JavaScript的三种形式</h2>  <!DOCTYPE html>  <html>      <head>          <meta charset="utf-8">          <title>使用js的三种形式</title>          <!--           使用JavaScript的三种形式              1、行内：事件的属性上使用JavaScript代码              2、内嵌：script标签内写JavaScript代码              3、外部：先创建js文件，在js文件中编写js代码，然后通过script标签引入外部的js文件                  src：指定外部js文件的地址                  引入js文件的script标签内部不能写js代码                  引入js文件的script标签虽然内容为空，但也不能使用自封形式                  js文件中，直接写js代码即可，不需要script标签          -->          <script type="text/javascript">          function inner_m(){              alert('我被鼠标击中了...');          }          </script>          <script type="text/javascript" src="./js/index.js"></script>      </head>      <body>          <input type="button" value="点我试一试（行内）" onclick="alert('我被鼠标击中了...');">          <input type="button" value="点我试一试（内嵌）" onclick="inner_m();">          <input type="button" value="点我试一试（外部）" onclick="outer_m();">      </body>  </html>## 注释// 单行注释</li></ul><p>/* 多行注释 */</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="https://s3.bmp.ovh/imgs/2021/09/517e4f5c1de563ef.png"></p><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;声明变量&lt;/title&gt;        &lt;script&gt;        // 声明变量并赋值： var 变量名 = 值;        // 声明常量并赋值： const 变量名 = 值;        var i = 1;        // 等价于java中的System.out.println();        console.log(i);        // 获取变量的类型: typeof 变量名; // 该表达式的返回值，就是变量的数据类型名称        var t = typeof i;        console.log(&quot;变量i的数据类型：&quot; + t);        console.log(&quot;变量t的数据类型：&quot; + typeof t);                // 修改变量i的数据类型        i = &quot;1&quot;;        console.log(&quot;变量i的数据类型：&quot; + typeof i);        i = true;        console.log(&quot;变量i的数据类型：&quot; + typeof i);        i = null;        console.log(&quot;变量i的数据类型：&quot; + typeof i);        i = new XMLHttpRequest();        console.log(&quot;变量i的数据类型：&quot; + typeof i);        i = undefined;        console.log(&quot;变量i的数据类型：&quot; + typeof i);                // instanceof不要用于原始类型        i = new XMLHttpRequest();        console.log(&quot;判断变量i是否输入Object类型：&quot; + (i instanceof Object));                        var und;        console.log(und);        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="关键字typeof"><a href="#关键字typeof" class="headerlink" title="关键字typeof"></a>关键字typeof</h2><p><img src="https://s3.bmp.ovh/imgs/2021/09/337dede967653303.png"></p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;演示JavaScript中的String类型的使用&lt;/title&gt;        &lt;script&gt;        var str = &quot;abcdefgh,ijklmn   &quot;;        console.log(&quot;原始字符串：&quot; + str);        // length属性获取字符串的长度        console.log(&quot;字符串的长度：&quot; + str.length);                // 截取字符串 参数1：开始下标  参数2：结束下标        console.log(&quot;截取的开始下标为3，结束下标为5：&quot; + str.substring(3,5));        // 截取字符串 参数1：开始下标  参数2：截取的字符个数（长度）        console.log(&quot;从下标3开始截取5个字符：&quot; + str.substr(3,5));                // 删除两头的空格        console.log(&quot;trim():删除两端空格：&quot; + str.trim());        // 删除左侧的空格        console.log(&quot;trimLeft():删除两端空格：&quot; + str.trimLeft());        // 删除右侧的空格        console.log(&quot;trimRight():删除两端空格：&quot; + str.trimRight());                // 拆分字符串        var arr = str.split(&quot;,&quot;);        console.log(&quot;以逗号拆分字符串：&quot; + arr[0]);        console.log(&quot;以逗号拆分字符串：&quot; + arr[1]);                // 替换字符        console.log(&quot;mn替换成xyz：&quot; + str.replace(&quot;mn&quot;,&quot;xyz&quot;));                // 查找指定字符串的下标        console.log(&quot;indexOf:查找abc的下标：&quot; + str.indexOf(&quot;abc&quot;));        // 查找指定字符串的下标        console.log(&quot;lastIndexOf:查找abc的下标：&quot; + str.lastIndexOf(&quot;abc&quot;));        // 是否包含指定的字符串        // console.log(&quot;contains:是否包含abc：&quot; + str.contains(&quot;abc&quot;,0));        // 判断是否指定的字符串开头        console.log(&quot;startsWith:判断字符串是否以abc开头：&quot; + str.startsWith(&quot;abc&quot;));        // 判断是否指定的字符串结尾        console.log(&quot;endsWith:判断字符串是否以abc结尾：&quot; + str.endsWith(&quot;abc&quot;));        // 连接字符串        console.log(&quot;concat:连接字符串：&quot; + str.concat(&quot;oooo&quot;));        console.log(&quot;+:连接字符串：&quot; + str + &quot;oooo&quot;);                                        // 将字符串转换成大写        console.log(&quot;大写：&quot; + str.toUpperCase());        console.log(&quot;原变量str的值不变：&quot; + str);        str = &quot;ABC&quot;;        // 将字符串转换成小写        console.log(&quot;小写：&quot; + str.toLowerCase());                        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;类型转换&lt;/title&gt;        &lt;script&gt;        var i = 1;        // 将Number类型的变量i转换为String类型        var str = i.toString();        console.log(&quot;转换后的数据类型：&quot; + typeof str);        console.log(&quot;转换后原变量i的数据类型：&quot; + typeof i);                // 第二种转换形式（只要是通过new出来的对象，数据类型都是Object类型）        i = 1;        str = new String(i);        console.log(&quot;转换后的数据类型：&quot; + typeof str);        console.log(&quot;转换后的数据类型：&quot; + str);                i = 10;        // 基模式：根据指定的进制将Number类型的值，转换成字符串        console.log(&quot;将10转换为2进制的字符串：&quot; + i.toString(2));        console.log(&quot;将10转换为8进制的字符串：&quot; + i.toString(8));        console.log(&quot;将10转换为16进制的字符串：&quot; + i.toString(16));                        // 字符串转换成数字        var s = &quot;123&quot;;        // 将字符串转换为整型值        var int_ = parseInt(s);        console.log(&quot;将\&quot;123\&quot;转为整型数据：&quot; + typeof int_);        console.log(&quot;将\&quot;123\&quot;转为整型数据：&quot; + int_);                // 如果参数是小数，小数部分会被丢弃        console.log(&quot;将\&quot;123.123\&quot;转为整型数据：&quot; + typeof parseInt(&quot;123.123&quot;));        console.log(&quot;将\&quot;123.123\&quot;转为整型数据：&quot; + parseInt(&quot;123.123&quot;));                // 如果字符串是以数字开头的就可以转换成功，直到第一个不为数字的字符，其后所有字符都被丢弃        console.log(&quot;将\&quot;123abc\&quot;转为整型数据：&quot; + typeof parseInt(&quot;123abc123&quot;));        console.log(&quot;将\&quot;123abc\&quot;转为整型数据：&quot; + parseInt(&quot;123abc123&quot;));                // 如果字符串是不是以数字开头的，也可以转换成功，转换后的值是NaN（Not a Number）        console.log(&quot;将\&quot;abc123\&quot;转为整型数据：&quot; + typeof parseInt(&quot;abc123&quot;));        console.log(&quot;将\&quot;abc123\&quot;转为整型数据：&quot; + parseInt(&quot;abc123&quot;));                        // 将字符串转换为浮点型值        console.log(&quot;将\&quot;123.123\&quot;转为浮点型数据：&quot; + typeof parseFloat(&quot;123.123&quot;));        console.log(&quot;将\&quot;123.123\&quot;转为浮点型数据：&quot; + parseFloat(&quot;123.123&quot;));                // 如果字符串是以数字开头的就可以转换成功，直到第一个不为数字或小数点的字符，其后所有字符都被丢弃        console.log(&quot;将\&quot;123.1abc\&quot;转为浮点型数据：&quot; + typeof parseFloat(&quot;123.1abc123&quot;));        console.log(&quot;将\&quot;123.1abc\&quot;转为浮点型数据：&quot; + parseFloat(&quot;123.1abc123&quot;));                // 如果字符串是不是以数字开头的，也可以转换成功，转换后的值是NaN（Not a Number）        console.log(&quot;将\&quot;abc123.1\&quot;转为浮点型数据：&quot; + typeof parseFloat(&quot;abc123.1&quot;));        console.log(&quot;将\&quot;abc123.1\&quot;转为浮点型数据：&quot; + parseFloat(&quot;abc123.1&quot;));                // parseInt(&quot;123abc&quot;)转换的结果：123;        // new Number(&quot;123abc&quot;)转换的结果：NaN;        var num = new Number(&quot;123abc&quot;);        console.log(&quot;将\&quot;123\&quot;转为Number类型的数据：&quot; + typeof num);        console.log(&quot;将\&quot;123\&quot;转为Number类型的数据：&quot; + (num + 1));        // NaN:自己都不等于自己，所以不能用双等号来判断一个变量是否是NaN        console.log(&quot;判断num的值是否是NaN：&quot; + (NaN == NaN));        console.log(&quot;判断num的值是否是NaN：&quot; + (num == NaN));        console.log(&quot;isNaN判断num的值是否是NaN：&quot; + isNaN(num));                // 其他的数据类型转换成布尔类型        num = 0;        var bool = new Boolean(num);        console.log(&quot;将数字转换为boolean类型：&quot; + typeof bool);        console.log(&quot;将数字转换为boolean类型：&quot; + bool);        // javascript中的流程控制和java中的一样（if、if-else、while、do-while、for）        // 当其他类型用作布尔表达式时，js会自动将数据转换成boolean类型        if(num)&#123;                    &#125;else&#123;            console.log(&quot;0会被转换为false&quot;);        &#125;        // 0、null、undefined、空字符串 会被转换为false，其余的值都会被转换为true        console.log(&quot;将0转换为boolean类型：&quot; + new Boolean(0));        console.log(&quot;将null转换为boolean类型：&quot; + new Boolean(null));        console.log(&quot;将undefined转换为boolean类型：&quot; + new Boolean(undefined));        console.log(&quot;将空字符串转换为boolean类型：&quot; + new Boolean(&quot;&quot;));        console.log(&quot;将\&quot;false\&quot;转换为boolean类型：&quot; + new Boolean(&quot;false&quot;));        if(0 &amp;&amp; null)&#123;                    &#125;else&#123;            console.log(&quot;0会被转换为false&quot;);        &#125;                        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;运算符&lt;/title&gt;        &lt;script&gt;        var i = 1;        var str = &quot;1&quot;;        var i2 = 2;        var str2 = &quot;2&quot;;        var i3 = 3;        var i4 = 3;                // ==：只比较值（内容），不比较数据类型；只要内容相同，就返回true；否则返回false        // 相当于 内容1 == 内容2 || 数据类型1 == 数据类型2        console.log( i == str );        // ===：即比较值（内容），也比较数据类型；数据类型和内容都相同时，结果为true；否则结果为false        // 相当于  内容1 == 内容2 &amp;&amp; 数据类型1 == 数据类型2        console.log( i === str );        // !=：内容和数据类型，都不相同时，返回true；否则返回false        // 相当于  内容1 != 内容2 &amp;&amp; 数据类型1 != 数据类型2        console.log( i2 != str2 );        // !==：内容和数据类型，只要有一项不同，就返回true；否则返回false        // 相当于  内容1 != 内容2 || 数据类型1 != 数据类型2        console.log( i2 !== str2 );        console.log( i3 !== str2 );        console.log( i3 !== i4 );        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script&gt;        var arr = [1,2,3,4,5,6];        for(var i=0;i&lt;arr.length;i++)&#123;            console.log(arr[i]);        &#125;        // index：每循环一次，index就会获取数组arr的一个下标        // for(var prop : 对象)&#123;&#125; ：每循环一次，prop就会获取对象的一个属性（用于遍历对象上的属性，如果将一个对象看做map集合的话，遍历的就是map的key）        for(var index in arr)&#123;            console.log(arr[index]);        &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;数组&lt;/title&gt;        &lt;script&gt;        // 声明数组，并创建数组对象赋值        // 数组常量：[值1,值2,...,值n]        var arr1 = [1,2,3];        console.log(arr1[4]);        // 创建数组对象：new Array(长度); 默认的元素值都是undefined        var arr2 = new Array(3);        for(var i = 0; i &lt; arr2.length; i++)&#123;            console.log(arr2[i]);        &#125;                // js没有数组和collection集合之分的        var arr3 = new Array();        arr3[0] = 10;        arr3[3] = 10;        console.log(arr3.length);        console.log(arr3[0]);        console.log(arr3[1]);        console.log(arr3[2]);        console.log(arr3[3]);        console.log(arr3[4]);                        var arr4 = new Array(1,4,5,67,8,2);        console.log(arr4[0]);        console.log(arr4[1]);        console.log(arr4[2]);        console.log(arr4[3]);        console.log(arr4[4]);                // forEach(方法名);  循环执行参数方法        arr4.forEach(loop);        // 参数一：获取数组中的元素值   参数二：获取数组的下标        function loop(value,index)&#123;            console.log(value + &quot;-&quot; + index);        &#125;                &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;函数&lt;/title&gt;        &lt;script&gt;        // 声明函数  function 函数名(变量名1,...,变量名n)&#123; [return [返回值];] &#125;        // 注意：参数直接参数名即可，一定不能使用var进行声明        function add(a,b)&#123;            console.log(&quot;a=&quot; + a);            console.log(&quot;b=&quot; + b);            return a + b;        &#125;        // 调用方法        var result = add(1,2);        console.log(&quot;result=&quot;+result);                // function(变量名1,...,变量名n)&#123;&#125; 声明一个匿名方法        // 函数的声明方式二：var 方法名 = function(变量名1,...,变量名n)&#123;&#125;        var m1 = function(a)&#123;            console.log(&quot;a=&quot;+a);        &#125;        // 调用方法        m1(100);        var m3 = m1;        // 调用方法        m3(200);                function m4(m5)&#123;            m5(500);        &#125;        m4(m3);                // 获取方法参数的个数        console.log(&quot;获取参数的个数：&quot; + m1.length);        // 获取方法的源代码        console.log(m1);        console.log(m1.valueOf());        console.log(m1.toString());                m1.name = &quot;m1方法&quot;;        // 遍历m1上的属性        // for(var property in m1)&#123;        //     console.log(&quot;property = &quot; + property);        // &#125;                // 类型是Function        console.log(typeof m1);                        // 函数的声明方式三：var 方法名 = new Function([&quot;参数列表&quot;],[&quot;方法体&quot;]);        var m2 = new Function(&quot;a&quot;,&quot;console.log(a)&quot;);        // 调用方法        m2(10);                        // 方法重载        function f()&#123;            console.log(&quot;没有参数的方法&quot;);            var result = 0;            // arguments:获取方法的参数（实参）列表（数组）            for(var index in arguments)&#123;                // 如果参数的数据类型是function，则调用该方法                // if(typeof arguments[index] == &quot;function&quot;)&#123;                if(arguments[index] instanceof Function)&#123;                    // 调用传入的方法                    arguments[index]();                &#125; else &#123;                    console.log(&quot;参数：&quot; + arguments[index]);                    result += arguments[index];                &#125;            &#125;            return result;        &#125;        // function f(a)&#123;        //     console.log(&quot;有一个参数的方法&quot;);        // &#125;        var sum = f(1,2,3,4,5,6,7,8,9,10,function()&#123;            console.log(&quot;参数传入的匿名方法&quot;);        &#125;);        console.log(sum);        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;对象&lt;/title&gt;        &lt;script&gt;        // 创建对象：new Object();        var obj1 = new Object();        // 给对象添加一个name属性：对象名.属性名 = 值;        obj1.name = &quot;张三&quot;;        obj1.age = 18;        // 给对象添加方法        obj1.print = function()&#123;            // this指向当前对象的引用            console.log(&quot;姓名：&quot; + this.name + &quot; 年龄：&quot; + this.age);        &#125;;        // 删除指定对象的属性：delete 对象名.属性名;        delete obj1.age;        console.log(obj1);        console.log(obj1.name);        console.log(obj1.age);        // 调用print方法        obj1.print();                // 方式二：创建对象  &#123;&quot;属性1&quot;:值1,...,&quot;属性n&quot;:值n&#125;        var user = &#123;&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:20,&quot;sex&quot;:&quot;男&quot;,                    &quot;print&quot;:function()&#123;                        console.log(&quot;user&quot;);                    &#125;&#125;;        // 访问属性：对象.属性名     对象[&quot;属性名&quot;]        console.log(user.name);        console.log(user.age);        console.log(user.sex);        user.print();        var name = &quot;name&quot;;        console.log(user[name]);        console.log(user[&quot;age&quot;]);        console.log(user[&quot;sex&quot;]);                // 遍历对象的属性        for(var property in user)&#123;            console.log(&quot;属性：&quot; + property + &quot; - 值：&quot; + user[property]);        &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;异常&lt;/title&gt;        &lt;script&gt;        function div(a,b)&#123;            var result = 0;            try&#123;                // result = a/b;                // 抛出一个异常                throw new RangeException();            &#125; catch(e)&#123;                console.log(&quot;异常：&quot; + e);            &#125; finally &#123;                console.log(&quot;finally&quot;);            &#125;            return result;        &#125;        // js中除0的结果是：无穷大        var result = div(10,0);        console.log(result);        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="获取文档中的元素对象"><a href="#获取文档中的元素对象" class="headerlink" title="获取文档中的元素对象"></a>获取文档中的元素对象</h2><p><img src="https://s3.bmp.ovh/imgs/2021/09/4e4ec0d5ddcd67eb.png"><br>获取元素对象</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;获取元素对象&lt;/title&gt;        &lt;script&gt;        // 整个的HTML文档会被转换成一个 document 的对象        // 声明获取元素对象的方法        function getEle()&#123;            // getElementById(id值):根据ID获取元素对象，如果有多个相同id的元素，getElementById方法只会获取第一个id值和参数相同的元素            // 获取id=p1的p元素            // js中遵守了HTML规范，元素id的唯一性            var p = document.getElementById(&quot;p1&quot;);            // 注意：浏览器解析HTML文档，是自上而下解析的；            // 如果获取元素对象的js代码，在要获取的元素被解析之前执行，则无法获取元素对象            // 解决方式有两种            // 1、将获取元素对象的js代码，放到被获取的元素之后            // 2、在body的onload事件中执行获取元素对象的js代码            console.log(p);        &#125;        // 调用获取元素对象的方法        getEle();        &lt;/script&gt;    &lt;/head&gt;    &lt;!-- onload事件：在文档解析完成之后，才会触发该事件 --&gt;    &lt;body onload=&quot;getEle()&quot;&gt;        &lt;p id=&quot;p1&quot;&gt; 段落内容-1 &lt;/p&gt;        &lt;p id=&quot;p1&quot;&gt; 段落内容-2 &lt;/p&gt;        &lt;input id=&quot;username&quot; value=&quot;admin&quot; type=&quot;text&quot; /&gt;    &lt;/body&gt;        &lt;!-- &lt;script&gt;    // 整个的HTML文档会被转换成一个 document 的对象    // 声明获取元素对象的方法    function getEle()&#123;        // 根据ID获取元素对象        // 获取id=p1的p元素        var p = document.getElementById(&quot;p1&quot;);        // 注意：浏览器解析HTML文档，是自上而下解析的；        // 如果获取元素对象的js代码，在要获取的元素被解析之前执行，则无法获取元素对象        // 解决方式有两种        // 1、将获取元素对象的js代码，放到被获取的元素之后        console.log(p);    &#125;    // 调用获取元素对象的方法    getEle();    &lt;/script&gt; --&gt;&lt;/html&gt;</code></pre><p>获取多个元素对象</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;p id=&quot;p1&quot; class=&quot;p1&quot; name=&quot;n1&quot;&gt; 段落内容-1 &lt;/p&gt;        &lt;p id=&quot;p1&quot; class=&quot;p1 p2&quot; name=&quot;n1&quot;&gt; 段落内容-2 &lt;/p&gt;        &lt;input id=&quot;username&quot; class=&quot;p2&quot; name=&quot;n2&quot; value=&quot;admin&quot; type=&quot;text&quot; /&gt;    &lt;/body&gt;    &lt;script&gt;    function getEles()&#123;        // 获取多个元素        // getElementsByClassName(class属性值)：获取所有class属性含有参数值的元素对象        // 注意：IE浏览器不支持getElementsByClassName方法        var arr = document.getElementsByClassName(&quot;p1&quot;);        console.log(arr);        console.log(arr[0]);        console.log(arr[1]);        // getElementsByName(name属性值):获取所有name属性和参数值相同的元素对象        var arrByName = document.getElementsByName(&quot;n1&quot;);        console.log(arrByName);                // getElementsByTagName(标签名):根据标签的名称获取元素对象        var arrByTagName = document.getElementsByTagName(&quot;p&quot;);        console.log(arrByTagName);        console.log(arrByTagName[0]);        console.log(arrByTagName[1]);        console.log(arrByTagName[&quot;n1&quot;]);        console.log(arrByTagName[&quot;p1&quot;]);        console.log(arrByTagName.n1);        console.log(arrByTagName.p1);            &#125;    getEles();    &lt;/script&gt;&lt;/html&gt;</code></pre><h2 id="获取元素内容"><a href="#获取元素内容" class="headerlink" title="获取元素内容"></a>获取元素内容</h2><p><img src="https://s3.bmp.ovh/imgs/2021/09/3b5e7dbc790368b5.png"><br>获取和设置元素的内容</p><pre><code>&lt;!DOCTYPE html&gt;&lt;h获取和设置元素的内容tml&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;获取和设置元素的内容&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;p id=&quot;p1&quot;&gt; 段落内容-1 &lt;/p&gt;        &lt;p id=&quot;p2&quot;&gt; pre --- &lt;span&gt;段落内容-2&lt;/span&gt; --- next &lt;/p&gt;                &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt;        &lt;p id=&quot;p4&quot;&gt;&lt;/p&gt;        &lt;p id=&quot;p5&quot;&gt;&lt;/p&gt;        &lt;p id=&quot;p6&quot;&gt;&lt;/p&gt;        &lt;script&gt;        // 获取元素的内容        function getContent()&#123;            // 1、获取元素            var p = document.getElementById(&quot;p1&quot;);            // 2、获取元素的内容            console.log(&quot;innerHTML获取元素内容：&quot; + p.innerHTML);            console.log(&quot;innerText获取元素内容：&quot; + p.innerText);            // IE浏览器不支持textContent            console.log(&quot;textContent获取元素内容：&quot; + p.textContent);                                    var p2 = document.getElementById(&quot;p2&quot;);            // 如果元素内容中包含HTML标签，则innerHTML获取的内容是含HTML标签的，而innerText和textContent获取的内容是不含HTML标签的（只获取文本内容）            console.log(&quot;innerHTML获取元素内容：&quot; + p2.innerHTML);            console.log(&quot;innerText获取元素内容：&quot; + p2.innerText);            console.log(&quot;textContent获取元素内容：&quot; + p2.textContent);                                    var p3 = document.getElementById(&quot;p3&quot;);            p3.innerHTML = &quot;abc&quot;;            var p4 = document.getElementById(&quot;p4&quot;);            p4.innerText = &quot;abc&quot;;            var p5 = document.getElementById(&quot;p5&quot;);            // 如果设置的元素内容中包含HTML标签            // 使用innerHTML设置，则会解析HTML标签            // 使用innerText设置，不会解析HTML标签，而是将HTML标签作为字符串（文本）显示在页面上            p5.innerHTML = &quot;&lt;font color=&#39;red&#39;&gt; abc &lt;/font&gt;&quot;;            var p6 = document.getElementById(&quot;p6&quot;);            p6.innerText = &quot;&lt;font color=&#39;red&#39;&gt; abc &lt;/font&gt;&quot;;                    &#125;        getContent();        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>获取和设置元素的属性2</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;获取和设置元素的属性&lt;/title&gt;        &lt;style&gt;        .message&#123;            color: red;            padding: 0px 10px;            margin: 0px 5px;        &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--         id、class、style：大部分元素都有的原生属性        name、type、value：表单控件拥有的原生属性        src、title、alt：img元素的原生属性        href、target：a元素的原生属性        --&gt;        用户名：&lt;input id=&quot;username&quot; type=&quot;text&quot; /&gt;&lt;span id=&quot;username_msg&quot; class=&quot;message&quot;&gt;&lt;/span&gt;        &lt;br /&gt;        密码：&lt;input id=&quot;password&quot; name=&quot;pass&quot; type=&quot;password&quot; /&gt;&lt;span id=&quot;password_msg&quot; class=&quot;message&quot;&gt;&lt;/span&gt;        &lt;br /&gt;        &lt;!-- 点击该按钮时，触发onclick事件，事件被触发就会执行testAttribute() --&gt;        &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;testAttribute();&quot; /&gt;                &lt;span id=&quot;span1&quot; name=&quot;span_name&quot; value=&quot;span_value&quot;&gt;&lt;/span&gt;                &lt;script&gt;        function testAttribute()&#123;            // 1、获取元素对象            var username = document.getElementById(&quot;username&quot;);            // 2、获取元素的原生属性值：元素对象.原生属性名            var username_value = username.value;            if(username_value == &quot;&quot;)&#123;                document.getElementById(&quot;username_msg&quot;).innerHTML = &quot;用户名不能为空&quot;;            &#125; else &#123;                document.getElementById(&quot;username_msg&quot;).innerHTML = &quot;&quot;;                console.log(&quot;username = &quot; + username_value);            &#125;                        var password = document.getElementById(&quot;password&quot;);            var password_value = password.value;                console.log(&quot;password_name = &quot; + password.name);            if(password_value == &quot;&quot; || password_value == null)&#123;                document.getElementById(&quot;password_msg&quot;).innerHTML = &quot;密码不能为空&quot;;            &#125; else &#123;                document.getElementById(&quot;password_msg&quot;).innerHTML = &quot;&quot;;                password.value += &quot;456&quot;;                console.log(&quot;password = &quot; + password.value);            &#125;                        var span = document.getElementById(&quot;span1&quot;);            console.log(&quot;span的name值：&quot; + span.name);            // setAttribute(&quot;属性名&quot;,&quot;值&quot;); 设置属性值            span.setAttribute(&quot;value&quot;,&quot;aaaaaaaaaaaaaaaaa&quot;);            // getAttribute(&quot;非原生属性名&quot;)：获取指定的属性值（非原生属性）            // getAttribute(&quot;原生属性名&quot;)：IE支持、Google浏览器不支持            console.log(&quot;span的值：&quot; + span.getAttribute(&quot;value&quot;));                        // 获取元素属性的集合：元素对象.attributes;            var attrs = span.attributes;            console.log(attrs);            // 修改指定的属性值            attrs[1].value = &quot;bbbbbbbbbbbbb&quot;;            // 获取指定属性的值            console.log(&quot;id=&quot; + attrs[0].value);            console.log(&quot;value=&quot; + attrs[1].value);                                    console.log(&quot;getAttributeNode = &quot; + span.getAttributeNode(&quot;value&quot;).value)        &#125;                &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>获取单选框，复选框和下拉列表</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input name=&quot;sex&quot; type=&quot;radio&quot; value=&quot;男&quot; /&gt;男        &lt;input name=&quot;sex&quot; type=&quot;radio&quot; value=&quot;女&quot; /&gt;女        &lt;br /&gt;        &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; value=&quot;吃饭&quot; /&gt;吃饭        &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; value=&quot;睡觉&quot; /&gt;睡觉        &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; value=&quot;打豆豆&quot; /&gt;打豆豆        &lt;br /&gt;        &lt;select id=&quot;city&quot; name=&quot;city&quot;&gt;            &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;            &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt;            &lt;option value=&quot;guangzhou&quot;&gt;广州&lt;/option&gt;        &lt;/select&gt;        &lt;br /&gt;        &lt;input type=&quot;button&quot; value=&quot;测试&quot; onclick=&quot;test()&quot;/&gt;                &lt;script&gt;        function test()&#123;            var sex = document.getElementsByName(&quot;sex&quot;);            for(var i = 0; i &lt; sex.length; i++ )&#123;                // 获取单选框是否被选中的状态                console.log(sex[i].checked);                // 输出被选中的值            &#125;            var hobby = document.getElementsByName(&quot;hobby&quot;);            for(var i = 0; i &lt; hobby.length; i++ )&#123;                // 获取复选框是否被选中的状态                console.log(hobby[i].checked);                // 输出被选中的值            &#125;                        var select = document.getElementById(&quot;city&quot;);            // 获取被选中的option的value值                console.log(select.value);                                &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="子元素"><a href="#子元素" class="headerlink" title="子元素"></a>子元素</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;子元素&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;ul id=&quot;list&quot;&gt;            &lt;li id=&quot;li_id&quot; class=&quot;li_class&quot; onclick=&quot;changeColor(this)&quot;&gt;电脑数码&lt;/li&gt;            &lt;li class=&quot;li_class&quot; onclick=&quot;changeColor(this)&quot;&gt;大小家电&lt;/li&gt;            &lt;li onclick=&quot;changeColor(this)&quot;&gt;厨卫用品&lt;/li&gt;            &lt;li onclick=&quot;changeColor(this)&quot;&gt;母婴用品&lt;/li&gt;            &lt;li onclick=&quot;changeColor(this)&quot;&gt;户外用品&lt;/li&gt;        &lt;/ul&gt;        &lt;div&gt;&lt;/div&gt;        &lt;script&gt;        function changeColor(li)&#123;            var ul = document.getElementById(&quot;list&quot;);            var childs = ul.children;            // 现将所有的li都设置成蓝色            for(var i=0;i&lt;childs.length;i++)&#123;                childs[i].style.color = &quot;blue&quot;;            &#125;            // 再将被点击的li元素设置成红色            li.style.color = &quot;red&quot;;        &#125;        // 获取ul元素        var ul = document.getElementById(&quot;list&quot;);        var list = ul.getElementsByTagName(&quot;li&quot;);        console.log(list);        list = ul.getElementsByClassName(&quot;li_class&quot;);        console.log(list);        // hidden：获取和设置隐藏的状态                // childElementCount:获取子元素的个数        // parentNode：父节点        // childNodes（集合类型：NodeList）：获取子节点的集合（集合中的每个元素都是一个Node（节点）对象）（注意：HTML中的换行会被当做文本节点（Text Node））        // firstChild：获取第一个节点        // lastChild：获取最后一个节点        // previousSibling：当前节点的前一个节点        // nextSibling：当前节点的下个节点                // parentElement：父元素        // children（集合类型：HTMLCollection）：获取子元素的集合（只获取HTML元素，不包含换行空格等）        // firstElementChild:获取第一个元素（IE不支持）        // lastElementChild：获取最后一个元素（IE不支持）        // previousElementSibling：当前元素的前一个元素（IE不支持）        // nextElementSibling：当前元素的下一个元素（IE不支持）        console.log(ul);        console.log(ul.children);        var childs = ul.children;        for(var i=0;i&lt;childs.length;i++)&#123;            childs[i].style.color = &quot;blue&quot;;        &#125;        var firstLi = ul.firstElementChild;        firstLi.style.color = &quot;red&quot;;                &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="创建和删除子元素"><a href="#创建和删除子元素" class="headerlink" title="创建和删除子元素"></a>创建和删除子元素</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;创建和添加子元素&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;parent_div&quot;&gt;            &lt;input type=&quot;button&quot; value=&quot;添加用户&quot; onclick=&quot;addUser();&quot; /&gt;            &lt;div id=&quot;title&quot;&gt;                &lt;span&gt; 用户名 &lt;/span&gt;                &lt;span&gt; 密码 &lt;/span&gt;                &lt;span&gt; 操作 &lt;/span&gt;            &lt;/div&gt;            &lt;div id=&quot;content&quot;&gt;                &lt;div&gt;                    &lt;span&gt; 张三 &lt;/span&gt;                    &lt;span&gt; abc &lt;/span&gt;                    &lt;span&gt;                         &lt;input type=&quot;button&quot; value=&quot;删除用户&quot; onclick=&quot;delUser(this.parentElement.parentElement);&quot; /&gt;                    &lt;/span&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;script&gt;        function addUser()&#123;            var content = document.getElementById(&quot;content&quot;);            // 方式一：通过innerHTML属性添加子元素            // 1、首先获取原内容            // var html = content.innerHTML;            // // 追加内容            // html += &quot;&lt;div&gt;&quot;             //     + &quot;&lt;span&gt; &lt;input id=&#39;username&#39; type=&#39;text&#39; /&gt; &lt;/span&gt;&quot;            //     + &quot;&lt;span&gt; &lt;input id=&#39;password&#39; type=&#39;text&#39; /&gt; &lt;/span&gt;&quot;            //     + &quot;&lt;span&gt; &lt;input type=&#39;button&#39; value=&#39;保存&#39; onclick=&#39;save(this);&#39; /&gt;&quot;             //     + &quot;&lt;input type=&#39;button&#39; value=&#39;删除&#39;  onclick=&#39;del(this);&#39; /&gt; &lt;/span&gt;&quot;            //     + &quot;&lt;/div&gt;&quot;;            // // 将追加后的内容赋值到innerHTML上            // content.innerHTML = html;                        // 方式二：通过JavaScript代码创建            // 创建元素            var div = document.createElement(&quot;div&quot;);            var spanUsername = document.createElement(&quot;span&quot;);            var spanPassword = document.createElement(&quot;span&quot;);            var spanButton = document.createElement(&quot;span&quot;);            var inputUsername = document.createElement(&quot;input&quot;);            var inputPassword = document.createElement(&quot;input&quot;);            var inputSave = document.createElement(&quot;input&quot;);            inputSave.value = &#39;保存&#39;;            inputSave.type = &#39;button&#39;;            inputSave.setAttribute(&quot;onclick&quot;,&#39;save(this);&#39;);            var inputDelete = document.createElement(&quot;input&quot;);            inputDelete.value = &#39;删除&#39;;            inputDelete.type = &#39;button&#39;;            inputDelete.setAttribute(&quot;onclick&quot;,&#39;del(this);&#39;);            // inputDelete.onclick = &quot;del(this);&quot;;            // 组装对象            spanUsername.appendChild(inputUsername);            spanPassword.appendChild(inputPassword);            spanButton.appendChild(inputSave);            spanButton.appendChild(inputDelete);            div.appendChild(spanUsername);            div.appendChild(spanPassword);            div.appendChild(spanButton);            content.appendChild(div);        &#125;        function delUser(div)&#123;            // 删除当前元素            div.remove();        &#125;        function del(btn)&#123;            // 删除元素            btn.parentElement.parentElement.remove();        &#125;        function save(btn)&#123;            // 获取保存按钮的父元素            var btnSpan = btn.parentElement;            // 获取password的父元素            var passwrodSpan = btnSpan.previousElementSibling;            // 获取password输入框            var passwordInput = passwrodSpan.firstElementChild;            // 获取密码框输入的值            var passwrodValue = passwordInput.value;            // 将密码框替换成密码框中输入的值            passwrodSpan.innerHTML = passwrodValue;                                    // 获取username的父元素            var usernameSpan = passwrodSpan.previousElementSibling;            // 获取username输入框            var usernameInput = usernameSpan.firstElementChild;            // 获取文本框输入的值            var usernameValue = usernameInput.value;            // 将文本框替换成文本框中输入的值            usernameSpan.innerHTML = usernameValue;                        btn.remove();        &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="获取焦点的事件-和-失去焦点的事件"><a href="#获取焦点的事件-和-失去焦点的事件" class="headerlink" title="获取焦点的事件 和 失去焦点的事件"></a>获取焦点的事件 和 失去焦点的事件</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--         onfocus：获取焦点的事件        onblur：失去焦点的事件        --&gt;        &lt;input id=&quot;username&quot; value=&quot;请输入用户名&quot;         onfocus=&quot;clearValue(this)&quot;         onblur=&quot;fillValue(this)&quot; /&gt;        &lt;!-- html5中提供placeholder属性可以实现相同的功能 --&gt;        &lt;input placeholder=&quot;请输入&quot; /&gt;        &lt;script&gt;            function clearValue(input)&#123;                if(input.value == &quot;请输入用户名&quot;)&#123;                    input.value = &quot;&quot;;                &#125;            &#125;            function fillValue(input)&#123;                if(input.value == &quot;&quot;)&#123;                    input.value = &quot;请输入用户名&quot;;                &#125;            &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="change事件"><a href="#change事件" class="headerlink" title="change事件"></a>change事件</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;select onchange=&quot;ch(this)&quot;&gt;            &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;            &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt;            &lt;option value=&quot;guangzhou&quot;&gt;广州&lt;/option&gt;        &lt;/select&gt;        &lt;script&gt;        function ch(select)&#123;            console.log(select.value);        &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="级联联动"><a href="#级联联动" class="headerlink" title="级联联动"></a>级联联动</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;三级联动&lt;/title&gt;    &lt;/head&gt;    &lt;body onload=&quot;init()&quot;&gt;        &lt;select id=&quot;provinces&quot; onchange=&quot;changeProvincesOption(this)&quot;&gt;&lt;/select&gt;        &lt;select id=&quot;city&quot; onchange=&quot;changeCityOption(this)&quot;&gt;&lt;/select&gt;        &lt;select id=&quot;area&quot;&gt;&lt;/select&gt;        &lt;script&gt;        // 声明在方法外，是全局变量        // 声明在方法内，是局部变量        // 创建一个country对象        var country = &#123;&quot;provinces&quot;:[                &#123;                    &quot;name&quot;:&quot;北京&quot;,                    &quot;value&quot;:&quot;beijing&quot;,                    &quot;city&quot;:[                        &#123;                            &quot;name&quot;:&quot;北京&quot;,                            &quot;value&quot;:&quot;beijing&quot;,                            &quot;area&quot;:[                                &#123;                                    &quot;name&quot;:&quot;海淀区&quot;,                                    &quot;value&quot;:&quot;haidian&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;朝阳区&quot;,                                    &quot;value&quot;:&quot;chaoyang&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;昌平区&quot;,                                    &quot;value&quot;:&quot;changping&quot;                                &#125;]                        &#125;                    ]                &#125;,&#123;                    &quot;name&quot;:&quot;上海&quot;,                    &quot;value&quot;:&quot;shanghai&quot;,                    &quot;city&quot;:[                        &#123;                            &quot;name&quot;:&quot;上海&quot;,                            &quot;value&quot;:&quot;shanghai&quot;,                            &quot;area&quot;:[                                &#123;                                    &quot;name&quot;:&quot;浦东区&quot;,                                    &quot;value&quot;:&quot;pudong&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;宝山区&quot;,                                    &quot;value&quot;:&quot;baoshan&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;虹口区&quot;,                                    &quot;value&quot;:&quot;hongkou&quot;                                &#125;]                        &#125;                    ]                &#125;,&#123;                    &quot;name&quot;:&quot;广州&quot;,                    &quot;value&quot;:&quot;guangzhou&quot;,                    &quot;city&quot;:[                        &#123;                            &quot;name&quot;:&quot;广州&quot;,                            &quot;value&quot;:&quot;guangzhou&quot;,                            &quot;area&quot;:[                                &#123;                                    &quot;name&quot;:&quot;白云区&quot;,                                    &quot;value&quot;:&quot;baiyun&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;朝阳区&quot;,                                    &quot;value&quot;:&quot;chaoyang&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;昌平区&quot;,                                    &quot;value&quot;:&quot;changping&quot;                                &#125;]                        &#125;                    ]                &#125;,&#123;                    &quot;name&quot;:&quot;内蒙古&quot;,                    &quot;value&quot;:&quot;neimenggu&quot;,                    &quot;city&quot;:[                        &#123;                            &quot;name&quot;:&quot;呼和浩特&quot;,                            &quot;value&quot;:&quot;huhehaote&quot;,                            &quot;area&quot;:[                                &#123;                                    &quot;name&quot;:&quot;新城区&quot;,                                    &quot;value&quot;:&quot;xingcheng&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;赛罕区&quot;,                                    &quot;value&quot;:&quot;saihan&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;回民区&quot;,                                    &quot;value&quot;:&quot;huimin&quot;                                &#125;]                        &#125;,                        &#123;                            &quot;name&quot;:&quot;赤峰市&quot;,                            &quot;value&quot;:&quot;chifeng&quot;,                            &quot;area&quot;:[                                &#123;                                    &quot;name&quot;:&quot;阿鲁科尔沁旗&quot;,                                    &quot;value&quot;:&quot;alukeerqinqi&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;红山区&quot;,                                    &quot;value&quot;:&quot;hongshan&quot;                                &#125;]                        &#125;                    ]                &#125;            ]&#125;;                    // 初始化的方法（将数据填充到select中）        // 声明一个用于保存省份全局变量，用来保存当前选中的省份对象        var provinces = null;        function init()&#123;            // 获取省份的select            var provinces = document.getElementById(&quot;provinces&quot;);            // 获取城市的select            var city = document.getElementById(&quot;city&quot;);            // 获取行政区的select            var area = document.getElementById(&quot;area&quot;);                        /*************************** 填充省份的select - 开始 *******************************/            var provincesOption = &quot;&quot;;            // 循环填充省份            for(var i=0;i&lt;country.provinces.length;i++)&#123;                provincesOption += &quot;&lt;option value=&#39;&quot;                                 + country.provinces[i].value                                + &quot;&#39;&gt;&quot;                                + country.provinces[i].name                                + &quot;&lt;/option&gt;&quot;;            &#125;            provinces.innerHTML = provincesOption;            /*************************** 填充省份的select - 结束 *******************************/                                    changeProvincesOption(provinces);                    &#125;                /*            参数：省份select对象        */        function changeProvincesOption(provincesSelect)&#123;                        /*************************** 循环查找被选中的省份对象 - 开始 *******************************/            // 获取被选中省份的option的value值            var provincesValue = provincesSelect.value;            // var provinces = null;            for(var i = 0;i &lt; country.provinces.length;i++)&#123;                if(country.provinces[i].value == provincesValue)&#123;                    // 给全局变量provinces赋值（当前选中的对象）                    provinces = country.provinces[i];                &#125;            &#125;            /*************************** 循环查找被选中的省份对象 - 结束 *******************************/                                    /*************************** 填充城市的select - 开始 *******************************/            // 获取当前选中的省份下，所有的城市            var cityList = provinces.city;            var cityOption = &quot;&quot;;            // 循环填充城市            for(var i=0;i&lt;cityList.length;i++)&#123;                cityOption += &quot;&lt;option value=&#39;&quot;                                 + cityList[i].value                                + &quot;&#39;&gt;&quot;                                + cityList[i].name                                + &quot;&lt;/option&gt;&quot;;            &#125;            document.getElementById(&quot;city&quot;).innerHTML = cityOption;            /*************************** 填充城市的select - 开始 *******************************/                        changeCityOption(provinces.city[0]);        &#125;                /*        参数：当前被选中的城市select对象        */        function changeCityOption(citySelect)&#123;            /*************************** 查找当前被选中的city对象 - 开始 *******************************/            // 获取当前选中的城市的option的value值            var cityValue = citySelect.value;            for(var i=0;i&lt;provinces.city.length;i++)&#123;                if(cityValue == provinces.city[i].value)&#123;                    changeCity(provinces,provinces.city[i]);                    break;                &#125;            &#125;            /*************************** 查找当前被选中的city对象 - 开始 *******************************/        &#125;        /*        参数一：当前选中的省份        参数二：当前选中的城市        */        function changeCity(provinces,city)&#123;            // 获取第一个省份的所有城市的集合            var cityList = provinces.city;                        if(city)&#123;                changeArea(city);            &#125; else &#123;                changeArea(cityList[0]);            &#125;        &#125;                /*        参数：当前选中的城市对象        */        function changeArea(city)&#123;            /*************************** 填充行政区的select - 开始 *******************************/            // 获取第一个省份的第一个城市的所有行政区的集合            var areaList = city.area;            var areaOption = &quot;&quot;;            // 循环填充城市            for(var i=0;i&lt;areaList.length;i++)&#123;                areaOption += &quot;&lt;option value=&#39;&quot;                                 + areaList[i].value                                + &quot;&#39;&gt;&quot;                                + areaList[i].name                                + &quot;&lt;/option&gt;&quot;;            &#125;            area.innerHTML = areaOption;            /*************************** 填充行政区的select - 结束 *******************************/        &#125;                &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="三级联动"><a href="#三级联动" class="headerlink" title="三级联动"></a>三级联动</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;三级联动&lt;/title&gt;    &lt;/head&gt;    &lt;body onload=&quot;init()&quot;&gt;        &lt;span id=&quot;provincesSpan&quot;&gt;&lt;/span&gt;        &lt;span id=&quot;citySpan&quot;&gt;&lt;/span&gt;        &lt;span id=&quot;areaSpan&quot;&gt;&lt;/span&gt;        &lt;script&gt;        // 声明在方法外，是全局变量        // 声明在方法内，是局部变量        // 创建一个country对象        var country = &#123;&quot;provinces&quot;:[                &#123;                    &quot;name&quot;:&quot;北京&quot;,                    &quot;value&quot;:&quot;beijing&quot;,                    &quot;city&quot;:[                        &#123;                            &quot;name&quot;:&quot;北京&quot;,                            &quot;value&quot;:&quot;beijing&quot;,                            &quot;area&quot;:[                                &#123;                                    &quot;name&quot;:&quot;海淀区&quot;,                                    &quot;value&quot;:&quot;haidian&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;朝阳区&quot;,                                    &quot;value&quot;:&quot;chaoyang&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;昌平区&quot;,                                    &quot;value&quot;:&quot;changping&quot;                                &#125;]                        &#125;                    ]                &#125;,&#123;                    &quot;name&quot;:&quot;上海&quot;,                    &quot;value&quot;:&quot;shanghai&quot;,                    &quot;city&quot;:[                        &#123;                            &quot;name&quot;:&quot;上海&quot;,                            &quot;value&quot;:&quot;shanghai&quot;,                            &quot;area&quot;:[                                &#123;                                    &quot;name&quot;:&quot;浦东区&quot;,                                    &quot;value&quot;:&quot;pudong&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;宝山区&quot;,                                    &quot;value&quot;:&quot;baoshan&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;虹口区&quot;,                                    &quot;value&quot;:&quot;hongkou&quot;                                &#125;]                        &#125;                    ]                &#125;,&#123;                    &quot;name&quot;:&quot;广州&quot;,                    &quot;value&quot;:&quot;guangzhou&quot;,                    &quot;city&quot;:[                        &#123;                            &quot;name&quot;:&quot;广州&quot;,                            &quot;value&quot;:&quot;guangzhou&quot;,                            &quot;area&quot;:[                                &#123;                                    &quot;name&quot;:&quot;白云区&quot;,                                    &quot;value&quot;:&quot;baiyun&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;朝阳区&quot;,                                    &quot;value&quot;:&quot;chaoyang&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;昌平区&quot;,                                    &quot;value&quot;:&quot;changping&quot;                                &#125;]                        &#125;                    ]                &#125;,&#123;                    &quot;name&quot;:&quot;内蒙古&quot;,                    &quot;value&quot;:&quot;neimenggu&quot;,                    &quot;city&quot;:[                        &#123;                            &quot;name&quot;:&quot;呼和浩特&quot;,                            &quot;value&quot;:&quot;huhehaote&quot;,                            &quot;area&quot;:[                                &#123;                                    &quot;name&quot;:&quot;新城区&quot;,                                    &quot;value&quot;:&quot;xingcheng&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;赛罕区&quot;,                                    &quot;value&quot;:&quot;saihan&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;回民区&quot;,                                    &quot;value&quot;:&quot;huimin&quot;                                &#125;]                        &#125;,                        &#123;                            &quot;name&quot;:&quot;赤峰市&quot;,                            &quot;value&quot;:&quot;chifeng&quot;,                            &quot;area&quot;:[                                &#123;                                    &quot;name&quot;:&quot;阿鲁科尔沁旗&quot;,                                    &quot;value&quot;:&quot;alukeerqinqi&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;红山区&quot;,                                    &quot;value&quot;:&quot;hongshan&quot;                                &#125;]                        &#125;                    ]                &#125;            ]&#125;;                                                            function init()&#123;                        // 获取省份的select            var provincesSpan = document.getElementById(&quot;provincesSpan&quot;);                        /*************************** 创建省份的select - 开始 *******************************/            var provincesSelect = &#39;&lt;select id=&quot;provinces&quot; onchange=&quot;changeProvinces(this)&quot;&gt;&#39;;            // 循环创建省份的option            for(var i=0;i&lt;country.provinces.length;i++)&#123;                provincesSelect += &quot;&lt;option value=&#39;&quot;                                 + country.provinces[i].value                                + &quot;&#39;&gt;&quot;                                + country.provinces[i].name                                + &quot;&lt;/option&gt;&quot;;            &#125;            provincesSelect += &#39;&lt;/select&gt;&#39;;            provincesSpan.innerHTML = provincesSelect;            /*************************** 创建省份的select - 结束 *******************************/                        changeProvinces(provincesSpan.firstChild);                    &#125;                /*            参数：省份select对象        */        function changeProvinces(provincesSelect)&#123;        // 获取城市的select        var citySpan = document.getElementById(&quot;citySpan&quot;);                        /*************************** 循环查找被选中的省份对象 - 开始 *******************************/            var provincesIndex = provincesSelect.selectedIndex;            provincesIndex = (provincesIndex &lt; 0 ? 0 : provincesIndex);            /*************************** 循环查找被选中的省份对象 - 结束 *******************************/                                    /*************************** 创建城市的select - 开始 *******************************/            // 获取当前选中的省份下，所有的城市            var cityList = country.provinces[provincesIndex].city;            var citySelect = &#39;&lt;select id=&quot;city&quot; onchange=&quot;changeCity(this)&quot;&gt;&#39;;            // 循环创建城市的option            for(var i=0;i&lt;cityList.length;i++)&#123;                citySelect += &quot;&lt;option value=&#39;&quot;                                 + cityList[i].value                                + &quot;&#39;&gt;&quot;                                + cityList[i].name                                + &quot;&lt;/option&gt;&quot;;            &#125;            citySelect += &#39;&lt;/select&gt;&#39;;            citySpan.innerHTML = citySelect;            /*************************** 创建城市的select - 开始 *******************************/                        changeCity(citySpan.firstChild);        &#125;                /*        参数：当前被选中的城市select对象        */        function changeCity(citySelect)&#123;        // 获取行政区的select        var areaSpan = document.getElementById(&quot;areaSpan&quot;);            var provincesIndex = provinces.selectedIndex;            var cityIndex = citySelect.selectedIndex;            provincesIndex = (provincesIndex &lt; 0 ? 0 : provincesIndex);            cityIndex = (cityIndex &lt; 0 ? 0 : cityIndex);                        var city = country.provinces[provincesIndex].city[cityIndex];                /*************************** 创建行政区的select - 开始 *******************************/                // 获取第一个省份的第一个城市的所有行政区的集合                var areaList = city.area;                var areaOption = &#39;&lt;select id=&quot;area&quot;&gt;&#39;;                // 循环创建行政区的option                for(var i=0;i&lt;areaList.length;i++)&#123;                    areaOption += &quot;&lt;option value=&#39;&quot;                                     + areaList[i].value                                    + &quot;&#39;&gt;&quot;                                    + areaList[i].name                                    + &quot;&lt;/option&gt;&quot;;                &#125;                areaOption += &#39;&lt;/select&gt;&#39;;                areaSpan.innerHTML = areaOption;                /*************************** 创建行政区的select - 结束 *******************************/                    &#125;                &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;鼠标事件&lt;/title&gt;        &lt;style&gt;        div&#123;            width: 200px;            height: 200px;            background-color: aqua;        &#125;        .inner_div&#123;            width: 100px;            height: 100px;            background-color: red;        &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--         onmouseenter：鼠标移入元素的事件（只要没有移出父元素的范围，就不会再次执行）        mouseleave：鼠标移出元素的事件（在父元素和子元素之间移入移出不会触发onmouseenter和mouseleave事件）        onmouseover：鼠标移入元素的事件（在父元素和子元素之间移入移出也会触发onmouseover和onmouseout事件）        onmouseout：鼠标移出元素的事件        onmousemove：鼠标在元素中移动的事件        onmousedown：鼠标按键按下的事件        onmouseup：松开鼠标按键的事件        --&gt;        &lt;div         onmouseover=&quot;mouseIn()&quot;         onmouseout=&quot;mouseOut()&quot;        onmousemove=&quot;mouseMove()&quot;        onmousedown=&quot;mouseDown()&quot;        onmouseup=&quot;mouseUp()&quot;        onmouseenter=&quot;mouseEnter()&quot;&gt;         &lt;div class=&quot;inner_div&quot;&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;!-- event：当前发生的事件对象 --&gt;        &lt;div onmousedown=&quot;mouseDown(event)&quot;&gt; div &lt;/div&gt;        &lt;script&gt;        function mouseIn()&#123;            console.log(&quot;mouse in&quot;);        &#125;        function mouseOut()&#123;            console.log(&quot;mouse Out&quot;);        &#125;        function mouseMove()&#123;            console.log(&quot;mouse Move&quot;);        &#125;        function mouseDown(event)&#123;            // event.button: 0:鼠标左键  1：鼠标滚轮  2：鼠标右键            // event.altKey: 按下鼠标时，是否按住了Alt建            // event.ctrlKey: 按下鼠标时，是否按住了Ctrl建            // event.shiftKey: 按下鼠标时，是否按住了Shift建            // event.target：发送事件的目标对象（被点击的元素对象）            console.log(event);            // console.log(&quot;mouse Down&quot;);        &#125;        function mouseUp()&#123;            console.log(&quot;mouse Up&quot;);        &#125;        function mouseEnter()&#123;            console.log(&quot;mouse Enter&quot;);        &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;键盘事件&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--         onkeydown：键盘的按键按下时触发的事件        onkeyup：键盘的按键松开（释放）时触发的事件        onkeypress：键盘的按键按下并松开（释放）时触发的事件        --&gt;        &lt;input id=&quot;password&quot; onkeydown=&quot;keyDown(event)&quot;         onkeyup=&quot;keyUp(event)&quot;         onkeypress=&quot;keyPress(event)&quot; /&gt;        &lt;span id=&quot;message&quot;&gt;&lt;/span&gt;        &lt;script&gt;        function keyDown(e)&#123;            // e.altKey: 按下键盘的按键时，是否按住了Alt建            // e.ctrlKey: 按下键盘的按键时，是否按住了Ctrl建            // e.shiftKey: 按下键盘的按键时，是否按住了Shift建            // e.key: 获取按下的按键字符            // e.keyCode: 获取按下的按键字符的ASCII码值            // e.KeyA: 获取键盘按键的编码            // console.log(e);            // 每次按下得到的文本框的值，都是按下之前的值            // var password = document.getElementById(&quot;password&quot;);            // console.log(password.value);        &#125;        function keyUp(e)&#123;            console.log(&quot;up&quot;);            // 每次按键抬起得到的文本框的值，都是输入之后的值            // var password = document.getElementById(&quot;password&quot;);            // console.log(password.value);        &#125;        function keyPress(e)&#123;            // console.log(&quot;press&quot;);            // 每次按下得到的文本框的值，都是按下之前的值            var password = document.getElementById(&quot;password&quot;);            console.log(password.value);            var message = document.getElementById(&quot;message&quot;);            if(password.value.length + 1 &lt; 6 || password.value.length &gt; 19)&#123;                message.innerHTML = &quot;密码的长度应在6~20之间&quot;;            &#125; else &#123;                message.innerHTML = &quot;&quot;;            &#125;        &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="selet-事件"><a href="#selet-事件" class="headerlink" title="selet 事件"></a>selet 事件</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--         checkbox、radio、select选中状态发送变化时，触发的是 change事件，而不是 select事件        onselect：文本被选中的事件（&lt;input&gt;和&lt;textarea&gt;支持）        --&gt;        &lt;input id=&quot;input&quot; type=&quot;text&quot; onselect=&quot;sel(event);sel1();&quot; /&gt;        &lt;div onselect=&quot;sel(event)&quot;&gt;            fjdklsajflkdsajkfjkldsajl        &lt;/div&gt;        &lt;select onchange=&quot;sel(event)&quot;&gt;            &lt;option&gt;1&lt;/option&gt;            &lt;option&gt;2&lt;/option&gt;            &lt;option&gt;3&lt;/option&gt;        &lt;/select&gt;        &lt;script&gt;        function sel(event)&#123;            var input = document.getElementById(&quot;input&quot;);            console.log(input.value);            console.log(event);        &#125;        function sel1(event)&#123;            console.log(&quot;11111&quot;);        &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="表单验证（sumbit事件）"><a href="#表单验证（sumbit事件）" class="headerlink" title="表单验证（sumbit事件）"></a>表单验证（sumbit事件）</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;表单验证&lt;/title&gt;        &lt;style&gt;        span&#123;            color:red;        &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- &lt;form action=&quot;http://www.baidu.com&quot; onsubmit=&quot;return sub();&quot;&gt; --&gt;        &lt;form id=&quot;myform&quot; action=&quot;http://www.baidu.com&quot; onsubmit=&quot;return false;&quot;&gt;            &lt;!-- HTML5中新增required属性，如果表单控件中使用required，表示该控件必须输入值 --&gt;            用户名：&lt;input id=&quot;username&quot; required=&quot;required&quot; /&gt;&lt;span id=&quot;username_msg&quot;&gt;&lt;/span&gt;&lt;br /&gt;            密 码：&lt;input id=&quot;password&quot; type=&quot;password&quot; /&gt;&lt;span id=&quot;password_msg&quot;&gt;&lt;/span&gt;&lt;br /&gt;            爱 好：            &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; value=&quot;吃饭&quot; /&gt;吃饭            &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; value=&quot;睡觉&quot; /&gt;睡觉            &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; value=&quot;打豆豆&quot; /&gt;打豆豆            &lt;span id=&quot;hobby_msg&quot;&gt;&lt;/span&gt;&lt;br /&gt;            &lt;!--             type=&quot;submit&quot;：被点击时，默认会触发form的sumbit事件            注意：只有在form元素内，才会触发form的submit事件            --&gt;            &lt;!-- &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; --&gt;            &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;sub()&quot; /&gt;        &lt;/form&gt;        &lt;script&gt;        function sub()&#123;            var username = document.getElementById(&quot;username&quot;);            var password = document.getElementById(&quot;password&quot;);            var hobbys = document.getElementsByName(&quot;hobby&quot;);            var username_msg = document.getElementById(&quot;username_msg&quot;);            var username_msg = document.getElementById(&quot;username_msg&quot;);            var hobby_msg = document.getElementById(&quot;hobby_msg&quot;);            if(username.value == &quot;&quot;)&#123;                username_msg.innerHTML = &quot;用户名不能为空！&quot;;                return false;            &#125; else &#123;                username_msg.innerHTML = &quot;&quot;;            &#125;            if(password.value == &quot;&quot;)&#123;                password_msg.innerHTML = &quot;密码不能为空！&quot;;                return false;            &#125; else &#123;                password_msg.innerHTML = &quot;&quot;;            &#125;            if(password.value.length &lt; 6 || password.value.length &gt; 20)&#123;                password_msg.innerHTML = &quot;密码长度必须在 6 ~ 20 之间！&quot;;                return false;            &#125; else &#123;                password_msg.innerHTML = &quot;&quot;;            &#125;                        var result = false;            // 如果所有的复选框都没有选中，则循环 或 完之后，result为false            // 如果只要有一个复选框被选中，则循环 或 完之后，result为true            for(var i=0;i&lt;hobbys.length;i++)&#123;                var hobby = hobbys[i];                result = result || hobby.checked;            &#125;            if(!result)&#123;                hobby_msg.innerHTML = &quot;至少要选一个爱好&quot;;            &#125; else &#123;                hobby_msg.innerHTML = &quot;&quot;;            &#125;                        console.log(&quot;表单被提交了&quot;);                        // 获取form对象            // var myform = document.getElementById(&quot;myform&quot;);            // var myform = document.forms.myform;            // var myform = document.forms[0];            var myform = document.forms[&quot;myform&quot;];            // 提交表单            myform.submit();                        // 方法中return返回boolean值   true：提交表单   false：不提交表单            return result;        &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="输出信息"><a href="#输出信息" class="headerlink" title="输出信息"></a>输出信息</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--         alert：弹出的消息框，只有一个ok（确认）按钮        confirm：弹出的消息框，有一个ok（确认）按钮 和 一个cancel（取消）按钮                    如果点击ok（确认）按钮，该方法的返回值为true                      如果点击cancel（取消）按钮，该方法的返回值为false        prompt：弹出的消息框，有一个ok（确认）按钮 和 一个cancel（取消）按钮 和 一个输入框                    如果点击ok（确认）按钮，该方法的返回值为 用户输入的 值                      如果点击cancel（取消）按钮，该方法的返回值为 null        --&gt;        &lt;input type=&quot;button&quot; value=&quot;alert&quot; onclick=&quot;alert(&#39;弹出提示框&#39;)&quot; /&gt;        &lt;input type=&quot;button&quot; value=&quot;confirm&quot; onclick=&quot;var r = confirm(&#39;弹出提示框&#39;);alert(r)&quot; /&gt;        &lt;input type=&quot;button&quot; value=&quot;prompt&quot; onclick=&quot;var r = prompt(&#39;弹出提示框&#39;);alert(r)&quot; /&gt;        &lt;input type=&quot;button&quot; value=&quot;document.write&quot; onclick=&quot;w()&quot; /&gt;        &lt;script&gt;        function w()&#123;            // 向页面写入指定的内容（会覆盖文档中原有的所有内容）            document.write(&quot;&lt;div&gt;动态向页面中写入的内容&lt;/div&gt;&quot;);            console.log(&quot;向控制台输出的内容&quot;);                        var x = 9.656;            x.toFixed(0);           // 返回 10            x.toFixed(2);           // 返回 9.66            x.toFixed(4);           // 返回 9.6560            x.toFixed(6);           // 返回 9.656000        &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="搜索元素"><a href="#搜索元素" class="headerlink" title="搜索元素"></a>搜索元素</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;通过选择器获取元素对象&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;div1&quot; class=&quot;myclass&quot;&gt; div1 &lt;/div&gt;        &lt;div id=&quot;div2&quot; class=&quot;myclass&quot;&gt; div2 &lt;/div&gt;        &lt;div id=&quot;div3&quot;&gt; div3 &lt;/div&gt;                &lt;script&gt;        // querySelector:根据选择器，查找第一个匹配的元素对象        // querySelectorAll:根据选择器，查找所有匹配的元素对象        // 根据ID搜索元素（使用css中的ID选择器获取元素）        var searchById = document.querySelector(&quot;#div1&quot;);        console.log(searchById);                // 根据class搜索元素（使用css中的类选择器获取元素）        var searchByFirstClass = document.querySelector(&quot;.myclass&quot;);        console.log(searchByFirstClass);                var searchByAllClass = document.querySelectorAll(&quot;.myclass&quot;);        console.log(searchByAllClass);                        // 根据标签搜索元素（使用css中的标签选择器获取元素）        var searchByFirstTagName = document.querySelector(&quot;div&quot;);        console.log(searchByFirstTagName);                var searchByAllTagName = document.querySelectorAll(&quot;div&quot;);        console.log(searchByAllTagName);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="math"><a href="#math" class="headerlink" title="math"></a>math</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script&gt;        var random = Math.random();         document.write(random);        document.write(&quot;&lt;br/&gt;&quot;);        // 返回 0 至 100 之间的数        document.write(Math.floor(Math.random() * 101));        document.write(&quot;&lt;br/&gt;&quot;);        // 返回 1 至 10 之间的数        document.write(Math.floor(Math.random() * 10) + 1);            &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="js中的BOM对象"><a href="#js中的BOM对象" class="headerlink" title="js中的BOM对象"></a>js中的BOM对象</h1><h2 id="打开关闭窗口"><a href="#打开关闭窗口" class="headerlink" title="打开关闭窗口"></a>打开关闭窗口</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;button&quot; value=&quot;打开&quot; onclick=&quot;window.open(&#39;http://www.baidu.com&#39;)&quot; /&gt;        &lt;input type=&quot;button&quot; value=&quot;关闭&quot; onclick=&quot;window.close()&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="当前屏幕的参数"><a href="#当前屏幕的参数" class="headerlink" title="当前屏幕的参数"></a>当前屏幕的参数</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;当前屏幕的参数&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script&gt;        document.write(screen.width);        document.write(&quot;&lt;br /&gt;&quot;);        document.write(screen.height);        document.write(&quot;&lt;br /&gt;&quot;);        document.write(screen.availWidth);        document.write(&quot;&lt;br /&gt;&quot;);        document.write(screen.availHeight);        document.write(&quot;&lt;br /&gt;&quot;);        document.write(screen.colorDepth);        document.write(&quot;&lt;br /&gt;&quot;);        document.write(screen.pixelDepth);        document.write(&quot;&lt;br /&gt;&quot;);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="使用location的href属性连接页面"><a href="#使用location的href属性连接页面" class="headerlink" title="使用location的href属性连接页面"></a>使用location的href属性连接页面</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;button&quot; value=&quot;打开&quot; onclick=&quot;location.href = &#39;http://www.baidu.com&#39;&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="访问历史，前进和后退"><a href="#访问历史，前进和后退" class="headerlink" title="访问历史，前进和后退"></a>访问历史，前进和后退</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;a href=&quot;third.html&quot;&gt;第三页&lt;/a&gt;        &lt;input type=&quot;button&quot; value=&quot;前进&quot; onclick=&quot;history.go(1)&quot; /&gt;        &lt;!--         go(参数):正值（前进）  负值（后退）        --&gt;        &lt;input type=&quot;button&quot; value=&quot;后退&quot; onclick=&quot;history.go(-1)&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;content&quot;&gt;&lt;/div&gt;        &lt;script&gt;        // json格式的字符串（JSON串）        var jsonStr = &#39;&#123;&quot;id&quot;:1,&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;abc123&quot;,&quot;hobby&quot;:[&quot;吃饭&quot;,&quot;睡觉&quot;],&quot;type&quot;:&#123;&#125;&#125;&#39;;        // 将JSON串转换成JavaScript中的对象        // eval方法转换时，JSON串必须使用()括起来，不推荐使用        // var user = eval(&quot;(&quot; + jsonStr + &quot;)&quot;);        // JSON.parse()方法：将JSON格式的字符串转换成JavaScript的对象        var user = JSON.parse(jsonStr);        console.log(user.id);        console.log(user.username);        console.log(user.password);        console.log(user);        // 将JavaScript中的对象转换成JSON格式的字符串        var str = JSON.stringify(user);        console.log(str);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form&gt;            手机号：&lt;input type=&quot;text&quot; id=&quot;phone&quot; name=&quot;phone&quot; /&gt;&lt;span id=&quot;phone_msg&quot;&gt;&lt;/span&gt;&lt;br/&gt;            密 码：&lt;input type=&quot;text&quot; id=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;span id=&quot;password_msg&quot;&gt;&lt;/span&gt;&lt;br/&gt;            邮 箱：&lt;input type=&quot;text&quot; id=&quot;email&quot; name=&quot;email&quot; /&gt;&lt;span id=&quot;email_msg&quot;&gt;&lt;/span&gt;&lt;br/&gt;            &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;sub()&quot;/&gt;        &lt;/form&gt;        &lt;script&gt;        function sub()&#123;            var phone = document.getElementById(&quot;phone&quot;).value;            var password = document.getElementById(&quot;password&quot;).value;            var email = document.getElementById(&quot;email&quot;).value;            var phone_msg = document.getElementById(&quot;phone_msg&quot;);            var password_msg = document.getElementById(&quot;password_msg&quot;);            var email_msg = document.getElementById(&quot;email_msg&quot;);            /********************* 验证手机 *********************/            // 手机号：1、必须是纯数字  2、必须以数字 1 开头  3、第二位：3、4、5、6、7、8、9    4、从第三位开始剩余的 9 位都可以是 0-9              // 创建验证手机号的正则表达式对象            // ^字符:是否以指定的字符开头            // 字符$:是否以指定的字符结尾            var phoneExp = /^1[3-9]\d&#123;9&#125;$/ ;            if(phoneExp.test(phone))&#123;                phone_msg.innerHTML = &quot;&quot;;            &#125; else &#123;                phone_msg.innerHTML = &quot;手机号的格式不匹配&quot;;            &#125;                        // var passwordExp = /^[0-9A-z@]&#123;6,20&#125;$/;            var passwordExp = /^[A-z0-9]&#123;3,10&#125;@&#123;1&#125;[A-z0-9]&#123;2,9&#125;$/;            if(passwordExp.test(password))&#123;                password_msg.innerHTML = &quot;&quot;;            &#125; else &#123;                password_msg.innerHTML = &quot;密码格式不匹配&quot;;            &#125;                        // 1.@之前可以是数字和字符  2.@  3.至少要有一个字符 4.可以是.com .cn .net .com.cn            var emailExp = /^[0-9A-z]&#123;3,&#125;@[A-z]+(.com|.cn|.net|.com.cn)$/;            if(emailExp.test(email))&#123;                email_msg.innerHTML = &quot;&quot;;            &#125; else &#123;                email_msg.innerHTML = &quot;邮箱格式不正确&quot;;            &#125;                                &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JavaScript笔记&quot;&gt;&lt;a href=&quot;#JavaScript笔记&quot; class=&quot;headerlink&quot; title=&quot;JavaScript笔记&quot;&gt;&lt;/a&gt;JavaScript笔记&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>HTML和CSS笔记</title>
    <link href="http://example.com/2021/08/28/html%E5%92%8Ccss%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/08/28/html%E5%92%8Ccss%E7%AC%94%E8%AE%B0/</id>
    <published>2021-08-28T08:27:31.000Z</published>
    <updated>2021-09-14T06:56:14.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Html和CSS笔记"><a href="#Html和CSS笔记" class="headerlink" title="Html和CSS笔记"></a>Html和CSS笔记</h1><span id="more"></span><h1 id="《《文章很长，目录在右下角》》"><a href="#《《文章很长，目录在右下角》》" class="headerlink" title="《《文章很长，目录在右下角》》"></a>《《文章很长，目录在右下角》》</h1><h2 id="Html"><a href="#Html" class="headerlink" title="Html"></a>Html</h2><h3 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h3><ul><li>开始标签：&lt;标签名&gt;</li><li>结束标签：&lt;/标签名&gt;</li><li>自封标签(自闭标签)：&lt;标签名/&gt;</li></ul><p>注意：开始标签和结束标签必须成对出现，必须正确的嵌套</p><h3 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h3><ul><li><p>开始标签 + 内容 + 结束标签 =  html元素</p></li><li><p>html元素也会被浏览器转换成对象</p><h3 id="HTML文档的基本结构"><a href="#HTML文档的基本结构" class="headerlink" title="HTML文档的基本结构"></a>HTML文档的基本结构</h3></li><li><p>必须具有一个跟元素html</p></li><li><p>html中包含head和body两个元素</p></li><li><p>head元素中包含title元素</p></li><li><p>body中是网页的主题内容<br><img src="https://s3.bmp.ovh/imgs/2021/08/f4e5efde428942f4.png"></p><h3 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h3><p><img src="https://s3.bmp.ovh/imgs/2021/08/1f280a630ccf3b3e.png"></p><h3 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h3><p><img src="https://s3.bmp.ovh/imgs/2021/08/bc435e33f2979402.png"></p><h3 id="锚点标签"><a href="#锚点标签" class="headerlink" title="锚点标签"></a>锚点标签</h3><p><img src="https://s3.bmp.ovh/imgs/2021/08/e20526113d57c444.png"><br><img src="https://s3.bmp.ovh/imgs/2021/08/efbb0245217289ba.png"></p><h3 id="img图片标签"><a href="#img图片标签" class="headerlink" title="img图片标签"></a>img图片标签</h3><p><img src="https://s3.bmp.ovh/imgs/2021/08/860cf643811db8c6.png"></p><h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><p><img src="https://s3.bmp.ovh/imgs/2021/08/2ea5843eb14e2e66.png"><br><img src="https://s3.bmp.ovh/imgs/2021/08/262413c26a4267f5.png"></p><h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><p><img src="https://s3.bmp.ovh/imgs/2021/08/0e7ba995503b267a.png"></p></li><li><p>静态网页：无法与服务器交互</p></li><li><pre><code>HTML</code></pre></li><li><p>动态网页：可以与服务器交互</p></li><li><pre><code>JSP、PHP、ASP、ASP .NET</code></pre><h3 id="form表单"><a href="#form表单" class="headerlink" title="form表单"></a>form表单</h3></li></ul><pre><code>&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;表单控件&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!--     HTML标签通用的属性        id：唯一标识一个标签的标志（HTML规范要求id必须唯一）        name：指定元素的名称        class：css常用该属性设置样式        表单控件的disabled属性：禁用表单控件        form：表单标签        action：指定接收请求的url（地址）        method：提交请求的方式    input：表单控件标签        value：表单控件的值        type：            text（默认值：可以被省略）：文本框（输入单行文本）            password：密码输入框                        submit：提交表单按钮            reset：重置表单按钮            button：普通按钮                        radio：单选按钮                 name：属性值一致的单选按钮会被自动分为一组，一组单选按钮只能有一个被选中                value：指定提交到后台（服务器）的值                checked：设置当前按钮默认被选中            checkbox：复选框                name：同一组复选框name值要一致                value：指定提交到后台（服务器）的值                checked：设置当前按钮默认被选中            hidden：隐藏域            file：文件控件                    select：下拉列表框标签        name：提交到后的名称（key）    option：下拉列表框中的选项（select子标签）        value：提交到后台的值（value）    textarea：文本域标签（用于输入多行文本）        cols：一行显示的英文字符数（中文一个字符占两个英文字符的空间）        rows：显示内容的行数（一旦内容行数超出rows的指定值，就会自动出现滚动条）            button：按钮标签    --&gt;    &lt;form action=&quot;url&quot; method=&quot;get&quot; enctype=&quot;multipart/form-data&quot;&gt;        隐藏域：&lt;input type=&quot;hidden&quot; name=&quot;&quot; value=&quot;&quot; /&gt; &lt;br /&gt;        头像：&lt;input type=&quot;file&quot; name=&quot;upload_file&quot; /&gt; &lt;br /&gt;        手机号：&lt;input type=&quot;text&quot; id=&quot;phone&quot; name=&quot;phone&quot; disabled=&quot;disabled&quot; /&gt; &lt;br /&gt;        密码：&lt;input type=&quot;password&quot; /&gt; &lt;br /&gt;        性别：        &lt;input name=&quot;sex&quot; type=&quot;radio&quot; id=&quot;man&quot; checked=&quot;checked&quot; value=&quot;男&quot; /&gt;&lt;label for=&quot;man&quot;&gt;男&lt;/label&gt;         &lt;input name=&quot;sex&quot; type=&quot;radio&quot; id=&quot;woman&quot; value=&quot;女&quot; /&gt;&lt;label for=&quot;woman&quot;&gt;女&lt;/label&gt; &lt;br /&gt;        爱好：        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;chifan&quot; checked=&quot;checked&quot;/&gt;吃饭        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;shuijiao&quot;/&gt;睡觉        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;dadoudou&quot;/&gt;打豆豆        &lt;br /&gt;        家乡：        &lt;select name=&quot;city&quot;&gt;            &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;            &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt;            &lt;option value=&quot;guangzhou&quot;&gt;广州&lt;/option&gt;            &lt;option value=&quot;shenzhen&quot;&gt;深圳&lt;/option&gt;        &lt;/select&gt;        &lt;select name=&quot;area&quot;&gt;            &lt;option&gt;海淀&lt;/option&gt;            &lt;option&gt;朝阳&lt;/option&gt;            &lt;option&gt;丰台&lt;/option&gt;            &lt;option&gt;昌平&lt;/option&gt;        &lt;/select&gt;        &lt;br /&gt;        个人简介：        &lt;textarea name=&quot;info&quot; cols=&quot;20&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;        &lt;br /&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交表单按钮&quot; /&gt;        &lt;input type=&quot;reset&quot; value=&quot;重置表单按钮&quot; /&gt;        &lt;input type=&quot;button&quot; value=&quot;普通按钮&quot; /&gt;        &lt;br /&gt;        图片按钮：&lt;input type=&quot;image&quot; src=&quot;./04、image/img10.jpg&quot; width=&quot;100&quot; height=&quot;100&quot; /&gt;        &lt;br /&gt;        &lt;button&gt;普通按钮&lt;/button&gt;        &lt;button type=&quot;submit&quot;&gt;提交表单按钮&lt;/button&gt;        &lt;button type=&quot;reset&quot;&gt;重置表单按钮&lt;/button&gt;        &lt;br /&gt;                &lt;!-- 以下是HTML5中增加的表单控件 --&gt;        只能输入数字：&lt;input type=&quot;number&quot; /&gt;        &lt;br /&gt;        输入邮箱地址（自带邮箱验证功能）：&lt;input type=&quot;email&quot; /&gt;        &lt;br /&gt;        颜色面板：&lt;input type=&quot;color&quot; /&gt;        &lt;br /&gt;        日期（自带日历面板（不含时间））：&lt;input type=&quot;date&quot; /&gt;        &lt;br /&gt;        日期+时间（自带日历面板）：&lt;input type=&quot;datetime&quot; /&gt;        &lt;br /&gt;        本地时间：&lt;input type=&quot;datetime-local&quot; /&gt;        &lt;br /&gt;        月份：&lt;input type=&quot;month&quot; /&gt;        &lt;br /&gt;        周：&lt;input type=&quot;week&quot; /&gt;        &lt;br /&gt;        时间：&lt;input type=&quot;time&quot; /&gt;        &lt;br /&gt;        滑块：&lt;input type=&quot;range&quot; /&gt;        &lt;br /&gt;        搜索框：&lt;input type=&quot;search&quot; /&gt;        &lt;br /&gt;        电话号码（自带电话验证功能）：&lt;input type=&quot;tel&quot; /&gt;        &lt;br /&gt;        URL：&lt;input type=&quot;url&quot; /&gt;        &lt;br /&gt;                    &lt;/form&gt;&lt;/body&gt;</code></pre><p><img src="https://s3.bmp.ovh/imgs/2021/08/4e91a1fba74e892f.png"><br><img src="https://s3.bmp.ovh/imgs/2021/08/08a7efb4b6ab5a0a.png"></p><h3 id="framset（不常用）"><a href="#framset（不常用）" class="headerlink" title="framset（不常用）"></a>framset（不常用）</h3><p>目录： D:\中软学习篇\赵灿老师代码\html\09、frameset</p><h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h3><p>目录： D:\中软学习篇\赵灿老师代码\html\10、iframe</p><h3 id="文本格式"><a href="#文本格式" class="headerlink" title="文本格式"></a>文本格式</h3><p><img src="https://s3.bmp.ovh/imgs/2021/08/61b5247061266679.png"></p><h3 id="打开方式"><a href="#打开方式" class="headerlink" title="打开方式"></a>打开方式</h3><p><img src="https://s3.bmp.ovh/imgs/2021/08/61ca88b184f29042.png"></p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h2 id="CSS-1"><a href="#CSS-1" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS-级联样式表"><a href="#CSS-级联样式表" class="headerlink" title="CSS(级联样式表)"></a>CSS(级联样式表)</h3><p>作用：用于美化html页面</p><h3 id="使用CSS的三种方式"><a href="#使用CSS的三种方式" class="headerlink" title="使用CSS的三种方式"></a>使用CSS的三种方式</h3><ul><li>内联式（行内样式）</li></ul><ol><li>优点：使用简单</li><li>缺点：维护麻烦，无法复用代码<br><img src="https://s3.bmp.ovh/imgs/2021/08/8882ef54aa4acaaa.png"></li></ol><ul><li>嵌入式（内嵌样式）</li></ul><ol><li>使用相对简单，难于维护，无法复用代码（只能在当前页内复用）<br><img src="https://s3.bmp.ovh/imgs/2021/08/5d4646575120fa81.png"></li></ol><ul><li>外部样式</li></ul><ol><li>优点：维护方便、代码可复用</li><li>缺点： 使用时需要注意选择器选中的范围<br><img src="https://s3.bmp.ovh/imgs/2021/08/4a12ff25c05ce8c6.png"><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3>：只能使用多行注释/<em>注释内容</em>/<h3 id="CSS语法"><a href="#CSS语法" class="headerlink" title="CSS语法"></a>CSS语法</h3></li></ol><ul><li><p>语法格式：选择器{语句1;…语句n;}</p></li><li><p>语句 =  属性:值;<br><img src="https://s3.bmp.ovh/imgs/2021/08/573d62c36b92e462.png"></p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3></li><li><p>作用：指向您需要设置样式的 HTML 元素</p></li><li><p>标签选择器（元素选择器）</p><p>  标签名{</p><pre><code>  属性:值;</code></pre><p>  }</p></li></ul><p><img src="https://s3.bmp.ovh/imgs/2021/08/8078673719bc7ebd.png"></p><h3 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h3><p>#标签的id属性的值{<br>}<br><img src="https://s3.bmp.ovh/imgs/2021/08/05ebe1d2e86f8b05.png"></p><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><ul><li>HTML规范：要是id在一个页面中要保证唯一性</li><li>CSS中id选择器，没遵守HTML的规范，如果有多个相同的id，都会被id选择器选中</li><li>JavaScript中：遵守了HTML的规范，当出现重复的id时，获取的元素对象为第一个出现的id<h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3></li><li>.标签的class属性的值{}<br><img src="https://s3.bmp.ovh/imgs/2021/08/e5166660d1467d79.png"><h3 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h3><img src="https://s3.bmp.ovh/imgs/2021/08/b49ab61d2c64491c.png"><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><img src="https://s3.bmp.ovh/imgs/2021/08/39db5d5b50989554.png"><h3 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h3><img src="https://s3.bmp.ovh/imgs/2021/08/16efc3aab28084ba.png"><h3 id="选择器分组"><a href="#选择器分组" class="headerlink" title="选择器分组"></a>选择器分组</h3><img src="https://s3.bmp.ovh/imgs/2021/08/99b338690e4b74a4.png"><h3 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h3><img src="https://s3.bmp.ovh/imgs/2021/08/3b49e8dbe51dbf27.png"><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3>  <!DOCTYPE html>  <html>      <head>          <meta charset="utf-8">          <title>伪类选择器</title>          <style type="text/css">          /* 初始状态 */          a:link{              color:black;          }          /* 鼠标移入的样式 */          a:hover{              color:blue;          }          /* 鼠标按下未松开 */          a:active{              color:red;          }          /* 被点击之后的样式 */          a:visited{              color:#0f0;          }          /* 获取焦点的伪类 */          #username:focus{              background-color: #FF0000;          }          </style>      </head>      <body>          <a href="./target.html"> target.html </a>          <input id="username">      </body>  </html></li></ul><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><ul><li>margin（外边距：边框和其他元素之间的距离）、padding（内边距：边框和元素内容之间的距离）、border（边框）<br><img src="https://s3.bmp.ovh/imgs/2021/08/68139e6115b9707c.png"><br><img src="https://s3.bmp.ovh/imgs/2021/08/297db6ebd7080f6f.png"><br><img src="https://s3.bmp.ovh/imgs/2021/08/2ce42d23b028e9c2.png"></li><li>代码<pre><code>  &lt;head&gt;      &lt;meta charset=&quot;utf-8&quot;&gt;      &lt;title&gt;盒子模型&lt;/title&gt;      &lt;style type=&quot;text/css&quot;&gt;      /*       span是行内元素，div是块元素      行内元素是不支持设置width和height的      */      span&#123;          width: 100px;          height: 100px;          background-color: #0000FF;          /* 将当前选择器选中的元素设置为块元素 */          display: block;      &#125;      /* 使用width和height设置元素的宽和高时，是不包含边框的宽度的 */      div&#123;          width: 100px;          height: 100px;      &#125;      .div1&#123;          background-color: #ffDDDD;          border: solid #FF0000 100px;      &#125;      .div2&#123;          background-color: #DDFFDD;          border: solid #00FF00 10px;      &#125;      .div3&#123;          background-color: #DDF;          border: solid #00F 10px;          /*           html文件解析的顺序是从上到下一条一条解析的，所以，如果相同属性，设置多次，下面的设置会覆盖上面的设置          内边距：内容到边框内边缘之间的距离          padding:值; 一次性设置四边的内边距          padding:值1 值2; 值1：上下  值2：左右          padding:值1 值2 值3 值4;  值1：上  值2：右  值3:下  值4：左          padding-left:设置左边的内边距          padding-top:设置上边的内边距          padding-right:设置右边的内边距          padding-bottom:设置下边的内边距          */          padding: 10px 50px 100px 150px;          /* padding-left: 500px; */          /*           外边距：边框的外边缘到占用的空间的边缘的距离          margin:值; 一次性设置四边的外边距          margin:值1 值2; 值1：上下  值2：左右          margin:值1 值2 值3 值4;  值1：上  值2：右  值3:下  值4：左          margin-left:设置左边的外边距          margin-top:设置上边的外边距          margin-right:设置右边的外边距          margin-bottom:设置下边的外边距          */          margin: 10px 50px 100px 50px;      &#125;      &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;      &lt;div class=&quot;div1&quot;&gt; div1 &lt;/div&gt;      &lt;div class=&quot;div2&quot;&gt; div2 &lt;/div&gt;      &lt;div class=&quot;div3&quot;&gt; div3 &lt;/div&gt;            &lt;span&gt;span&lt;/span&gt;  &lt;/body&gt;</code></pre></li></ul><h3 id="内容溢出"><a href="#内容溢出" class="headerlink" title="内容溢出"></a>内容溢出</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;内容溢出&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;        div&#123;            width: 200px;            height: 200px;            background-color: #F00;            /*             内容溢出（overflow）：            visible（默认值）：内容溢出后，在元素外显示溢出的内容，但溢出的内容不占空间;            auto:内容没有溢出时，不会显示滚动条；内容有溢出时，自动显示滚动条            hidden：隐藏溢出的内容            scroll：不管内容是否溢出，都显示滚动条            inherit：从父元素继承overflow的设置            */            overflow: visible;        &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div&gt;            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv        &lt;/div&gt;        &lt;span&gt;            spanspanspanspanspanspanspanspanspanspanspan            spanspanspanspanspanspanspanspanspanspanspan            spanspanspanspanspanspanspanspanspanspanspan        &lt;/span&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;元素浮动&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;            /*             浏览器在解析HTML时，是自上而下的一句一句解析的，            元素的顺序（元素占用空间的顺序）自上而下，自左而右进行排列的                        float:元素浮动（浮动以后，元素会脱离正常（默认）的文档流）                left:被选择器选中的元素漂浮到期后元素的左边                right:被选择器选中的元素漂浮到期后元素的由边            */            ul li&#123;                float: right;                background-color: aqua;                padding: 5px;                margin: 5px;                /* list-style设置为none，去除li默认的样式 */                list-style: none;            &#125;            /*             clear:清除浮动（不允许其他元素浮动到当前元素的左边或右边）                none(默认值)：允许漂浮                right:禁止其他元素漂浮到当前元素的右侧                left:禁止其他元素漂浮到当前元素的左侧                both:禁止其他元素漂浮到当前元素的两侧            */            div&#123;                clear: both;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;ul&gt;            &lt;li class=&quot;first&quot;&gt; 首页 &lt;/li&gt;            &lt;li&gt; HTML&lt;/li&gt;            &lt;li&gt; CSS &lt;/li&gt;            &lt;li class=&quot;last&quot;&gt; JAVASCRIPT &lt;/li&gt;        &lt;/ul&gt;        &lt;div&gt;div&lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><pre><code>!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;元素定位&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;        .container&#123;            background-color: #0f0;            height: 1000px;        &#125;        .container div&#123;            width: 200px;            height: 200px;            background-color: azure;            border: solid #f00 2px;        &#125;        /*         position(元素定位)：设置元素显示的起始位置（左上角）            static：以正常的文档流为左上角起点（上一个元素的结束位置）                    不支持left、right、top、bottom四个属性的            relative（相对定位）：相对于当前元素在正常文档流中的起点进行定位                    定位后元素会脱离正常的文档流，原来应该占用的元素空间依然会被占用            fixed（绝对定位）：以浏览器的左上角作为原点进行定位                    定位后元素会脱离正常的文档流，原来应该占用的元素空间不会再被占用            absolute(绝对定位):以第一个position不为static的父元素的左上角作为原点进行定位                    定位后元素会脱离正常的文档流，原来应该占用的元素空间不会再被占用            sticky(粘性定位):基于用户的滚动位置来定位。                    粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。            inherit：继承父元素的定位方式        */                .div2&#123;            position: absolute;            left:20px;            top:20px;        &#125;        .div3&#123;            position: fixed;            right: 0px;            bottom: 0px;        &#125;        .div4&#123;            /*             先以relative方式定位，当用户拖动滚动条的时候，            元素据浏览器可见区域上边缘的距离等于top的值时，自动切换成fixed定位            */            position: sticky;            top:10px;        &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body style=&quot;position: static;&quot;&gt;        &lt;div class = &quot;outer&quot; style=&quot;position: static;&quot;&gt;            &lt;div class = &quot;container&quot; style=&quot;position: static;left:50px;top:50px&quot;&gt;                &lt;div class=&quot;div1&quot;&gt;div1&lt;/div&gt;                &lt;div class=&quot;div2&quot;&gt;div2 &lt;/div&gt;                &lt;div class=&quot;div3&quot;&gt;div3 我是一个小广告 &lt;/div&gt;                &lt;div class=&quot;div4&quot;&gt;div4&lt;/div&gt;                &lt;span&gt; span1 &lt;/span&gt;                &lt;span&gt; span2 &lt;/span&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;        &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;        &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;        &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;        &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;        &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;        &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="元素重叠"><a href="#元素重叠" class="headerlink" title="元素重叠"></a>元素重叠</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;元素重叠&lt;/title&gt;                &lt;style type=&quot;text/css&quot;&gt;        div&#123;            width:200px;            height:200px;        &#125;        /*         z-index（默认值为0）值大的在上面，值小的在下面        没有定位的元素不支持z-index属性        */        #div1&#123;            background-color: aqua;            z-index: 1;        &#125;        #div2&#123;            background-color: red;            z-index: -2;            position: absolute;            top: 20px;            left:20px        &#125;        #div3&#123;            background-color: #0f0;            z-index: 3;            position: absolute;            top: 40px;            left:40px        &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;div1&quot;&gt;div1&lt;/div&gt;        &lt;div id=&quot;div2&quot;&gt;div2&lt;/div&gt;        &lt;div id=&quot;div3&quot;&gt;div3&lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Html和CSS笔记&quot;&gt;&lt;a href=&quot;#Html和CSS笔记&quot; class=&quot;headerlink&quot; title=&quot;Html和CSS笔记&quot;&gt;&lt;/a&gt;Html和CSS笔记&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL自学笔记</title>
    <link href="http://example.com/2021/08/28/MySQL%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/08/28/MySQL%E7%AC%94%E8%AE%B0/</id>
    <published>2021-08-28T07:20:33.000Z</published>
    <updated>2021-09-14T07:09:08.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL自学笔记"><a href="#MySQL自学笔记" class="headerlink" title="MySQL自学笔记"></a>MySQL自学笔记</h1><span id="more"></span><h1 id="《《文章很长，目录在右下角》》"><a href="#《《文章很长，目录在右下角》》" class="headerlink" title="《《文章很长，目录在右下角》》"></a>《《文章很长，目录在右下角》》</h1><h2 id="MySQL-数据库的安装和配置-安装演示-（略，忘了看韩顺平老师的笔记）"><a href="#MySQL-数据库的安装和配置-安装演示-（略，忘了看韩顺平老师的笔记）" class="headerlink" title="MySQL 数据库的安装和配置(安装演示)（略，忘了看韩顺平老师的笔记）"></a>MySQL 数据库的安装和配置(安装演示)（略，忘了看韩顺平老师的笔记）</h2><h2 id="Navicat-安装和使用（略，忘了看韩顺平老师的笔记）"><a href="#Navicat-安装和使用（略，忘了看韩顺平老师的笔记）" class="headerlink" title="Navicat 安装和使用（略，忘了看韩顺平老师的笔记）"></a>Navicat 安装和使用（略，忘了看韩顺平老师的笔记）</h2><h2 id="SQLyog-SQLyog-安装和使用（略，忘了看韩顺平老师的笔记）"><a href="#SQLyog-SQLyog-安装和使用（略，忘了看韩顺平老师的笔记）" class="headerlink" title="SQLyog[SQLyog] 安装和使用（略，忘了看韩顺平老师的笔记）"></a>SQLyog[SQLyog] 安装和使用（略，忘了看韩顺平老师的笔记）</h2><h2 id="数据库三层结构-破除-MySQL-神秘"><a href="#数据库三层结构-破除-MySQL-神秘" class="headerlink" title="数据库三层结构-破除 MySQL 神秘"></a>数据库三层结构-破除 MySQL 神秘</h2><p><img src="https://s3.bmp.ovh/imgs/2021/09/0e325f77eabc709f.png"><br><img src="https://s3.bmp.ovh/imgs/2021/09/9a72e45696564a7a.png"></p><h2 id="数据在数据库中的存储方式"><a href="#数据在数据库中的存储方式" class="headerlink" title="数据在数据库中的存储方式"></a>数据在数据库中的存储方式</h2><p><img src="https://s3.bmp.ovh/imgs/2021/09/037aaf6fa29ce2f7.png"></p><h2 id="SQL-语句分类"><a href="#SQL-语句分类" class="headerlink" title="SQL 语句分类"></a>SQL 语句分类</h2><p><img src="https://s3.bmp.ovh/imgs/2021/09/133363a7d0c2a179.png"></p><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p><img src="https://s3.bmp.ovh/imgs/2021/09/64be5c3dd4404fd2.png"></p><h2 id="查看、删除数据库"><a href="#查看、删除数据库" class="headerlink" title="查看、删除数据库"></a>查看、删除数据库</h2><p><img src="https://s3.bmp.ovh/imgs/2021/09/0c8012ae97b0257e.png"></p><h2 id="备份恢复数据库he备份恢复数据库的表"><a href="#备份恢复数据库he备份恢复数据库的表" class="headerlink" title="备份恢复数据库he备份恢复数据库的表"></a>备份恢复数据库he备份恢复数据库的表</h2><p><img src="https://s3.bmp.ovh/imgs/2021/09/935d4426485a44b4.png"><br><img src="https://s3.bmp.ovh/imgs/2021/09/30fc2be730dead27.png"></p><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p><img src="https://s3.bmp.ovh/imgs/2021/09/682489fa32efc209.png"></p><h2 id="Mysql-常用数据类型-列类型"><a href="#Mysql-常用数据类型-列类型" class="headerlink" title="Mysql 常用数据类型(列类型)"></a>Mysql 常用数据类型(列类型)</h2><p><img src="https://s3.bmp.ovh/imgs/2021/09/e11c30a12f08d716.png"></p><ul><li>数值型(整数)的基本使用<br><img src="https://s3.bmp.ovh/imgs/2021/09/43720f6e0cc96629.png"></li></ul><ol><li>如果没有指定 unsinged , 则 TINYINT 就是有符号 </li><li>如果指定 unsinged , 则 TINYINT 就是无符号 0-255</li></ol><ul><li>bit<br><img src="https://s3.bmp.ovh/imgs/2021/09/2c07c32e11dbc697.png"></li><li>数值型(小数)的基本使用<br><img src="https://s3.bmp.ovh/imgs/2021/09/4ba0f0913bb6b868.png"></li><li>字符串的基本使用<br><img src="https://s3.bmp.ovh/imgs/2021/09/55742c1568fcba95.png"><br><img src="https://s3.bmp.ovh/imgs/2021/09/e15905d1ef7d0bdf.png"><br><img src="https://i.loli.net/2021/09/07/PpUQ3SCfzDmK5Nq.png"></li><li>日期类型的基本使用<br><img src="https://i.loli.net/2021/09/07/7EwjVJ6KMfqClXO.png"><h2 id="创建表练习-略"><a href="#创建表练习-略" class="headerlink" title="创建表练习(略)"></a>创建表练习(略)</h2><h2 id="修改表-基本介绍"><a href="#修改表-基本介绍" class="headerlink" title="修改表-基本介绍"></a>修改表-基本介绍</h2><img src="https://s3.bmp.ovh/imgs/2021/09/a7f24cb801effc53.png"><h2 id="修改表-课堂练习"><a href="#修改表-课堂练习" class="headerlink" title="修改表-课堂练习"></a>修改表-课堂练习</h2>altertab.sql<h2 id="数据库-C-create-R-read-U-update-D-delete-语句"><a href="#数据库-C-create-R-read-U-update-D-delete-语句" class="headerlink" title="数据库 C[create]R[read]U[update]D[delete]语句"></a>数据库 C[create]R[read]U[update]D[delete]语句</h2></li><li>Insert语句 – 添加数据</li><li>Update语句 – 更改数据</li><li>Delete语句 – 删除数据</li><li>Select语句 – 查找数据<h2 id="Insert语句"><a href="#Insert语句" class="headerlink" title="Insert语句"></a>Insert语句</h2></li><li>使用 INSERT 语句向表中插入数据。insert.sql<br><img src="https://s3.bmp.ovh/imgs/2021/09/d6775b68bbbdf89f.png"></li><li>细节说明 insertdetail.sql<br>说明 insert 语句的细节 </li></ul><ol><li>插入的数据应与字段的数据类型相同。 – 比如 把 ‘abc’ 添加到 int 类型会错误 </li></ol><p>INSERT INTO goods (id, goods_name, price) VALUES(‘韩顺平’, ‘小米手机’, 2000);<br>2. 数据的长度应在列的规定范围内，例如：不能将一个长度为 80 的字符串加入到长度为 40 的列中。</p><p>INSERT INTO goods (id, goods_name, price) VALUES(40, ‘vovo 手机 vovo 手机 vovo 手机 vovo 手机 vovo 手机’, 3000);</p><ol start="3"><li>在 values 中列出的数据位置必须与被加入的列的排列位置相对应。 </li></ol><p>INSERT INTO goods (id, goods_name, price) – 不对 VALUES(‘vovo 手机’,40, 2000); </p><ol start="4"><li>字符和日期型数据应包含在单引号中。 </li></ol><p>INSERT INTO goods (id, goods_name, price) VALUES(40, vovo 手机, 3000); – 错误的 vovo 手机 应该 ‘vovo 手机’ </p><ol start="5"><li>列可以插入空值[前提是该字段允许为空]，insert into table value(null) </li></ol><p>INSERT INTO goods (id, goods_name, price) VALUES(40, ‘vovo 手机’, NULL); </p><ol start="6"><li>insert into tab_name (列名..) values (),(),() 形式添加多条记录 </li></ol><p>INSERT INTO goods (id, goods_name, price) VALUES(50, ‘三星手机’, 2300),(60, ‘海尔手机’, 1800); </p><ol start="7"><li>如果是给表中的所有字段添加数据，可以不写前面的字段名称 </li></ol><p>INSERT INTO goods VALUES(70, ‘IBM 手机’, 5000); </p><ol start="8"><li>默认值的使用，当不给某个字段值时，如果有默认值就会添加默认值，否则报错 – 如果某个列 没有指定 not null ,那么当添加数据时，没有给定值，则会默认给 null – 如果我们希望指定某个列的默认值，可以在创建表时指定 </li></ol><p>INSERT INTO goods (id, goods_name) VALUES(80, ‘格力手机’); SELECT * FROM goods; INSERT INTO goods2 (id, goods_name) VALUES(10, ‘顺平手机’); SELECT * FROM goods2;</p><h2 id="update-语句"><a href="#update-语句" class="headerlink" title="update 语句"></a>update 语句</h2><p><img src="https://s3.bmp.ovh/imgs/2021/09/1b733de368bcf020.png"></p><ul><li>细节<br><img src="https://s3.bmp.ovh/imgs/2021/09/7f9a63a86f7fca63.png"><h2 id="delete-语句"><a href="#delete-语句" class="headerlink" title="delete 语句"></a>delete 语句</h2></li><li>使用 delete 语句删除表中数据<br><img src="https://s3.bmp.ovh/imgs/2021/09/abdd3193658fd188.png"></li><li>使用细节<br><img src="https://s3.bmp.ovh/imgs/2021/09/7656836fdf36a3d2.png"><h2 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h2></li><li>基本语法<br><img src="https://s3.bmp.ovh/imgs/2021/09/76bd1a26f4932a24.png"></li><li>注意事项 (创建测试表学生表 )<br><img src="https://s3.bmp.ovh/imgs/2021/09/8398761ec9176a8c.png"></li><li>课堂练习: select01.sql</li><li>使用表达式对查询的列进行运算<br><img src="https://s3.bmp.ovh/imgs/2021/09/9c01fe90a930dbe2.png"></li><li>在 select 语句中可使用 as 语句</li><li>练习 select02.sql</li><li>在 where 子句中经常使用的运算符<br><img src="https://s3.bmp.ovh/imgs/2021/09/9ad2c1e2afdac6ee.png"></li><li>使用 where 子句，进行过滤查询 select03.sql</li><li>使用 order by 子句排序查询结果<br><img src="https://i.loli.net/2021/09/12/JqhN4uVmLDMXTbP.png"></li></ul><hr><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.bilibili.com/video/BV1fh411y7R8?p=730&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1fh411y7R8?p=730&amp;spm_id_from=pageDriver</a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=434902428&auto=1&height=66"></iframe>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MySQL自学笔记&quot;&gt;&lt;a href=&quot;#MySQL自学笔记&quot; class=&quot;headerlink&quot; title=&quot;MySQL自学笔记&quot;&gt;&lt;/a&gt;MySQL自学笔记&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>代码-中软学习篇</title>
    <link href="http://example.com/2021/08/13/%E4%BD%9C%E4%B8%9A-%E4%B8%AD%E8%BD%AF%E5%9B%BD%E9%99%85%E7%AF%87/"/>
    <id>http://example.com/2021/08/13/%E4%BD%9C%E4%B8%9A-%E4%B8%AD%E8%BD%AF%E5%9B%BD%E9%99%85%E7%AF%87/</id>
    <published>2021-08-13T01:12:23.000Z</published>
    <updated>2021-08-13T01:17:24.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码-中软学习篇"><a href="#代码-中软学习篇" class="headerlink" title="代码-中软学习篇"></a>代码-中软学习篇</h1><span id="more"></span><h1 id="路径：LocalHost：D-中软学习篇-zhongruanbao"><a href="#路径：LocalHost：D-中软学习篇-zhongruanbao" class="headerlink" title="路径：LocalHost：D:\中软学习篇\zhongruanbao"></a>路径：LocalHost：D:\中软学习篇\zhongruanbao</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;代码-中软学习篇&quot;&gt;&lt;a href=&quot;#代码-中软学习篇&quot; class=&quot;headerlink&quot; title=&quot;代码-中软学习篇&quot;&gt;&lt;/a&gt;代码-中软学习篇&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>笔记-中软学习篇</title>
    <link href="http://example.com/2021/07/19/%E7%AC%94%E8%AE%B0-%E4%B8%AD%E8%BD%AF%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <id>http://example.com/2021/07/19/%E7%AC%94%E8%AE%B0-%E4%B8%AD%E8%BD%AF%E5%AD%A6%E4%B9%A0%E7%AF%87/</id>
    <published>2021-07-19T09:47:23.000Z</published>
    <updated>2021-09-14T07:08:50.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="笔记-中软学习篇"><a href="#笔记-中软学习篇" class="headerlink" title="笔记-中软学习篇"></a>笔记-中软学习篇</h1><span id="more"></span><h1 id="《《文章很长，目录在右下角》》"><a href="#《《文章很长，目录在右下角》》" class="headerlink" title="《《文章很长，目录在右下角》》"></a>《《文章很长，目录在右下角》》</h1><h2 id="一周web基础学习-大课-没有正式上课"><a href="#一周web基础学习-大课-没有正式上课" class="headerlink" title="一周web基础学习-大课(没有正式上课)"></a>一周web基础学习-大课(没有正式上课)</h2><h3 id="做了个网址"><a href="#做了个网址" class="headerlink" title="做了个网址"></a>做了个网址</h3><h2 id="正式上课（大数据方向）（赵老师）（没全纪录，自学那还有好多笔记，很熟的pass）"><a href="#正式上课（大数据方向）（赵老师）（没全纪录，自学那还有好多笔记，很熟的pass）" class="headerlink" title="正式上课（大数据方向）（赵老师）（没全纪录，自学那还有好多笔记，很熟的pass）"></a>正式上课（大数据方向）（赵老师）（没全纪录，自学那还有好多笔记，很熟的pass）</h2><h2 id="javaSE-系统的自学过，此博文记得不全"><a href="#javaSE-系统的自学过，此博文记得不全" class="headerlink" title="javaSE(系统的自学过，此博文记得不全)"></a>javaSE(系统的自学过，此博文记得不全)</h2><h3 id="day01"><a href="#day01" class="headerlink" title="day01"></a>day01</h3><ul><li>安装软件，配置环境</li><li>工作台： eclipse（之前用过sublime，ider，挺好，这个没用过）<h3 id="day02"><a href="#day02" class="headerlink" title="day02"></a>day02</h3><h4 id="注释（不参与编译和运行）"><a href="#注释（不参与编译和运行）" class="headerlink" title="注释（不参与编译和运行）"></a>注释（不参与编译和运行）</h4></li><li>//  -单行注释</li><li>/*  */ -多行</li><li>/** */ -文档注释<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4></li><li>命名规则（记过笔记）</li></ul><ol><li>字母，数字，_,$;</li><li>不能以数字开头</li><li>不能使用关键字，保留字</li><li>见名知意</li><li>驼峰命名法</li></ol><ul><li>代码格式<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4></li><li>基本数据类型</li></ul><ol><li>byte ，1，8 </li><li>short，2，16</li><li>int, 4,32</li><li>long,8,64</li><li>float,4,32</li><li>double,8,64</li><li>char,2</li><li>boolean,1</li><li>String<h4 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h4></li></ol><ul><li>变量</li><li>常量（final）</li><li>字符分类 ：可见，不可见</li><li>编码类型<h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4></li><li>前提:数据类型要兼容</li><li>自动类型转换:转换后的类型 》 转换前的类型 转换后的空间比转换前的大，不会有精度损失，所以自动完成</li><li>强制转换：转换后的类型 《 转换前的类型（强转）</li><li>如果是常量，则编译器会自动判断是否在变量的取值范围内。如果在，则自动转换，如果不在，强转</li><li>一个运算表达式，每个操作数都是小于int类型，运算结果为int类型，如果有long类型，则运算结果为long类型。<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4></li><li>算术运算符</li><li>关系运算（&lt;,&gt;,&lt;=,&gt;=,==,!=）<h4 id="逻辑运算符（注意短路与不短路）"><a href="#逻辑运算符（注意短路与不短路）" class="headerlink" title="逻辑运算符（注意短路与不短路）"></a>逻辑运算符（注意短路与不短路）</h4><h4 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h4><h4 id="条件运算符（三元运算）"><a href="#条件运算符（三元运算）" class="headerlink" title="条件运算符（三元运算）"></a>条件运算符（三元运算）</h4><h3 id="day03"><a href="#day03" class="headerlink" title="day03"></a>day03</h3><h4 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h4></li><li>if-else if-else（if后面只有一条语句属于if结构）（注意大括号的省略）</li><li>switch (支持：byte，short，int，char，String，enum)（穿透）<h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4></li><li>while</li><li>do while</li><li>for<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4></li><li>break</li><li>continue<h3 id="day04"><a href="#day04" class="headerlink" title="day04"></a>day04</h3><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4></li><li>方式一： new 数据类型【长度】</li><li>方式二： new 数据类型【】{元素一，。。。。。元素n}</li><li>方式三： 在一条语句内（数据类型【】 变量名 = {元素一，。。。。。元素n}）</li><li>整型默认：0</li><li>浮点型默认：0.0</li><li>char默认： 空字符</li><li>boolean默认： false</li><li>引用类型： null<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4></li><li>数组类型【】【】 变量名；<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4></li><li>选择排序</li><li>冒泡排序</li><li>插入排序（没写过）</li><li>二分法查找（复习要好好看）<h3 id="先不记了。。。到我不会的在记录。。。"><a href="#先不记了。。。到我不会的在记录。。。" class="headerlink" title="先不记了。。。到我不会的在记录。。。"></a>先不记了。。。到我不会的在记录。。。</h3><h3 id="因为疫情被遣散回家，转战线上（对我影响不大，毕竟之前是自学过来的，强大的自制力（狗头））"><a href="#因为疫情被遣散回家，转战线上（对我影响不大，毕竟之前是自学过来的，强大的自制力（狗头））" class="headerlink" title="因为疫情被遣散回家，转战线上（对我影响不大，毕竟之前是自学过来的，强大的自制力（狗头））"></a>因为疫情被遣散回家，转战线上（对我影响不大，毕竟之前是自学过来的，强大的自制力（狗头））</h3>。。。<h2 id="HTML和CSS（之前没系统学过）（看另一篇博文）"><a href="#HTML和CSS（之前没系统学过）（看另一篇博文）" class="headerlink" title="HTML和CSS（之前没系统学过）（看另一篇博文）"></a>HTML和CSS（之前没系统学过）（看另一篇博文）</h2><a href="https://ljqljl.github.io/2021/08/28/html%E5%92%8Ccss%E7%AC%94%E8%AE%B0/">=点击这里跳转=</a><h2 id="Javascript（看另一篇博文）"><a href="#Javascript（看另一篇博文）" class="headerlink" title="Javascript（看另一篇博文）"></a>Javascript（看另一篇博文）</h2><a href="https://ljqljl.github.io/2021/08/31/JavaScript%E7%AC%94%E8%AE%B0/">=点击这里跳转=</a><h2 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h2><a href="https://ljqljl.github.io/2021/09/14/xml%E7%AC%94%E8%AE%B0/">=点击这里跳转=</a><h2 id="反射（之前记过）"><a href="#反射（之前记过）" class="headerlink" title="反射（之前记过）"></a>反射（之前记过）</h2><h2 id="servlet和jsp"><a href="#servlet和jsp" class="headerlink" title="servlet和jsp"></a>servlet和jsp</h2><a href="https://ljqljl.github.io/2021/09/14/servlet%E5%92%8Cjsp%E7%AC%94%E8%AE%B0/">=点击这里跳转=</a></li></ul><hr><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=434902428&auto=1&height=66"></iframe>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;笔记-中软学习篇&quot;&gt;&lt;a href=&quot;#笔记-中软学习篇&quot; class=&quot;headerlink&quot; title=&quot;笔记-中软学习篇&quot;&gt;&lt;/a&gt;笔记-中软学习篇&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>linux-root密码找回</title>
    <link href="http://example.com/2021/07/02/linux-root%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E/"/>
    <id>http://example.com/2021/07/02/linux-root%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E/</id>
    <published>2021-07-02T11:38:56.000Z</published>
    <updated>2021-07-02T11:39:34.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-root密码找回"><a href="#linux-root密码找回" class="headerlink" title="linux-root密码找回"></a>linux-root密码找回</h1><span id="more"></span><h2 id="这呢：来自韩顺平老师"><a href="#这呢：来自韩顺平老师" class="headerlink" title="这呢：来自韩顺平老师"></a>这呢：来自韩顺平老师</h2><p><img src="https://ftp.bmp.ovh/imgs/2021/07/81cf69144f4e43d1.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;linux-root密码找回&quot;&gt;&lt;a href=&quot;#linux-root密码找回&quot; class=&quot;headerlink&quot; title=&quot;linux-root密码找回&quot;&gt;&lt;/a&gt;linux-root密码找回&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>vi和vim快捷键</title>
    <link href="http://example.com/2021/07/02/linux-vi%E5%92%8Cvim%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://example.com/2021/07/02/linux-vi%E5%92%8Cvim%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2021-07-02T05:08:27.000Z</published>
    <updated>2021-07-02T05:08:33.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vi和vim快捷键"><a href="#vi和vim快捷键" class="headerlink" title="vi和vim快捷键"></a>vi和vim快捷键</h1><span id="more"></span><h2 id="这呢：来自韩顺平老师"><a href="#这呢：来自韩顺平老师" class="headerlink" title="这呢：来自韩顺平老师"></a>这呢：来自韩顺平老师</h2><p><img src="https://ftp.bmp.ovh/imgs/2021/07/83cbc71d3c6d2fa8.png"><br><img src="https://ftp.bmp.ovh/imgs/2021/07/518d024f777fd436.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;vi和vim快捷键&quot;&gt;&lt;a href=&quot;#vi和vim快捷键&quot; class=&quot;headerlink&quot; title=&quot;vi和vim快捷键&quot;&gt;&lt;/a&gt;vi和vim快捷键&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>linux自学笔记</title>
    <link href="http://example.com/2021/06/25/linux/"/>
    <id>http://example.com/2021/06/25/linux/</id>
    <published>2021-06-25T09:34:10.000Z</published>
    <updated>2021-07-20T05:49:02.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux入门"><a href="#linux入门" class="headerlink" title="linux入门"></a>linux入门</h1><span id="more"></span><h1 id="《《文章很长，目录在右下角》》"><a href="#《《文章很长，目录在右下角》》" class="headerlink" title="《《文章很长，目录在右下角》》"></a>《《文章很长，目录在右下角》》</h1><p>自学资源：<a href="https://www.bilibili.com/video/BV1Sv411r7vd?p=6&spm_id_from=pageDriver">linux自学所用视频</a></p><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="概述（了解就行，不整理了）"><a href="#概述（了解就行，不整理了）" class="headerlink" title="概述（了解就行，不整理了）"></a>概述（了解就行，不整理了）</h3><h3 id="linux和Unix的关系-了解"><a href="#linux和Unix的关系-了解" class="headerlink" title="linux和Unix的关系(了解)"></a>linux和Unix的关系(了解)</h3><ul><li>linux的由来<br><img src="https://ftp.bmp.ovh/imgs/2021/06/d49241fc3513afd2.png"></li><li>unix的由来<br><img src="https://ftp.bmp.ovh/imgs/2021/06/d7f45db1abef6cfd.png"></li><li>二者之间的关系<br><img src="https://ftp.bmp.ovh/imgs/2021/06/3c79e7901fa8ed86.png"><h2 id="VM-和-Linux-的安装"><a href="#VM-和-Linux-的安装" class="headerlink" title="VM 和 Linux 的安装"></a>VM 和 Linux 的安装</h2><h3 id="安装-vm-和-Centos"><a href="#安装-vm-和-Centos" class="headerlink" title="安装 vm 和 Centos"></a>安装 vm 和 Centos</h3></li><li>基本说明 学习 Linux 需要一个环境，我们需要创建一个虚拟机，然后在虚拟机上安装一个 Centos 系统来学习 </li></ul><ol><li>先安装 virtual machine 15.5 </li><li>再安装 Linux (CentOS 7.6/centOS8.1) </li><li>原理示意图<br><img src="https://ftp.bmp.ovh/imgs/2021/06/24e320af1ab78bf3.png"><h3 id="vmware15-5-下载"><a href="#vmware15-5-下载" class="headerlink" title="vmware15.5 下载"></a>vmware15.5 下载</h3></li><li>官方地址：<a href="https://www.vmware.com/cn.html">https://www.vmware.com/cn.html</a> </li><li>其它地址：<a href="https://www.nocmd.com/windows/740.html">https://www.nocmd.com/windows/740.html</a><h3 id="VM-安装的步骤"><a href="#VM-安装的步骤" class="headerlink" title="VM 安装的步骤"></a>VM 安装的步骤</h3></li><li>去 BIOS 里修改设置开启虚拟化设备支持（f2, f10）</li><li>安装虚拟机软件（vm15.5）, 演示一把， 在 BIOS 开启 CPU 虚拟化支持 </li><li><a href="https://jingyan.baidu.com/article/ab0b56305f2882c15afa7dda.html">https://jingyan.baidu.com/article/ab0b56305f2882c15afa7dda.html</a> <h3 id="Centos-下载地址"><a href="#Centos-下载地址" class="headerlink" title="Centos 下载地址"></a>Centos 下载地址</h3></li><li>CentOS-7-x86_64-DVD-1810.iso CentOS 7.6 DVD 版 4G (目前主流的生产环境) <a href="http://mirrors.163.com/centos/7.6.1810/isos/x86_64/CentOS-7-x86_64-DVD-1810.iso">http://mirrors.163.com/centos/7.6.1810/isos/x86_64/CentOS-7-x86_64-DVD-1810.iso</a> </li><li>CentOS-8.1.1911-x86_64-dvd1.iso CentOS 8.1 DVD 版 8G (未来的主流.) <a href="https://mirrors.aliyun.com/centos/8.1.1911/isos/x86_64/CentOS-8.1.1911-x86_64-dvd1.iso">https://mirrors.aliyun.com/centos/8.1.1911/isos/x86_64/CentOS-8.1.1911-x86_64-dvd1.iso</a><h3 id="CentOS-安装的步骤"><a href="#CentOS-安装的步骤" class="headerlink" title="CentOS 安装的步骤"></a>CentOS 安装的步骤</h3></li><li>创建虚拟机 [演示] </li><li>开始安装系统(CentOS7.6)的步骤 [演示]<br>提示:生成复杂密码:<a href="https://suijimimashengcheng.51240.com/">https://suijimimashengcheng.51240.com/</a> </li><li>CentOS 安装难点-网络连接方式理解 [示意图]<br><img src="https://ftp.bmp.ovh/imgs/2021/06/3c512e1847500bea.png"><h3 id="虚拟机克隆"><a href="#虚拟机克隆" class="headerlink" title="虚拟机克隆"></a>虚拟机克隆</h3></li><li>方式 1，直接拷贝一份安装好的虚拟机文件 2) 方式 </li><li>使用 vmware 的克隆操作，注意， 克隆时，需要先关闭 linux 系统<h3 id="虚拟机快照"><a href="#虚拟机快照" class="headerlink" title="虚拟机快照"></a>虚拟机快照</h3></li></ol><ul><li>如果你在使用虚拟机系统的时候(比如 linux)，你想回到原先的某一个状态，也就是说你担心可能有些误操作造成系 统异常，需要回到原先某个正常运行的状态，vmware 也提供了这样的功能，就叫快照管理 。<br><img src="https://ftp.bmp.ovh/imgs/2021/06/218890f4a88328a7.png"><h3 id="虚拟机迁移和删除"><a href="#虚拟机迁移和删除" class="headerlink" title="虚拟机迁移和删除"></a>虚拟机迁移和删除</h3></li><li>我在前面讲过，虚拟系统安装好了，它的本质就是文件(放在文件夹的)。因此虚拟系统的迁移很方便，你可以把安 装好的虚拟系统这个文件夹整体拷贝或者剪切到另外位置使用。删除也很简单，用 vmware 进行移除，再点击菜单-&gt;从磁盘删除即可，或者直接手动删除虚拟系统对应的文件夹即可。<h3 id="安装-vmtools"><a href="#安装-vmtools" class="headerlink" title="安装 vmtools"></a>安装 vmtools</h3></li><li>介绍 </li></ul><ol><li>vmtools 安装后，可以让我们在 windows 下更好的管理 vm 虚拟机 </li><li>可以设置 windows 和 centos 的共享文件夹 </li></ol><ul><li>安装 vmtools 的步骤 </li></ul><ol><li>进入 centos </li><li>点击 vm 菜单的-&gt;install vmware tools </li><li>centos 会出现一个 vm 的安装包, xx.tar.gz </li><li>拷贝到 /opt </li><li>使用解压命令 tar, 得到一个安装文件 cd /opt [进入到 opt 目录] </li></ol><p>tar -zxvf xx.tar.gz </p><ol start="6"><li>进入该 vm 解压的目录 , /opt 目录下 </li></ol><p>cd vmware…</p><ol start="7"><li>安装 ./vmware-install.pl </li><li>全部使用默认设置即可, 就可以安装成功 </li><li>注意：安装 vmtools 需要有 gcc . gcc -v <h3 id="设置共享文件夹"><a href="#设置共享文件夹" class="headerlink" title="设置共享文件夹"></a>设置共享文件夹</h3></li></ol><ul><li>步骤</li></ul><ol><li>菜单-&gt;vm-&gt;setting,<br><img src="https://ftp.bmp.ovh/imgs/2021/06/e3a56717d76ebe8b.png"></li></ol><ul><li>注意事项和细节说明 </li></ul><ol><li>windows 和 contos 就可以共享文件了，但是在实际开发中，文件的上传下载是需要使用 远程方式完成的 </li><li>远程方式登录，后面<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3></li></ol><ul><li>基本介绍</li></ul><ol><li>linux 的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录“/”，然后在此目录下再创建其他的 目录。 </li><li>深刻理解 linux 树状文件目录是非常重要的</li><li>记住一句经典的话：在 Linux 世界里，一切皆文件(!!)</li><li>示意图<br><img src></li></ol><ul><li>具体的目录结构(不用背,知道即可)</li></ul><ol><li>/bin [常用] (/usr/bin 、 /usr/local/bin) 是 Binary 的缩写, 这个目录存放着最经常使用的命令 </li><li>/sbin (/usr/sbin 、 /usr/local/sbin) s 就是 Super User 的意思，这里存放的是系统管理员使用的系统管理程序。 </li><li>/home [常用] 存放普通用户的主目录，在 Linux 中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名</li><li>/root [常用] 该目录为系统管理员，也称作超级权限者的用户主目录 </li><li>/lib 系统开机所需要最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要 用到这些共享库 </li><li>/lost+found 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件 </li><li>/etc [常用] 所有的系统管理所需要的配置文件和子目录, 比如安装 mysql 数据库 my.conf </li><li>/usr [常用] 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与 windows 下的 program files 目录。 </li><li>/boot [常用] 存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件 </li><li>/proc [不能动] 这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息 </li><li>/srv [不能动] service 缩写，该目录存放一些服务启动之后需要提取的数据 </li><li>/sys [不能动]这是 linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs =》【别 动】 </li><li>/tmp 这个目录是用来存放一些临时文件的 </li><li>/dev 类似于 windows 的设备管理器，把所有的硬件用文件的形式存储 </li><li>/media [常用] linux 系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，linux 会把识别的设备挂载到这个 目录下</li><li>/mnt [常用] 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了。</li><li>/opt 这是给主机额外安装软件所存放的目录。如安装 ORACLE 数据库就可放到该目录下。默认为空 </li><li>/usr/local [常用] 这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序 </li><li>/var [常用] 这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件 </li><li>/selinux [security-enhanced linux] SELinux 是一种安全子系统,它能控制程序只能访问特定文件, 有三种工作模式，可以自行设置.<h2 id="实操篇"><a href="#实操篇" class="headerlink" title="实操篇"></a>实操篇</h2><h3 id="远程登录到-Linux-服务器"><a href="#远程登录到-Linux-服务器" class="headerlink" title="远程登录到 Linux 服务器"></a>远程登录到 Linux 服务器</h3><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4></li><li>linux 服务器是开发小组共享 </li><li>正式上线的项目是运行在公网 </li><li>因此程序员需要远程登录到 Linux 进行项目管理或者开发 </li><li>画出简单的网络拓扑示意图(帮助理解) </li><li>远程登录客户端有 Xshell6， Xftp6 , 我们学习使用 Xshell 和 Xftp6 , 其它的远程工具大同小异<br><img src="https://ftp.bmp.ovh/imgs/2021/07/80931decd2694952.png"><h4 id="远程登录-Linux-Xshell6"><a href="#远程登录-Linux-Xshell6" class="headerlink" title="远程登录 Linux-Xshell6"></a>远程登录 Linux-Xshell6</h4></li><li>说明: Xshell 是目前最好的远程登录到 Linux 操作的软件，流畅的速度并且完美解决了中文乱码的问题， 是目前程序员首选的软件。</li><li>Xshell 是一个强大的安全终端模拟软件，它支持 SSH1, SSH2, 以及 Microsoft Windows 平台的 TELNET 协议。 </li><li>Xshell 可以在 Windows 界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的<h4 id="Xshell-下载-安装-配置和使用"><a href="#Xshell-下载-安装-配置和使用" class="headerlink" title="Xshell-下载-安装-配置和使用:"></a>Xshell-下载-安装-配置和使用:</h4></li><li>下载 free-for-home-school 版本 </li><li>地址: <a href="https://www.netsarang.com/en/free-for-home-school/">https://www.netsarang.com/en/free-for-home-school/</a><h4 id="远程上传下载文件-Xftp6"><a href="#远程上传下载文件-Xftp6" class="headerlink" title="远程上传下载文件-Xftp6"></a>远程上传下载文件-Xftp6</h4></li><li>是一个基于 windows 平台的功能强大的 SFTP、FTP 文件传输软件。使用了 Xftp 以后，windows 用户能安全地 在 UNIX/Linux 和 Windows PC 之间传输文件。<br><img src="https://ftp.bmp.ovh/imgs/2021/07/a32b1dfd807bd85b.png"><h3 id="Vi-和-Vim-编辑器"><a href="#Vi-和-Vim-编辑器" class="headerlink" title="Vi 和 Vim 编辑器"></a>Vi 和 Vim 编辑器</h3><h4 id="vi-和-vim-的基本介绍"><a href="#vi-和-vim-的基本介绍" class="headerlink" title="vi 和 vim 的基本介绍"></a>vi 和 vim 的基本介绍</h4></li><li>Linux 系统会内置 vi </li><li>文本编辑器 Vim 具有程序编辑的能力，可以看做是 Vi 的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。 代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。<h4 id="vi-和-vim-常用的三种模式"><a href="#vi-和-vim-常用的三种模式" class="headerlink" title="vi 和 vim 常用的三种模式"></a>vi 和 vim 常用的三种模式</h4></li><li>正常模式 以 vim 打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中， 你可以使用『上下左右』按键来 移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容， 也可以使用『复制、粘贴』来处理你的文件数 据</li><li>插入模式 按下 i, I, o, O, a, A, r, R 等任何一个字母之后才会进入编辑模式, 一般来说按 i 即可.</li><li>命令行模式 输入 esc 再输入：在这个模式当中， 可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显 示行号等的动作则是在此模式中达成的！<h4 id="vi-和-vim-基本使用"><a href="#vi-和-vim-基本使用" class="headerlink" title="vi 和 vim 基本使用"></a>vi 和 vim 基本使用</h4><img src="https://ftp.bmp.ovh/imgs/2021/07/a85982cfa09fe0ad.png"><h4 id="vi-和-vim-快捷键"><a href="#vi-和-vim-快捷键" class="headerlink" title="vi 和 vim 快捷键"></a>vi 和 vim 快捷键</h4></li><li>拷贝当前行 yy , 拷贝当前行向下的 5 行 5yy，并粘贴（输入 p）。 </li><li>删除当前行 dd , 删除当前行向下的 5 行 5dd </li><li>在文件中查找某个单词 [命令行下 /关键字 ， 回车 查找 , 输入 n 就是查找下一个 ] </li><li>设置文件的行号，取消文件的行号.[命令行下 : set nu 和 :set nonu] </li><li>编辑 /etc/profile 文件，在一般模式下, 使用快捷键到该文档的最末行[G]和最首行[gg] </li><li>在一个文件中输入 “hello” ,在一般模式下, 然后又撤销这个动作 u 7) 编辑 /etc/profile 文件，在一般模式下, 并将光标移动到 , 输入 20,再输入 shift+g </li><li>更多的看整理的文档 </li><li>快捷键的键盘对应图<br><img src="https://ftp.bmp.ovh/imgs/2021/07/518d024f777fd436.png"><h3 id="开机、重启和用户登录注销"><a href="#开机、重启和用户登录注销" class="headerlink" title="开机、重启和用户登录注销"></a>开机、重启和用户登录注销</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4></li><li>shutdown –h now 立该进行关机 </li><li>shudown -h 1 “hello, 1 分钟后会关机了” </li><li>shutdown –r now 现在重新启动计算机 </li><li>halt 关机，作用和上面一样. </li><li>reboot 现在重新启动计算机 </li><li>sync 把内存的数据同步到磁盘.<h4 id="注意细节"><a href="#注意细节" class="headerlink" title="注意细节"></a>注意细节</h4></li><li>不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中 </li><li>目前的 shutdown/reboot/halt 等命令均已经在关机前进行了 sync ， 老韩提醒: 小心驶得万年船<h4 id="用户登录和注销"><a href="#用户登录和注销" class="headerlink" title="用户登录和注销"></a>用户登录和注销</h4></li><li>登录时尽量少用 root 帐号登录，因为它是系统管理员，最大的权限，避免操作失误。可以利用普通用户登录，登录 后再用”su - 用户名’命令来切换成系统管理员身份. </li><li>在提示符下输入 logout 即可注销用户</li><li>logout 注销指令在图形运行级别无效，在运行级别 3 下有效<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4>Linux 系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个 账号，然后以这个账号的身份进入系统<h4 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h4></li></ol><ul><li>基本语法</li></ul><ol><li>useradd 用户名，</li></ol><ul><li>细节说明 </li></ul><ol><li>当创建用户成功后，会自动的创建和用户同名的家目录</li><li>也可以通过 useradd -d 指定目录 新的用户名，给新创建的用户指定家目录<h4 id="指定-修改密码"><a href="#指定-修改密码" class="headerlink" title="指定/修改密码"></a>指定/修改密码</h4></li></ol><ul><li>基本语法</li></ul><ol><li>passwd 用户名</li></ol><ul><li>应用案例</li></ul><ol><li>passwd milan </li><li>补充，显示当前用户所在的目录 pwd<h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4></li></ol><ul><li>基本语法</li></ul><ol><li>userdel 用户名</li></ol><ul><li>应用案例</li></ul><ol><li>删除用户 milan，但是要保留家目录, userdel milan </li><li>删除用户以及用户主目录, 比如 tom, userdel -r tom</li></ol><ul><li>细节说明</li></ul><ol><li>一般情况下保留家目录<h4 id="查询用户信息指令"><a href="#查询用户信息指令" class="headerlink" title="查询用户信息指令"></a>查询用户信息指令</h4></li></ol><ul><li>基本语法</li></ul><ol><li>id 用户名</li></ol><ul><li>细节</li></ul><ol><li>当用户不存在时，返回无此用户<h4 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h4></li></ol><ul><li>介绍 </li></ul><ol><li>在操作 Linux 中，如果当前用户的权限不够，可以通过 su - 指令，切换到高权限用户，比如 root </li></ol><ul><li>基本语法 </li></ul><ol><li>su - 切换用户名 </li></ol><ul><li>应用实例 </li></ul><ol><li>创建一个用户 jack, ，指定密码，然后切换到 jack </li></ol><ul><li>细节说明 </li></ul><ol><li> 从权限高的用户切换到权限低的用户，不需要输入密码，反之需要。 </li><li>当需要返回到原来用户时，使用 exit/logout 指令<h4 id="查看当前用户"><a href="#查看当前用户" class="headerlink" title="查看当前用户"></a>查看当前用户</h4>who am i/whoami<h4 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h4></li></ol><ul><li>介绍</li></ul><ol><li>类似于角色，系统可以对有共性/权限的多个用户进行统一的管理</li></ol><ul><li>新增组 指令 : groupadd 组名</li><li>删除组 指令(基本语法)： groupdel 组名 </li><li>案例演示 </li></ul><ol><li>增加用户时直接加上组 </li><li>指令(基本语法) : useradd –g 用户组 用户名 </li><li>增加一个用户 zwj, 直接将他指定到 wudang </li><li>groupadd wudang </li><li>useradd -g wudang zwj</li></ol><ul><li>修改用户的组 </li></ul><ol><li>指令(基本语法)：usermod –g 用户组 用户名 </li><li>案例演示 创建一个组 mojiao 把 zwj 放入到 mojiao 指令: usermod -g mojiao zw<h4 id="用户和组相关文件"><a href="#用户和组相关文件" class="headerlink" title="用户和组相关文件"></a>用户和组相关文件</h4></li></ol><ul><li>/etc/passwd 文件 </li></ul><ol><li>用户（user）的配置文件，记录用户的各种信息 </li><li>每行的含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录 Shell </li></ol><ul><li>/etc/shadow 文件 </li></ul><ol><li>口令的配置文件 </li><li>每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 </li></ol><ul><li>/etc/group 文件 </li></ul><ol><li>组(group)的配置文件，记录 Linux 包含的组的信息 </li><li>每行含义：组名:口令:组标识号:组内用户列表</li></ol><h3 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h3><h4 id="指定运行级别"><a href="#指定运行级别" class="headerlink" title="指定运行级别"></a>指定运行级别</h4><ul><li>基本介绍 运行级别说明： </li></ul><p>0 ：关机 </p><p>1 ：单用户【找回丢失密码】 </p><p>2：多用户状态没有网络服务 </p><p>3：多用户状态有网络服务 </p><p>4：系统未使用保留给用户 </p><p>5：图形界面 </p><p>6：系统重启 </p><p>常用运行级别是 3 和 5 ，也可以指定默认运行级别， 后面演示 </p><ul><li>应用实例 </li></ul><ol><li>命令：init [0123456] </li><li>应用案例： 通过 init 来切换不同的运行级别，比如动 5-3 ， 然后关机。 </li></ol><ul><li>CentOS7 后运行级别说明<br>在 centos7 以前， /etc/inittab 文件中 . 进行了简化 ，如下: </li></ul><ol><li>multi-user.target: analogous to runlevel 3 </li><li>graphical.target: analogous to runlevel 5 </li><li>‘#’(注意没有‘’) To view current default target, run: </li><li>systemctl get-default </li><li>‘#’(注意没有‘’) To set a default target, run: </li><li>systemctl set-default TARGET.target<h4 id="找回-root-密码（看另一篇博文）"><a href="#找回-root-密码（看另一篇博文）" class="headerlink" title="找回 root 密码（看另一篇博文）"></a>找回 root 密码（看另一篇博文）</h4><h4 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h4></li></ol><ul><li>man 获得帮助信息 </li></ul><ol><li>基本语法：man [命令或配置文件]（功能描述：获得帮助信息） </li><li>案例：查看 ls 命令的帮助信息 man ls </li><li>在 linux 下，隐藏文件是以 .开头 , 选项可以组合使用 比如 ls -al, 比如 ls -al /root </li></ol><ul><li>help 指令 </li></ul><ol><li>基本语法：help 命令 （功能描述：获得 shell 内置命令的帮助信息） </li></ol><ul><li>百度帮助更直接 如果英语不太好的，也可以直接百度靠谱。<h3 id="实用指令-文件目录类"><a href="#实用指令-文件目录类" class="headerlink" title="实用指令-文件目录类"></a>实用指令-文件目录类</h3><h4 id="pwd-指令"><a href="#pwd-指令" class="headerlink" title="pwd 指令"></a>pwd 指令</h4></li><li>基本语法 ：pwd (功能描述：显示当前工作目录的绝对路径)<h4 id="ls-指令"><a href="#ls-指令" class="headerlink" title="ls 指令"></a>ls 指令</h4></li><li>基本语法：ls [选项] [目录或是文件] </li><li>常用选项 </li></ul><ol><li>-a ：显示当前目录所有的文件和目录，包括隐藏的。 </li><li>-l ：以列表的方式显示信息<h4 id="cd-指令"><a href="#cd-指令" class="headerlink" title="cd 指令"></a>cd 指令</h4></li></ol><ul><li>基本语法：cd [参数] (功能描述：切换到指定目录) </li><li>理解：绝对路径和相对路径</li><li>cd ~ 或者 cd ：回到自己的家目录, 比如 你是 root ， </li><li>cd ~ 到 /root cd .. 回到当前目录的上一级目录</li><li>应用实例</li></ul><ol><li>1：使用绝对路径切换到 root 目录 ， cd /root </li><li>2: 使用相对路径到/root 目录, 比如在 /home/tom , cd ../../root 案例 </li><li>3：表示回到当前目录的上一级目录 , cd .. 案例 </li><li>4：回到家目录 , cd ~<h4 id="mkdir-指令"><a href="#mkdir-指令" class="headerlink" title="mkdir 指令"></a>mkdir 指令</h4></li></ol><ul><li>mkdir 指令用于创建目录 </li><li>基本语法：mkdir [选项] 要创建的目录 </li><li>常用选项 -p ：创建多级目录 </li><li>应用实例 </li></ul><p>案例 1:创建一个目录 /home/dog mkdir /home/dog </p><p>案例 2:创建多级目录 /home/animal/tiger </p><p>mkdir -p /home/animal/tiger </p><h4 id="rmdir-指令删除空目录"><a href="#rmdir-指令删除空目录" class="headerlink" title="rmdir 指令删除空目录"></a>rmdir 指令删除空目录</h4><ul><li> 基本语法rmdir [选项] 要删除的空目录 </li><li>应用实例案例:删除一个目录 /home/dog </li><li>使用细节rmdir 删除的是空目录，如果目录下有内容时无法删除的。 提示：如果需要删除非空目录，需要使用 rm -rf 要删除的目录 比如： rm -rf /home/animal<h4 id="touch-指令"><a href="#touch-指令" class="headerlink" title="touch 指令 \"></a>touch 指令 \</h4></li><li>touch 指令创建空文件 </li><li>基本语法</li></ul><p>touch 文件名称 </p><ul><li>应用实例 案例: 在/home 目录下 ， 创建一个空文件 hello.txt<h4 id="cp-指令"><a href="#cp-指令" class="headerlink" title="cp 指令"></a>cp 指令</h4></li><li>cp 指令拷贝文件到指定目录 </li><li>基本语法 cp [选项] source dest </li><li>常用选项 -r ：递归复制整个文件夹 </li><li>应用实例 </li></ul><p>案例 1: 将 /home/hello.txt 拷贝到 /home/bbb 目录下 cp hello.txt /home/bbb </p><p>案例 2: 递归复制整个文件夹，举例, 比如将 /home/bbb 整个目录， 拷贝到 /opt cp -r /home/bbb /opt </p><ul><li>使用细节 强制覆盖不提示的方法：\cp , \cp -r /home/bbb /opt<h4 id="rm-指令"><a href="#rm-指令" class="headerlink" title="rm 指令"></a>rm 指令</h4></li><li>说明：rm 指令移除文件或目录 </li><li>基本语法</li></ul><ol><li>rm [选项] 要删除的文件或目录 </li></ol><ul><li>常用选项 </li></ul><ol><li>-r ：递归删除整个文件夹 </li><li>-f ： 强制删除不提示 </li></ol><ul><li>应用实例 </li></ul><p>案例 1: 将 /home/hello.txt 删除 , rm /home/hello.txt </p><p>案例 2: 递归删除整个文件夹 /home/bbb , rm -rf /home/bbb [删除整个文件夹，不提示] </p><ul><li>使用细节 强制删除不提示的方法：带上 -f 参数即可<h4 id="mv-指令"><a href="#mv-指令" class="headerlink" title="mv 指令"></a>mv 指令</h4></li><li>mv 移动文件与目录或重命名 </li><li>基本语法 </li></ul><ol><li>mv oldNameFile newNameFile (功能描述：重命名) </li><li>mv /temp/movefile /targetFolder (功能描述：移动文件) </li></ol><ul><li>应用实例</li></ul><p>案例 1: 将 /home/cat.txt 文件 重新命名为 pig.txt </p><p>案例 2:将 /home/pig.txt 文件 移动到 /root 目录下 </p><p>案例 3: 移动整个目录 , 比如将 /opt/bbb 移动到 /home 下 mv /opt/bbb /home/ </p><h4 id="cat-指令"><a href="#cat-指令" class="headerlink" title="cat 指令"></a>cat 指令</h4><ul><li>cat 查看文件内容 </li><li>基本语法</li></ul><ol><li>cat [选项] 要查看的文件 </li></ol><ul><li>常用选项 -n ：显示行号 </li><li>应用实例 </li></ul><p>案例 1: /etc/profile 文件内容，并显示行号 </p><ul><li>使用细节 </li></ul><ol><li>cat 只能浏览文件，而不能修改文件，为了浏览方便，一般会带上 管道命令 | more </li><li>cat -n /etc/profile | more [进行交互]<h4 id="more-指令"><a href="#more-指令" class="headerlink" title="more 指令"></a>more 指令</h4></li></ol><ul><li>more 指令是一个基于 VI 编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more 指令中内置了若 干快捷键(交互的指令)，详见操作说明 </li><li>基本语法 </li></ul><ol><li>more 要查看的文件 </li><li>操作说明，如图<br><img src="https://ftp.bmp.ovh/imgs/2021/07/4a4cedfead7e5b01.png"><h4 id="less-指令"><a href="#less-指令" class="headerlink" title="less 指令"></a>less 指令</h4></li></ol><ul><li>less 指令用来分屏查看文件内容，它的功能与 more 指令类似，但是比 more 指令更加强大，支持各种显示终端。less 指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有 较高的效率。 </li><li> 基本语法 </li></ul><ol><li>less 要查看的文件 </li><li>操作说明<br><img src="https://ftp.bmp.ovh/imgs/2021/07/7fba1a3a1630c75d.png"><h4 id="echo-指令"><a href="#echo-指令" class="headerlink" title="echo 指令"></a>echo 指令</h4></li></ol><ul><li>echo 输出内容到控制台 </li><li>基本语法 echo [选项] [输出内容] </li><li>应用实例 </li></ul><p>案例: 使用 echo 指令输出环境变量, 比如输出 $PATH $HOSTNAME, echo $HOSTNAME</p><h4 id="head-指令"><a href="#head-指令" class="headerlink" title="head 指令"></a>head 指令</h4><ul><li>head 用于显示文件的开头部分内容，默认情况下 head 指令显示文件的前 10 行内容 </li><li>基本语法 </li></ul><ol><li>head 文件 (功能描述：查看文件头 10 行内容) </li><li>head -n 5 文件 (功能描述：查看文件头 5 行内容，5 可以是任意行数) </li></ol><ul><li>应用实例 </li></ul><p>案例: 查看/etc/profile 的前面 5 行代码 head -n 5 /etc/profile</p><h4 id="tail-指令"><a href="#tail-指令" class="headerlink" title="tail 指令"></a>tail 指令</h4><ul><li>tail 用于输出文件中尾部的内容，默认情况下 tail 指令显示文件的前 10 行内容。 </li><li> 基本语法 </li></ul><ol><li>tail 文件 （功能描述：查看文件尾 10 行内容） </li><li>tail -n 5 文件 （功能描述：查看文件尾 5 行内容，5 可以是任意行数） </li><li>tail -f 文件 （功能描述：实时追踪该文档的所有更新） </li></ol><ul><li>应用实例 </li></ul><p>案例 1: 查看/etc/profile 最后 5 行的代码 tail -n 5 /etc/profile </p><p>案例 2: 实时监控 mydate.txt , 看看到文件有变化时，是否看到， 实时的追加 hello,world tail -f /home/mydate.txt</p><h4 id="gt-指令-和-gt-gt-指令"><a href="#gt-指令-和-gt-gt-指令" class="headerlink" title="&gt; 指令 和 &gt;&gt; 指令"></a>&gt; 指令 和 &gt;&gt; 指令</h4><ul><li><blockquote><p>输出重定向和 &gt;&gt; 追加</p></blockquote></li><li>基本语法 </li></ul><ol><li>ls -l &gt;文件 （功能描述：列表的内容写入文件 a.txt 中（覆盖写）） </li><li>ls -al &gt;&gt;文件 （功能描述：列表的内容追加到文件 aa.txt 的末尾） </li><li>cat 文件 1 &gt; 文件 2 （功能描述：将文件 1 的内容覆盖到文件 2） </li><li>echo “内容”&gt;&gt; 文件 (追加) </li></ol><ul><li>应用实例 </li></ul><p>案例 1: 将 /home 目录下的文件列表 写入到 /home/info.txt 中, 覆盖写入 ls -l /home &gt; /home/info.txt [如果 info.txt 没有，则会创建] </p><p>案例 2: 将当前日历信息 追加到 /home/mycal 文件中 </p><p>指令为： cal &gt;&gt; /home/mycal</p><h4 id="ln-指令"><a href="#ln-指令" class="headerlink" title="ln 指令"></a>ln 指令</h4><ul><li>软链接也称为符号链接，类似于 windows 里的快捷方式，主要存放了链接其他文件的路径 </li><li>基本语法 ln -s [原文件或目录] [软链接名] （功能描述：给原文件创建一个软链接） </li><li>应用实例 </li></ul><p>案例 1: 在/home 目录下创建一个软连接 myroot，连接到 /root 目录 ln -s /root /home/myroot </p><p>案例 2: 删除软连接 myroot rm /home/myroot </p><ul><li>细节说明 当我们使用 pwd 指令查看目录时，仍然看到的是软链接所在目录<h4 id="history-指令"><a href="#history-指令" class="headerlink" title="history 指令"></a>history 指令</h4></li><li>查看已经执行过历史命令,也可以执行历史指令 </li><li>基本语法 history （功能描述：查看已经执行过历史命令） </li><li>应用实例 </li></ul><p>案例 1: 显示所有的历史命令 history </p><p>案例 2: 显示最近使用过的 10 个指令。 history 10 </p><p>案例 3：执行历史编号为 5 的指令 </p><p>!5</p><h3 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h3><h4 id="date-指令-显示当前日期"><a href="#date-指令-显示当前日期" class="headerlink" title="date 指令-显示当前日期"></a>date 指令-显示当前日期</h4><ul><li>基本语法 </li></ul><ol><li>date （功能描述：显示当前时间） </li><li>date +%Y（功能描述：显示当前年份） </li><li>date +%m（功能描述：显示当前月份） </li><li>date +%d （功能描述：显示当前是哪一天） </li><li>date “+%Y-%m-%d %H:%M:%S”（功能描述：显示年月日时分秒） </li></ol><ul><li>应用实例 </li></ul><p>案例 1: 显示当前时间信息 date </p><p>案例 2: 显示当前时间年月日 date “+%Y-%m-%d</p><p>案例 3: 显示当前时间年月日时分秒 date “+%Y-%m-%d %H:%M:%S”(特殊格式，可不能乱写)</p><h4 id="date-指令-设置日期"><a href="#date-指令-设置日期" class="headerlink" title="date 指令-设置日期"></a>date 指令-设置日期</h4><ul><li>基本语法 date -s 字符串时间 </li><li>应用实例<br>案例 1: 设置系统当前时间 ， 比如设置成 2020-11-03 20:02:10 date -s “2020-11-03 20:02:10” <h4 id="cal-指令"><a href="#cal-指令" class="headerlink" title="cal 指令"></a>cal 指令</h4></li><li>查看日历指令 cal </li><li>基本语法 cal [选项] （功能描述：不加选项，显示本月日历） </li><li>应用实例 </li></ul><p>案例 1: 显示当前日历 cal </p><p>案例 2: 显示 2020 年日历 : cal 2020</p><h3 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h3><h4 id="find-指令"><a href="#find-指令" class="headerlink" title="find 指令"></a>find 指令</h4><ul><li>find 指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。 </li><li>基本语法 find [搜索范围] [选项] </li><li>选项说明<br><img src="https://ftp.bmp.ovh/imgs/2021/07/c65238e78ea090f1.png"></li><li>应用实例 </li></ul><p>案例 1: 按文件名：根据名称查找/home 目录下的 hello.txt 文件 </p><p>find /home -name hello.txt </p><p>案例 2：按拥有者：查找/opt 目录下，用户名称为 nobody 的文件 </p><p>find /opt -user nobody </p><p>案例 3：查找整个 linux 系统下大于 200M 的文件（+n 大于 -n 小于 n 等于, 单位有 k,M,G） </p><p>find / -size +200M</p><h4 id="locate-指令"><a href="#locate-指令" class="headerlink" title="locate 指令"></a>locate 指令</h4><ul><li>locate 指令可以快速定位文件路径。locate 指令利用事先建立的系统中所有文件名称及路径的 locate 数据库实现快速 定位给定的文件。Locate 指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更 新 locate 时刻 </li><li>基本语法 locate 搜索文件 </li><li>特别说明 由于 locate 指令基于数据库进行查询，所以第一次运行前，必须使用 updatedb 指令创建 locate 数据库。 </li><li>应用实例 </li></ul><p>案例 1: 请使用 locate 指令快速定位 hello.txt 文件所在目录 </p><p>which 指令，可以查看某个指令在哪个目录下，比如 ls 指令在哪个目录 </p><p>which ls</p><h4 id="grep-指令和-管道符号"><a href="#grep-指令和-管道符号" class="headerlink" title="grep 指令和 管道符号 |"></a>grep 指令和 管道符号 |</h4><p><img src="https://ftp.bmp.ovh/imgs/2021/07/60958e235720e4e1.png"></p><h3 id="压缩和解压类"><a href="#压缩和解压类" class="headerlink" title="压缩和解压类"></a>压缩和解压类</h3><h4 id="gzip-gunzip-指令"><a href="#gzip-gunzip-指令" class="headerlink" title="gzip/gunzip 指令"></a>gzip/gunzip 指令</h4><ul><li>gzip 用于压缩文件， gunzip 用于解压的 </li><li>基本语法 </li><li>gzip 文件 （功能描述：压缩文件，只能将文件压缩为*.gz 文件） </li><li>gunzip 文件.gz （功能描述：解压缩文件命令） </li><li>应用实例 </li></ul><p>案例 1: gzip 压缩， 将 /home 下的 hello.txt 文件进行压缩</p><p>gzip /home/hello.txt </p><p>案例 2: gunzip 压缩， 将 /home 下的 hello.txt.gz 文件进行解压缩 </p><p>gunzip /home/hello.txt.gz</p><h4 id="zip-unzip"><a href="#zip-unzip" class="headerlink" title="zip/unzip"></a>zip/unzip</h4><ul><li>指令 zip 用于压缩文件， unzip 用于解压的，这个在项目打包发布中很有用的 </li><li> 基本语法 zip [选项] XXX.zip 将要压缩的内容（功能描述：压缩文件和目录的命令） </li><li>unzip [选项] XXX.zip （功能描述：解压缩文件） </li><li>zip 常用选项 -r：递归压缩，即压缩目录 </li><li>unzip 的常用选项 -d&lt;目录&gt; ：指定解压后文件的存放目录 </li><li>应用实例 </li></ul><p>案例 1: 将 /home 下的 所有文件/文件夹进行压缩成 myhome.zip </p><p>zip -r myhome.zip /home/ [将 home 目录及其包含的文件和子文件夹都压缩] </p><p>案例 2: 将 myhome.zip 解压到 /opt/tmp 目录下 </p><p>mkdir /opt/tmp </p><p>unzip -d /opt/tmp /home/myhome.zip</p><h4 id="tar-指令"><a href="#tar-指令" class="headerlink" title="tar 指令"></a>tar 指令</h4><ul><li>tar 指令 是打包指令，最后打包后的文件是 .tar.gz 的文件。</li><li>基本语法 tar [选项] XXX.tar.gz 打包的内容 (功能描述：打包目录，压缩后的文件格式.tar.gz) </li><li>选项说明<br><img src="https://ftp.bmp.ovh/imgs/2021/07/6a0b5c342f8cd803.png"></li><li> 应用实例 </li></ul><p>案例 1: 压缩多个文件，将 /home/pig.txt 和 /home/cat.txt 压缩成 pc.tar.gz </p><p>tar -zcvf pc.tar.gz /home/pig.txt /home/cat.txt </p><p>案例 2: 将/home 的文件夹 压缩成 myhome.tar.gz </p><p>tar -zcvf myhome.tar.gz /home/ </p><p>案例 3: 将 pc.tar.gz 解压到当前目录 </p><p>tar -zxvf pc.tar.gz </p><p>案例4: 将myhome.tar.gz 解压到 /opt/tmp2目录下 </p><p>(1) mkdir /opt/tmp2 </p><p>(2) tar -zxvf /home/myhome.tar.gz -C /opt/tmp2</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=434902428&auto=1&height=66"></iframe>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;linux入门&quot;&gt;&lt;a href=&quot;#linux入门&quot; class=&quot;headerlink&quot; title=&quot;linux入门&quot;&gt;&lt;/a&gt;linux入门&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>StringBuffer 类常见方法</title>
    <link href="http://example.com/2021/06/22/StringBuffer%20%E7%B1%BB%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2021/06/22/StringBuffer%20%E7%B1%BB%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/</id>
    <published>2021-06-22T08:17:16.000Z</published>
    <updated>2021-06-22T08:21:29.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="StringBuffer-类常见方法"><a href="#StringBuffer-类常见方法" class="headerlink" title="StringBuffer 类常见方法"></a>StringBuffer 类常见方法</h1><span id="more"></span><p><img src="https://i.loli.net/2021/06/22/ewMhVdbDGu7AJkU.png"><br><img src="https://i.loli.net/2021/06/22/usijIvDAZxyXa2W.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;StringBuffer-类常见方法&quot;&gt;&lt;a href=&quot;#StringBuffer-类常见方法&quot; class=&quot;headerlink&quot; title=&quot;StringBuffer 类常见方法&quot;&gt;&lt;/a&gt;StringBuffer 类常见方法&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>String常用方法</title>
    <link href="http://example.com/2021/06/22/String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2021/06/22/String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2021-06-22T07:02:32.000Z</published>
    <updated>2021-06-22T07:18:54.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h1><span id="more"></span><p><img src="https://i.loli.net/2021/06/22/2gLhzsjVBSoOiM5.png"><br><img src="https://i.loli.net/2021/06/22/wNl8B5oUe63tXYK.png"><br><img src="https://i.loli.net/2021/06/22/2sz9FlVcRLOEZbo.png"><br><img src="https://i.loli.net/2021/06/22/qwlI1Gm7zVckPC8.png"><br><img src="https://i.loli.net/2021/06/22/hzCraFUS9ZoLMqj.png"><br><img src="https://i.loli.net/2021/06/22/ahQewN3fS7Tvq4j.png"><br><img src="https://i.loli.net/2021/06/22/xsiTwz7QBPUWRe4.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;String常用方法&quot;&gt;&lt;a href=&quot;#String常用方法&quot; class=&quot;headerlink&quot; title=&quot;String常用方法&quot;&gt;&lt;/a&gt;String常用方法&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>SuppressWarning 中的属性介绍以及属性说明</title>
    <link href="http://example.com/2021/06/17/@SuppressWarning%20%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E/"/>
    <id>http://example.com/2021/06/17/@SuppressWarning%20%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E/</id>
    <published>2021-06-17T07:12:30.000Z</published>
    <updated>2021-06-20T09:51:17.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SuppressWarning-中的属性介绍以及属性说明"><a href="#SuppressWarning-中的属性介绍以及属性说明" class="headerlink" title="@SuppressWarning 中的属性介绍以及属性说明"></a>@SuppressWarning 中的属性介绍以及属性说明</h1><span id="more"></span><ul><li>all，抑制所有警告</li><li>boxing，抑制与封装/拆装作业相关的警告</li><li>cast，抑制与强制转型作业相关的警告</li><li>dep-ann，抑制与淘汰注释相关的警告</li><li>deprecation，抑制与淘汰的相关警告</li><li>fallthrough，抑制与switch陈述式中遗漏break相关的警告</li><li>finally，抑制与未传回finally区块相关的警告</li><li>hiding，抑制与隐藏变数的区域变数相关的警告</li><li>incomplete-switch，抑制与switch陈述式(enum case)中遗漏项目相关的警告</li><li>javadoc，抑制与javadoc相关的警告</li><li>nls，抑制与非nls字串文字相关的警告</li><li>null，抑制与空值分析相关的警告</li><li>rawtypes，抑制与使用raw类型相关的警告</li><li>resource，抑制与使用Closeable类型的资源相关的警告</li><li>restriction，抑制与使用不建议或禁止参照相关的警告</li><li>serial，抑制与可序列化的类别遗漏serialVersionUID栏位相关的警告</li><li>static-access，抑制与静态存取不正确相关的警告</li><li>static-method，抑制与可能宣告为static的方法相关的警告</li><li>super，抑制与置换方法相关但不含super呼叫的警告</li><li>synthetic-access，抑制与内部类别的存取未最佳化相关的警告</li><li>sync-override，抑制因为置换同步方法而遗漏同步化的警告</li><li>unchecked，抑制与未检查的作业相关的警告</li><li>unqualified-field-access，抑制与栏位存取不合格相关的警告</li><li>unused，抑制与未用的程式码及停用的程式码相关的警告</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SuppressWarning-中的属性介绍以及属性说明&quot;&gt;&lt;a href=&quot;#SuppressWarning-中的属性介绍以及属性说明&quot; class=&quot;headerlink&quot; title=&quot;@SuppressWarning 中的属性介绍以及属性说明&quot;&gt;&lt;/a&gt;@SuppressWarning 中的属性介绍以及属性说明&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java自学完成项目</title>
    <link href="http://example.com/2021/06/05/java%E8%87%AA%E5%AD%A6%E5%AE%8C%E6%88%90%E9%A1%B9%E7%9B%AE/"/>
    <id>http://example.com/2021/06/05/java%E8%87%AA%E5%AD%A6%E5%AE%8C%E6%88%90%E9%A1%B9%E7%9B%AE/</id>
    <published>2021-06-05T01:57:52.000Z</published>
    <updated>2021-08-23T10:22:25.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java自学完成项目"><a href="#Java自学完成项目" class="headerlink" title="Java自学完成项目"></a>Java自学完成项目</h1><span id="more"></span><h1 id="《《文章很长，目录在右下角》》"><a href="#《《文章很长，目录在右下角》》" class="headerlink" title="《《文章很长，目录在右下角》》"></a>《《文章很长，目录在右下角》》</h1><h2 id="零钱通（oop版）"><a href="#零钱通（oop版）" class="headerlink" title="零钱通（oop版）"></a>零钱通（oop版）</h2><ul><li>package com.javacode.smallchangesys.OOP;</li></ul><p>public class SmallChangeSysAPP {</p><pre><code>public static void main(String[] args) &#123;    new SmallChangeSysOOP().mainMenu();&#125;</code></pre><p>}</p><ul><li>package com.javacode.smallchangesys.OOP;</li></ul><p>import java.text.SimpleDateFormat;</p><p>import java.util.Date;</p><p>import java.util.Scanner;</p><p>public class SmallChangeSysOOP {</p><pre><code>Scanner scanner = new Scanner(System.in);//根据功能需求，定义变量String key = &quot;&quot;;//明细变量String details = (&quot;\n -----------------零钱通明细----------------&quot;);//收益变量double money;double balance = 0;Date date = null;SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);//消费变量String note = &quot;&quot;;boolean loop = true;public void mainMenu() &#123;    do&#123;        System.out.println(&quot;---------零钱通菜单---------&quot;);        System.out.println(&quot;\t\t1.零钱通明细&quot;);        System.out.println(&quot;\t\t2.收益入账&quot; );        System.out.println(&quot;\t\t3.消费&quot;);        System.out.println(&quot;\t\t4.退出&quot;);        System.out.println(&quot;---------------------------&quot;);        System.out.print(&quot;请选择你要执行的操作1-4: &quot;);        key = scanner.next();        //利用分支结构，做出功能选择        switch(key)&#123;            case &quot;1&quot;:                this.details();                break;            case &quot;2&quot;:                this.income();                break;            case &quot;3&quot;:                this.pey();                break;            case &quot;4&quot;:                this.exit();                break;            default:                System.out.println(&quot;你输入的有误，请重新输入&quot;);        &#125;    &#125;while(loop);    System.out.println(&quot;你已经退出&quot;);&#125;public void details() &#123;    System.out.println(details);&#125;public void income() &#123;    System.out.println(&quot;收益入账金额:&quot;);    money = scanner.nextDouble();    //应该有金钱校验    if (money &lt;= 0) &#123;        System.out.println(&quot;你需要输入大于零的金额&quot;);        return;    &#125;    date = new Date();    balance += money;    details += &quot;\n收益入账\t&quot; + money + &quot;\t&quot; + sdf.format(date) + &quot;\t&quot; + &quot;余额：&quot; + balance;&#125;public void pey() &#123;    System.out.println(&quot;消费金额&quot;);    money = scanner.nextDouble();    //金钱校验    if (money &lt;= 0 || money &gt; balance) &#123;        System.out.println(&quot;你消费的金额需在0-&quot; + balance);        return;    &#125;    System.out.println(&quot;消费原因&quot;);    note = scanner.next();    date = new Date();    balance -= money;    details += &quot;\n&quot; + note + &quot;\t-&quot; + money + &quot;\t&quot; + sdf.format(date) + &quot;\t&quot; + &quot;余额：&quot; + balance;&#125;public void exit() &#123;    //提示是否退出    //1)判断输入是否有误    String choice = &quot;&quot;;    while (true) &#123;        System.out.println(&quot;确定退出？ y/n&quot;);        choice = scanner.next();        if (&quot;y&quot;.equals(choice) || &quot;n&quot;.equals(choice)) &#123;            break;        &#125;    &#125;    //  2）判断输入y/n    if (&quot;y&quot;.equals(choice)) &#123;        loop = false;    &#125;&#125;</code></pre><p>}</p><h2 id="房屋出租系统（工具类Utility）"><a href="#房屋出租系统（工具类Utility）" class="headerlink" title="房屋出租系统（工具类Utility）"></a>房屋出租系统（工具类Utility）</h2><p>package com.ljq.house;</p><p>import com.ljq.house.view.HouseView;</p><p>public class HouseApp {</p><pre><code>public static void main(String[] args) &#123;    new HouseView().mainMenu();    System.out.println(&quot;你退出了~&quot;);&#125;</code></pre><p>}</p><p>package com.ljq.house.view;</p><p>import com.ljq.house.domain.House;<br>import com.ljq.house.service.HouseService;<br>import com.ljq.house.utils.Utility;</p><p>/**</p><ul><li>1.显示主菜单</li><li>2.提供用户输入</li><li>3.调用HouseService实现各种操作</li></ul><p>*/</p><p>public class HouseView {</p><pre><code>//显示主菜单的变量private boolean loop = true;//控制主菜单循环private char key = &#39; &#39;;//用户输入//房屋列表变量private HouseService houseService = new HouseService(10);//设置数组大小//根据id查找对象，并进行修改public void updateHouse() &#123;    System.out.println(&quot;============修改房屋信息============&quot;);    System.out.print(&quot;请输入你要修改的房屋id（-1表示退出）&quot;);    int updateId = Utility.readInt();    if (updateId == -1) &#123;        System.out.println(&quot;===========放弃修改房屋信息===========&quot;);        return;    &#125;    House house = houseService.lookup(updateId);    if (house != null) &#123;        System.out.print(&quot;姓名（&quot; + house.getName() + &quot;）：&quot;);        //如果用户不修改，直接回车，默认&quot;&quot;，下面同理        String name = Utility.readString(6, &quot;&quot;);        if (!&quot;&quot;.equals(name)) &#123;//name不是默认，进行修改,下面同理            house.setName(name);        &#125;        System.out.print(&quot;电话（&quot; + house.getPhone() + &quot;）：&quot;);        String phone = Utility.readString(16, &quot;&quot;);        if (!&quot;&quot;.equals(phone)) &#123;            house.setPhone(phone);        &#125;        System.out.print(&quot;地址（&quot; + house.getAddress() + &quot;）：&quot;);        String address = Utility.readString(24, &quot;&quot;);        if (!&quot;&quot;.equals(address)) &#123;            house.setAddress(address);        &#125;        System.out.print(&quot;租金（&quot; + house.getMonthly() + &quot;）：&quot;);        String monthly = Utility.readString(10, &quot;&quot;);        if (!&quot;&quot;.equals(monthly)) &#123;            house.setMonthly(monthly);        &#125;        System.out.print(&quot;状态（未出租/已出租）（&quot; + house.getState() + &quot;）：&quot;);        String state = Utility.readString(5, &quot;&quot;);        if (!&quot;&quot;.equals(state)) &#123;            house.setState(state);        &#125;        System.out.println(&quot;==============修改成功=============&quot;);    &#125; else &#123;        System.out.println(&quot;===========修改的房屋不存在===========&quot;);    &#125;&#125;//编写lookupId方法，接收输入id，调用lookup方法查找public void lookupId() &#123;    System.out.println(&quot;=============查找房屋=============&quot;);    System.out.print(&quot;请输入你要查找的id&quot;);    int lookupId = Utility.readInt();    if (houseService.lookup(lookupId) != null) &#123;        System.out.println(&quot;=============查找成功=============&quot;);    &#125; else &#123;        System.out.println(&quot;=============查找失败=============&quot;);    &#125;&#125;//实现退出确认public void exit() &#123;    //利用工具类    char c = Utility.readConfirmSelection();    if (c == &#39;Y&#39;) &#123;        loop = false;    &#125;&#125;//编写delHouse方法，接受要输入的id，调用Service中的del方法public void delHouse() &#123;    System.out.println(&quot;=============删除房屋=============&quot;);    System.out.print(&quot;请输入需要删除房屋的编号（-1退出）：&quot;);    int delId = Utility.readInt();    if (delId == -1) &#123;        System.out.println(&quot;==========你退出了房屋删除==========&quot;);        return;    &#125;    //该方法有循环判断的逻辑，不输入Y或N出不来    char choice = Utility.readConfirmSelection();    if (choice == &#39;Y&#39;) &#123;//真的删除，调用del方法        if (houseService.del(delId)) &#123;            System.out.println(&quot;==========删除房屋成功==========&quot;);        &#125; else &#123;            System.out.println(&quot;=======删除失败，房屋不存在=======&quot;);        &#125;    &#125; else &#123;        System.out.println(&quot;==========你退出了房屋删除==========&quot;);    &#125;&#125;//编写addHouse，接收输入，创建新对象，调用add方法public void addHouse() &#123;    System.out.println(&quot;\n=============添加房屋=============&quot;);    System.out.print(&quot;姓名：&quot;);    String name = Utility.readString(8);    System.out.print(&quot;电话：&quot;);    String phone = Utility.readString(16);    System.out.print(&quot;地址：&quot;);    String address = Utility.readString(24);    System.out.print(&quot;月租：&quot;);    String monthly = Utility.readString(10);    System.out.print(&quot;状态(未出租/已出租)：&quot;);    String state = Utility.readString(5);    House house = new House(0, name, phone, address, monthly, state);    if (houseService.add(house)) &#123;        System.out.println(&quot;=============添加房屋成功=============&quot;);    &#125; else &#123;        System.out.println(&quot;=============添加房屋失败=============&quot;);    &#125;&#125;//显示主菜单的方法public void mainMenu() &#123;    do &#123;        System.out.println(&quot;===========房屋出租系统============&quot;);        System.out.println(&quot;\t\t\t1.新增房源&quot;);        System.out.println(&quot;\t\t\t2.查找房屋&quot;);        System.out.println(&quot;\t\t\t3.删除房屋&quot;);        System.out.println(&quot;\t\t\t4.修改房屋信息&quot;);        System.out.println(&quot;\t\t\t5.房屋列表&quot;);        System.out.println(&quot;\t\t\t6.退   出&quot;);        System.out.print(&quot;请输入你的选择（1-6）：&quot;);        key = Utility.readChar();        switch (key) &#123;            case &#39;1&#39;:                addHouse();                break;            case &#39;2&#39;:                lookupId();                break;            case &#39;3&#39;:                delHouse();                break;            case &#39;4&#39;:                updateHouse();                break;            case &#39;5&#39;:                listHouse();                break;            case &#39;6&#39;:                exit();                break;        &#125;    &#125; while (loop);&#125;//房屋列表public void listHouse() &#123;    House[] house = houseService.list();//得到所有数组信息    System.out.println(&quot;\n=============房屋列表=============&quot;);    System.out.println(&quot;编号\t\t房主\t\t电话\t\t地址\t\t月租\t\t状态（未出租/已出租）&quot;);    for (int i = 0; i &lt; house.length; i++) &#123;        if (house[i] == null) &#123;            break;        &#125;        System.out.println(house[i]);    &#125;    System.out.println(&quot;==========房屋列表显示结束=========&quot;);&#125;</code></pre><p>}</p><p>package com.ljq.house.service;</p><p>import com.ljq.house.domain.House;</p><p>public class HouseService {</p><pre><code>private House[] house;private int houseNums = 1;private int idCounter = 1;public HouseService(int size) &#123;    house = new House[size];//size指定数组大小    house[0] = new House(1, &quot;jack&quot;, &quot;404&quot;, &quot;新城区&quot;, &quot;3000&quot;, &quot;未出租&quot;);&#125;//编写lookup方法public House lookup(int lookupId) &#123;    int index = -1;    for (int i = 0; i &lt; houseNums; i++) &#123;        if (i == lookupId - 1) &#123;            index = i;            System.out.println(house[i]);        &#125;    &#125;    if (index == -1) &#123;        System.out.println(&quot;没有找到此id&quot;);        return null;    &#125;    return house[index];&#125;//编写del方法public boolean del(int delId) &#123;    int index = -1;//索引值    //找到删除房屋编号的对应下标    for (int i = 0; i &lt; houseNums; i++) &#123;        if (delId == house[i].getId()) &#123;            index = i;        &#125;    &#125;    if (index == -1) &#123;//证明了删除房屋不存在        return false;    &#125;    //将被删除的这个坑填上，    for (int i = index; i &lt; houseNums - 1; i++) &#123;        house[i] = house[i + 1];    &#125;    //将最后一个置空6    house[--houseNums] = null;    return true;&#125;//编写add方法，添加新对象，返回boolean值public boolean add(House newHouse) &#123;    //判断是否可以添加    if (houseNums == house.length) &#123;        System.out.println(&quot;你的数组已经满了。。。。&quot;);        return false;    &#125;    //把newHouse加入到新增加的一个房屋    house[houseNums++] = newHouse;    newHouse.setId(++idCounter);    return true;&#125;//编写list方法，返回数组public House[] list() &#123;    return house;&#125;</code></pre><p>}</p><p>package com.ljq.house.domain;</p><p>/**</p><ul><li>House表示一个房屋信息</li></ul><p>*/</p><p>public class House {</p><pre><code>//编号 房主 电话 地址 月租 状态(未出租/已出租private int id;private String name;private String phone;private String address;private String monthly;private String state;public House(int id, String name, String phone, String address, String monthly, String state) &#123;    this.id = id;    this.name = name;    this.phone = phone;    this.address = address;    this.monthly = monthly;    this.state = state;&#125;@Overridepublic String toString() &#123;    return  id +            &quot;\t\t&quot; + name +            &quot;\t&quot; + phone +            &quot;\t\t&quot; + address +            &quot;\t&quot; + monthly +            &quot;\t&quot; + state ;&#125;public int getId() &#123;    return id;&#125;public void setId(int id) &#123;    this.id = id;&#125;public String getName() &#123;    return name;&#125;public void setName(String name) &#123;    this.name = name;&#125;public String getPhone() &#123;    return phone;&#125;public void setPhone(String phone) &#123;    this.phone = phone;&#125;public String getAddress() &#123;    return address;&#125;public void setAddress(String address) &#123;    this.address = address;&#125;public String getMonthly() &#123;    return monthly;&#125;public void setMonthly(String monthly) &#123;    this.monthly = monthly;&#125;public String getState() &#123;    return state;&#125;public void setState(String state) &#123;    this.state = state;&#125;</code></pre><p>}</p><h2 id="坦克大战"><a href="#坦克大战" class="headerlink" title="坦克大战"></a>坦克大战</h2><p>package com.ljq.tank03;</p><p>import jdk.nashorn.internal.ir.CallNode;</p><p>import javax.swing.*;<br>import java.awt.event.WindowAdapter;<br>import java.awt.event.WindowEvent;<br>import java.util.Scanner;</p><p>/**</p><ul><li>@author 6+7</li><li>@version 1.0</li><li>窗口</li></ul><p>*/</p><p>public class LjqTankGame03 extends JFrame {</p><pre><code>MyPanel mp =null;//定义面板属性static Scanner scanner = new Scanner(System.in);public static void main(String[] args) &#123;    LjqTankGame03 ljqTankGame01 = new LjqTankGame03();&#125;public LjqTankGame03()&#123;    System.out.println(&quot;请输入你的选择：1，开始新的游戏/2，继续上局游戏&quot;);    String key = scanner.next();    mp = new MyPanel(key);//面板    new Thread(mp).start();    this.add(mp);//添加画板到窗口    this.setSize(1350,750);//窗口大小    this.addKeyListener(mp);    this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//退出    this.setVisible(true);//可视化    //在JFrame中增加相应的关闭窗口的处理    this.addWindowListener(new WindowAdapter() &#123;        @Override        public void windowClosing(WindowEvent e) &#123;            Recorder.keepRecorder();            System.exit(0);        &#125;    &#125;);&#125;</code></pre><p>}</p><p>public class Tank {</p><pre><code>boolean isLive = true;private int x;private int y;private int direction = 0;//方向《上下左右=0123》private int speed = 3;//速度，默认为1public Tank(int x, int y) &#123;    this.x = x;    this.y = y;&#125;public void moveUp()&#123;    y-=speed;&#125;public void moveDown()&#123;    y+=speed;&#125;public void moveLeft()&#123;    x-=speed;&#125;public void moveRight()&#123;    x+=speed;&#125;public int getDirection() &#123;    return direction;&#125;public void setDirection(int direction) &#123;    this.direction = direction;&#125;public int getSpeed() &#123;    return speed;&#125;public void setSpeed(int speed) &#123;    this.speed = speed;&#125;public int getX() &#123;    return x;&#125;public void setX(int x) &#123;    this.x = x;&#125;public int getY() &#123;    return y;&#125;public void setY(int y) &#123;    this.y = y;&#125;</code></pre><p>}</p><p>public class MyTank extends Tank{</p><pre><code>Shot shot = null;//可以发射多颗子弹（集合）Vector&lt;Shot&gt; shots = new Vector&lt;&gt;();public MyTank(int x, int y) &#123;    super(x, y);&#125;//因为是我放坦克的子弹，所以放在这//向敌人发射子弹的方法public void shotEnemyTank()&#123;    //控制一下，每次最多五枚子弹    if(shots.size() &gt; 5)&#123;        return;    &#125;    //射向敌人时方向不同    switch (getDirection()) &#123;        case 0://车身向上            shot = new Shot(getX() + 18, getY() - 5, 0);            break;        case 1://车身向右            shot = new Shot(getX() + 55, getY() + 28, 1);            break;        case 2://车身向下            shot = new Shot(getX() + 18, getY() + 65, 2);            break;        case 3://车身向左            shot = new Shot(getX() - 15, getY() + 28, 3);            break;    &#125;    //把新建的shot放到shots中    shots.add(shot);    //启动线程    new Thread(shot).start();&#125;</code></pre><p>}</p><p>public class EnemyTank extends Tank implements Runnable{</p><pre><code>boolean isLive = true;//敌人的子弹Vector&lt;Shot&gt; shots = new Vector&lt;&gt;();//增加成员，可以得到敌人坦克的VectorVector&lt;EnemyTank&gt; enemyTanks = new Vector&lt;&gt;();public EnemyTank(int x, int y) &#123;    super(x, y);&#125;//这里提供一个方法，可以将MyPanel中的敌人坦克集合拿过来public void setEnemyTanks(Vector&lt;EnemyTank&gt; enemyTanks) &#123;    this.enemyTanks = enemyTanks;&#125;public boolean isCollision()&#123;    switch(this.getDirection())&#123;        case 0://上            //让当前坦克和所有坦克比较（循环）            for (int i = 0; i &lt; enemyTanks.size(); i++) &#123;                //取出一个                EnemyTank enemyTank = enemyTanks.get(i);                //不能和自己比较                if(this != enemyTank)&#123;                    //如果敌人坦克是上/下                    //敌方坦克的取值范围x[enemyTank.getX()   enemyTank.getX() + 40]                    //               y[enemyTank.getY()   enemyTank.getY() + 60]                    if(enemyTank.getDirection() == 0 || enemyTank.getDirection() == 2)&#123;                        //左上角坐标 [this.getX()   this.getY()]                        if(this.getX() &gt;= enemyTank.getX()                                &amp;&amp; this.getX() &lt;= enemyTank.getX() + 40                                &amp;&amp; this.getY() &gt;= enemyTank.getY()                                &amp;&amp; this.getY() &lt;= enemyTank.getY() + 60)&#123;                            return true;                        &#125;                        //右上角坐标 [this.getX() + 40   this.getY()]                        if(this.getX() + 40 &gt;= enemyTank.getX()                                &amp;&amp; this.getX() + 40 &lt;= enemyTank.getX() + 40                                &amp;&amp; this.getY() &gt;= enemyTank.getY()                                &amp;&amp; this.getY() &lt;= enemyTank.getY() + 60)&#123;                            return true;                        &#125;                    &#125;                    //如果敌人坦克是左/右                    //敌方坦克的取值范围x[enemyTank.getX()   enemyTank.getX() + 50]                    //               y[enemyTank.getY()   enemyTank.getY() + 50]                    if(enemyTank.getDirection() == 1 || enemyTank.getDirection() == 3)&#123;                        //左上角坐标 [this.getX()   this.getY()]                        if(this.getX() &gt;= enemyTank.getX()                                &amp;&amp; this.getX() &lt;= enemyTank.getX() + 50                                &amp;&amp; this.getY() &gt;= enemyTank.getY()                                &amp;&amp; this.getY() &lt;= enemyTank.getY() + 50)&#123;                            return true;                        &#125;                        //右上角坐标 [this.getX() + 40   this.getY()]                        if(this.getX() + 40 &gt;= enemyTank.getX()                                &amp;&amp; this.getX() + 40 &lt;= enemyTank.getX() + 50                                &amp;&amp; this.getY() &gt;= enemyTank.getY()                                &amp;&amp; this.getY() &lt;= enemyTank.getY() + 50)&#123;                            return true;                        &#125;                    &#125;                &#125;            &#125;            break;        case 1://右            //让当前坦克和所有坦克比较（循环）            for (int i = 0; i &lt; enemyTanks.size(); i++) &#123;                //取出一个                EnemyTank enemyTank = enemyTanks.get(i);                //不能和自己比较                if(this != enemyTank)&#123;                    //如果敌人坦克是上/下                    //敌方坦克的取值范围x[enemyTank.getX()   enemyTank.getX() + 40]                    //               y[enemyTank.getY()   enemyTank.getY() + 60]                    if(enemyTank.getDirection() == 0 || enemyTank.getDirection() == 2)&#123;                        //右上角坐标 [this.getX() + 50   this.getY()]                        if(this.getX() + 50 &gt;= enemyTank.getX()                                &amp;&amp; this.getX() + 50 &lt;= enemyTank.getX() + 40                                &amp;&amp; this.getY() &gt;= enemyTank.getY()                                &amp;&amp; this.getY() &lt;= enemyTank.getY() + 60)&#123;                            return true;                        &#125;                        //右下角坐标 [this.getX() + 50   this.getY() + 50]                        if(this.getX() + 50 &gt;= enemyTank.getX()                                &amp;&amp; this.getX() + 50 &lt;= enemyTank.getX() + 40                                &amp;&amp; this.getY() + 50 &gt;= enemyTank.getY()                                &amp;&amp; this.getY() + 50 &lt;= enemyTank.getY() + 60)&#123;                            return true;                        &#125;                    &#125;                    //如果敌人坦克是左/右                    //敌方坦克的取值范围x[enemyTank.getX()   enemyTank.getX() + 50]                    //               y[enemyTank.getY()   enemyTank.getY() + 50]                    if(enemyTank.getDirection() == 1 || enemyTank.getDirection() == 3)&#123;                        //右上角坐标 [this.getX() + 50   this.getY()]                        if(this.getX() + 50 &gt;= enemyTank.getX()                                &amp;&amp; this.getX() + 50 &lt;= enemyTank.getX() + 50                                &amp;&amp; this.getY() &gt;= enemyTank.getY()                                &amp;&amp; this.getY() &lt;= enemyTank.getY() + 50)&#123;                            return true;                        &#125;                        //右下角坐标 [this.getX() + 50   this.getY() + 50]                        if(this.getX() + 50 &gt;= enemyTank.getX()                                &amp;&amp; this.getX() + 50 &lt;= enemyTank.getX() + 50                                &amp;&amp; this.getY() + 50 &gt;= enemyTank.getY()                                &amp;&amp; this.getY() + 50 &lt;= enemyTank.getY() + 50)&#123;                            return true;                        &#125;                    &#125;                &#125;            &#125;            break;        case 2://下            //让当前坦克和所有坦克比较（循环）            for (int i = 0; i &lt; enemyTanks.size(); i++) &#123;                //取出一个                EnemyTank enemyTank = enemyTanks.get(i);                //不能和自己比较                if(this != enemyTank)&#123;                    //如果敌人坦克是上/下                    //敌方坦克的取值范围x[enemyTank.getX()   enemyTank.getX() + 40]                    //               y[enemyTank.getY()   enemyTank.getY() + 60]                    if(enemyTank.getDirection() == 0 || enemyTank.getDirection() == 2)&#123;                        //左下角坐标 [this.getX()   this.getY() + 60]                        if(this.getX() &gt;= enemyTank.getX()                                &amp;&amp; this.getX() &lt;= enemyTank.getX() + 40                                &amp;&amp; this.getY() + 60 &gt;= enemyTank.getY()                                &amp;&amp; this.getY() + 60 &lt;= enemyTank.getY() + 60)&#123;                            return true;                        &#125;                        //右下角坐标 [this.getX() + 40   this.getY() + 60]                        if(this.getX() + 40 &gt;= enemyTank.getX()                                &amp;&amp; this.getX() + 40 &lt;= enemyTank.getX() + 40                                &amp;&amp; this.getY() + 60&gt;= enemyTank.getY()                                &amp;&amp; this.getY() + 60&lt;= enemyTank.getY() + 60)&#123;                            return true;                        &#125;                    &#125;                    //如果敌人坦克是左/右                    //敌方坦克的取值范围x[enemyTank.getX()   enemyTank.getX() + 50]                    //               y[enemyTank.getY()   enemyTank.getY() + 50]                    if(enemyTank.getDirection() == 1 || enemyTank.getDirection() == 3)&#123;                        //左下角坐标 [this.getX()   this.getY() + 50]                        if(this.getX() &gt;= enemyTank.getX()                                &amp;&amp; this.getX() &lt;= enemyTank.getX() + 50                                &amp;&amp; this.getY() + 50 &gt;= enemyTank.getY()                                &amp;&amp; this.getY() + 50 &lt;= enemyTank.getY() + 50)&#123;                            return true;                        &#125;                        //右下角坐标 [this.getX() + 50   this.getY() + 50]                        if(this.getX() + 50 &gt;= enemyTank.getX()                                &amp;&amp; this.getX() + 50 &lt;= enemyTank.getX() + 50                                &amp;&amp; this.getY() + 50 &gt;= enemyTank.getY()                                &amp;&amp; this.getY() + 50 &lt;= enemyTank.getY() + 50)&#123;                            return true;                        &#125;                    &#125;                &#125;            &#125;            break;        case 3://左            //让当前坦克和所有坦克比较（循环）            for (int i = 0; i &lt; enemyTanks.size(); i++) &#123;                //取出一个                EnemyTank enemyTank = enemyTanks.get(i);                //不能和自己比较                if(this != enemyTank)&#123;                    //如果敌人坦克是上/下                    //敌方坦克的取值范围x[enemyTank.getX()   enemyTank.getX() + 40]                    //               y[enemyTank.getY()   enemyTank.getY() + 60]                    if(enemyTank.getDirection() == 0 || enemyTank.getDirection() == 2)&#123;                        //左上角坐标 [this.getX()   this.getY()]                        if(this.getX() &gt;= enemyTank.getX()                                &amp;&amp; this.getX() &lt;= enemyTank.getX() + 40                                &amp;&amp; this.getY() &gt;= enemyTank.getY()                                &amp;&amp; this.getY() &lt;= enemyTank.getY() + 60)&#123;                            return true;                        &#125;                        //左下角坐标 [this.getX()   this.getY() + 40]                        if(this.getX() &gt;= enemyTank.getX()                                &amp;&amp; this.getX() &lt;= enemyTank.getX() + 40                                &amp;&amp; this.getY() + 40 &gt;= enemyTank.getY()                                &amp;&amp; this.getY() + 40 &lt;= enemyTank.getY() + 60)&#123;                            return true;                        &#125;                    &#125;                    //如果敌人坦克是左/右                    //敌方坦克的取值范围x[enemyTank.getX()   enemyTank.getX() + 50]                    //               y[enemyTank.getY()   enemyTank.getY() + 50]                    if(enemyTank.getDirection() == 1 || enemyTank.getDirection() == 3)&#123;                        //左上角坐标 [this.getX()   this.getY()]                        if(this.getX() &gt;= enemyTank.getX()                                &amp;&amp; this.getX() &lt;= enemyTank.getX() + 50                                &amp;&amp; this.getY() &gt;= enemyTank.getY()                                &amp;&amp; this.getY() &lt;= enemyTank.getY() + 50)&#123;                            return true;                        &#125;                        //左下角坐标 [this.getX()   this.getY() + 50]                        if(this.getX() &gt;= enemyTank.getX()                                &amp;&amp; this.getX() &lt;= enemyTank.getX() + 50                                &amp;&amp; this.getY() + 50 &gt;= enemyTank.getY()                                &amp;&amp; this.getY() + 50 &lt;= enemyTank.getY() + 50)&#123;                            return true;                        &#125;                    &#125;                &#125;            &#125;            break;    &#125;    return false;&#125;@Overridepublic void run() &#123;    while(true)&#123;        //如果shots.size为零，则证明没有子弹了        //坦克不存在就不能发射        if(isLive &amp;&amp; shots.size() &lt; 1)&#123;            Shot shot = null;            switch (getDirection())&#123;                case 0://车身向上                    shot = new Shot(getX() + 18, getY() - 5, 0);                    break;                case 1://车身向右                    shot = new Shot(getX() + 55, getY() + 28, 1);                    break;                case 2://车身向下                    shot = new Shot(getX() + 18, getY() + 65, 2);                    break;                case 3://车身向左                    shot = new Shot(getX() - 15, getY() + 28, 3);                    break;            &#125;            //加子弹            shots.add(shot);            //启动线程            new Thread(shot).start();        &#125;        //让坦克根据方向移动        switch (getDirection())&#123;            case 0://向上                //走三十步                for (int i = 0; i &lt; 30; i++) &#123;                    //加一个控制条件，不扔让他跑出活动范围,下面同理                    if(getY() &gt; 0 &amp;&amp; !isCollision()) &#123;                        //父类的移动方法                        moveUp();                    &#125;                    //休眠50毫秒，不然会闪现的                    sleep50();                &#125;                break;            case 1://向右                //走三十步                for (int i = 0; i &lt; 30; i++) &#123;                    if (getX() + 70 &lt; 1000 &amp;&amp; !isCollision()) &#123;                        //父类的移动方法                        moveRight();                    &#125;                        //休眠50毫秒，不然会闪现的                    sleep50();                &#125;                break;            case 2://向下                //走三十步                for (int i = 0; i &lt; 30; i++) &#123;                    if(getY() + 110 &lt; 750 &amp;&amp; !isCollision()) &#123;                        //父类的移动方法                        moveDown();                    &#125;                        //休眠50毫秒，不然会闪现的                        sleep50();                &#125;                break;            case 3://向左                //走三十步                for (int i = 0; i &lt; 30; i++) &#123;                    if(getX() &gt; 10 &amp;&amp; !isCollision()) &#123;                        //父类的移动方法                        moveLeft();                    &#125;                    //休眠50毫秒，不然会闪现的                    sleep50();                &#125;                break;        &#125;        //随机改变坦克的方向        setDirection((int)(Math.random()*4));        //老师对我的提醒：写一个并发程序，一定要考虑线程何时结束        if (!(isLive))&#123;            break;        &#125;    &#125;&#125;public void sleep50()&#123;    try &#123;        Thread.sleep(50);    &#125; catch (InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>}</p><p>public class Shot implements Runnable {</p><pre><code>int x;//子弹的横坐标int y;//子弹的纵坐标int direction;//子弹的方向(0,1,2,3)int shotSpeed = 10;//子弹于行的速度boolean isLive = true;//线程的状态public Shot(int x, int y, int direction) &#123;    this.x = x;    this.y = y;    this.direction = direction;&#125;@Overridepublic void run() &#123;    while (true)&#123;        //子弹方向        switch (direction)&#123;            case 0://向上                y -= shotSpeed;                break;            case 1://向右                x += shotSpeed;                break;            case 2://向下                y += shotSpeed;                break;            case 3://向左                x -= shotSpeed;        &#125;        //休眠五十毫秒        try &#123;            Thread.sleep(50);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        //撞到边界结束进程（销毁子弹）        //碰到敌人坦克也应当销毁        if(!(y &gt;= 0 &amp;&amp; y &lt;= 750 &amp;&amp; x &gt;= 0 &amp;&amp; x &lt;= 1000 &amp;&amp; isLive)) &#123;            isLive = false;            break;        &#125;        //System.out.println(x + &quot; &quot; + y);    &#125;&#125;</code></pre><p>}</p><p>public class Node {</p><pre><code>private int x;private int y;private int direction;public Node(int x, int y, int direction) &#123;    this.x = x;    this.y = y;    this.direction = direction;&#125;public int getX() &#123;    return x;&#125;public void setX(int x) &#123;    this.x = x;&#125;public int getY() &#123;    return y;&#125;public void setY(int y) &#123;    this.y = y;&#125;public int getDirection() &#123;    return direction;&#125;public void setDirection(int direction) &#123;    this.direction = direction;&#125;</code></pre><p>}</p><p>public class Bomb {</p><pre><code>int x,y;//爆炸的坐标boolean isLive = true;//爆炸是否存活int life = 9;//炸弹的生命值（用于判断什么时候，用何种惨烈的图片）public Bomb(int x, int y) &#123;    this.x = x;    this.y = y;&#125;//写个方法，减少炸弹的生命值public void lifeDown()&#123;//配合出现爆炸效果    if(life &gt; 0)&#123;        life--;    &#125;else&#123;        isLive = false;    &#125;&#125;</code></pre><p>}</p><p>public class MyPanel extends JPanel implements KeyListener, Runnable {</p><pre><code>//获得爆炸图片Image image1 = null;Image image2 = null;Image image3 = null;MyTank mt = null;//爆炸，初始化一个集合//说明：当子弹接触到坦克时，则加入一个bomb对象到bombs中去Vector&lt;Bomb&gt; bombs = new Vector&lt;&gt;();//敌人的坦克，未来有很多，所以用集合，多线程，所以用VectorVector&lt;EnemyTank&gt; enemyTanks = new Vector&lt;&gt;();//定义一个存放node的Vector，用于回复敌人坦克的位置和方向Vector&lt;Node&gt; nodes = new Vector&lt;&gt;();int enemyTanksSize = 6;//敌人的个数（3）public MyPanel(String key) &#123;    //判断文件是否存在    //如果存在正常执行，如果不存在，提示，且key = 1    File file = new File(Recorder.getRecordFile());    if(file.exists()) &#123;        nodes = Recorder.getNodesAndEnemyTankRec();    &#125;else&#123;        System.out.println(&quot;文件不存在，只能开启新的游戏&quot;);        key = &quot;1&quot;;    &#125;    //将MyPanel类的enemyTanks 传给Recorder的enemyTanks    Recorder.setEnemyTanks(enemyTanks);    mt = new MyTank(500, 630);//初始化自己的坦克    switch(key)&#123;        case &quot;1&quot;:            //敌人坦克            for(int i = 0;i &lt; enemyTanksSize; i++)&#123;                //初始化敌人的坦克                EnemyTank enemyTank = new EnemyTank(150 * (i + 1), 0);                //enemyTanks集合放入敌人坦克类的集合中                enemyTank.setEnemyTanks(enemyTanks);                //敌人的方向                enemyTank.setDirection(2);                //开始敌人坦克的线程，让他能动                new Thread(enemyTank).start();                //给enemyTank加一子弹                Shot shot = new Shot(enemyTank.getX() + 18,enemyTank.getY() + 65,enemyTank.getDirection());                //加入到enemyTank的shots中去                enemyTank.shots.add(shot);                //启动shot线程                new Thread(shot).start();                enemyTanks.add(enemyTank);            &#125;            break;        case &quot;2&quot;://继续上局游戏            //敌人坦克            for(int i = 0;i &lt; nodes.size(); i++)&#123;                Node node = nodes.get(i);                //初始化敌人的坦克                EnemyTank enemyTank = new EnemyTank(node.getX(), node.getY());                //enemyTanks集合放入敌人坦克类的集合中                enemyTank.setEnemyTanks(enemyTanks);                //敌人的方向                enemyTank.setDirection(node.getDirection());                //开始敌人坦克的线程，让他能动                new Thread(enemyTank).start();                //给enemyTank加一子弹                Shot shot = new Shot(enemyTank.getX() + 18,enemyTank.getY() + 65,enemyTank.getDirection());                //加入到enemyTank的shots中去                enemyTank.shots.add(shot);                //启动shot线程                new Thread(shot).start();                enemyTanks.add(enemyTank);            &#125;            break;        default:            System.out.println(&quot;你的输入有误&quot;);            break;    &#125;    image1 = Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(&quot;/bomb_1.gif&quot;));    image2 = Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(&quot;/bomb_2.gif&quot;));    image3 = Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(&quot;/bomb_3.gif&quot;));    new AePlayWave(&quot;src\\111.wav&quot;).start();&#125;public void showInfo(Graphics g)&#123;    //更改画笔颜色    g.setColor(Color.BLACK);    Font font = new Font(&quot;宋体&quot;, Font.BOLD, 25);    //更改字体    g.setFont(font);    g.drawString(&quot;您累计击毁敌方坦克：&quot;,1020,30);    drawTank(1020,60,g,0,1);    g.setColor(Color.BLACK);    g.drawString(Recorder.allEnemyTankNum + &quot;&quot;,1080,100);&#125;@Overridepublic void paint(Graphics g) &#123;    super.paint(g);    //背景    g.fillRect(0, 0, 1000, 750);    showInfo(g);    //判断我方坦克是否存活    if(mt != null &amp;&amp; mt.isLive ) &#123;        //画坦克--封装        this.drawTank(mt.getX(), mt.getY(), g, mt.getDirection(), 0);    &#125;    //画我的子弹--封装(老师写的没封装，可能这块太简单吧=。=)    //发射多颗子弹    for(int i = 0; i &lt; mt.shots.size(); i++)&#123;        Shot shot = mt.shots.get(i);        if (shot != null &amp;&amp; shot.isLive)&#123;            this.drawShot(shot.x,shot.y,g);        &#125;else&#123;            mt.shots.remove(shot);        &#125;    &#125;    //画敌人的坦克    for(int i = 0; i &lt; enemyTanks.size();i++)&#123;        EnemyTank enemyTank = enemyTanks.get(i);        if(enemyTank.isLive ) &#123;//判断当前坦克是否还存活            this.drawTank(enemyTank.getX(), enemyTank.getY(), g, enemyTank.getDirection(), 1);            //画敌人的子弹（我也不封装了，麻烦=。=）            //遍历shots集合，画子弹；            for (int j = 0; j &lt; enemyTank.shots.size(); j++) &#123;                //得到集合中的shot                Shot shot = enemyTank.shots.get(j);                //画敌人子弹                if (shot.isLive) &#123;                    g.fill3DRect(shot.x, shot.y, 4, 4, false);                &#125; else &#123;                    enemyTank.shots.remove(shot);                &#125;            &#125;        &#125;    &#125;    //画爆炸（如果集合中有，就画出来）    for (int i = 0;i &lt; bombs.size(); i++)&#123;        //取出炸弹        Bomb bomb = bombs.get(i);        //根据life，画出不同的爆炸效果        if(bomb.life &gt; 6) &#123;            g.drawImage(image1, bomb.x, bomb.y, 60, 60, this);        &#125;else if(bomb.life &gt; 3)&#123;            g.drawImage(image2, bomb.x, bomb.y, 60, 60, this);        &#125;else if(bomb.life &gt; 0)&#123;            g.drawImage(image3, bomb.x, bomb.y, 60, 60, this);        &#125;        //让炸弹的生命值减少        bomb.lifeDown();        //如果爆炸不存在，就删除这个对象        if(bomb.life == 0)&#123;            bombs.remove(bomb);        &#125;    &#125;&#125;/** * @param x         坦克的横坐标 * @param y         坦克的纵坐标 * @param g         画笔 * @param direction 坦克的方向 * @param type      坦克的类型 */public void drawTank(int x, int y, Graphics g, int direction, int type) &#123;    //类型不同    switch (type) &#123;        case 0://我们的坦克（粉红战神）            g.setColor(Color.pink);            break;        case 1://敌人的坦克（绿油油怪）            g.setColor(Color.GREEN);            break;    &#125;    //方向不同    switch (direction) &#123;        case 0://向上            g.fill3DRect(x, y, 10, 60, false);//左边轮子            g.fill3DRect(x + 30, y, 10, 60, false);//右边轮子            g.fill3DRect(x + 10, y + 15, 20, 30, false);//车身            g.fillOval(x + 10, y + 20, 20, 20);//车盖            g.fill3DRect(x + 19, y - 5, 2, 35, false);//炮筒            break;        case 1://向右            //我把坦克调成中心旋转的，老师的不是（强迫症），下同理            x = x - 10;            y = y + 10;            g.fill3DRect(x, y, 60, 10, false);//左边轮子            g.fill3DRect(x, y + 30, 60, 10, false);//右边轮子            g.fill3DRect(x + 15, y + 10, 30, 20, false);//车身            g.fillOval(x + 20, y + 10, 20, 20);//车盖            g.fill3DRect(x + 30, y + 19, 35, 2, false);//炮筒            break;        case 2://向下            g.fill3DRect(x, y, 10, 60, false);//左边轮子            g.fill3DRect(x + 30, y, 10, 60, false);//右边轮子            g.fill3DRect(x + 10, y + 15, 20, 30, false);//车身            g.fillOval(x + 10, y + 20, 20, 20);//车盖            g.fill3DRect(x + 19, y + 30, 2, 35, false);//炮筒            break;        case 3://向左            x = x - 10;            y = y + 10;            g.fill3DRect(x, y, 60, 10, false);//左边轮子            g.fill3DRect(x, y + 30, 60, 10, false);//右边轮子            g.fill3DRect(x + 15, y + 10, 30, 20, false);//车身            g.fillOval(x + 20, y + 10, 20, 20);//车盖            g.fill3DRect(x - 5, y + 19, 35, 2, false);//炮筒            break;    &#125;&#125;public void drawShot(int x,int y,Graphics g)&#123;    g.setColor(Color.white);    g.fill3DRect(x,y,4,4,false);&#125;//从敌方坦克的集合中取出子弹（此处处理和老师的不一样）public void hitMyTank(MyTank mt)&#123;    //先取出敌方坦克    for (int i = 0; i &lt; enemyTanks.size(); i++)&#123;        EnemyTank enemyTank = enemyTanks.get(i);        //再取出敌方坦克中的shots集合中的shot对象        for(int j = 0; j &lt; enemyTank.shots.size(); j++)&#123;            Shot shot = enemyTank.shots.get(j);            //只有在我方坦克存活且敌方子弹存活才进行判断            if(mt.isLive &amp;&amp; shot.isLive) &#123;                hitTank(shot, mt);            &#125;        &#125;    &#125;&#125;//我再建一个方法//从我的坦克子弹集合取出子弹（此处处理和老师的不一样）public void hitEnemyTank(EnemyTank enemyTank)&#123;    for (int i = 0; i &lt; mt.shots.size(); i++)&#123;        Shot shot = mt.shots.get(i);        hitTank(shot,enemyTank);    &#125;&#125;//编写一个方法，判断我方子弹是否击中敌方坦克//这个方法在MyPanel线程run中判断最合理public void hitTank(Shot shot,Tank tank)&#123;    switch (tank.getDirection())&#123;        case 0:        case 2:            if(shot.x &gt; tank.getX() &amp;&amp; shot.x &lt; tank.getX() + 40            &amp;&amp; shot.y &gt;tank.getY() &amp;&amp; shot.y &lt; tank.getY() + 60)&#123;                shot.isLive = false;                tank.isLive = false;                //创建bomb对象，加入到bombs集合中                Bomb bomb = new Bomb(tank.getX(), tank.getY());                bombs.add(bomb);                //被击中了，要在集合中去掉这个坦克。                enemyTanks.remove(tank);                //坦克被击中了，就让allEnemyTankNum++                //因为，这里有自己坦克被击毁也会++                //所以，加一个判断                if(tank instanceof EnemyTank)&#123;                    Recorder.addAllEnemyTankNum();                &#125;            &#125;            break;        case 1:        case 3:            if(shot.x &gt; tank.getX()-10 &amp;&amp; shot.x &lt; tank.getX() + 50            &amp;&amp; shot.y &gt; tank.getY() + 10 &amp;&amp; shot.y &lt; tank.getY() + 50)&#123;                shot.isLive = false;                tank.isLive = false;                //创建bomb对象，加入到bombs集合中                Bomb bomb = new Bomb(tank.getX(), tank.getY());                bombs.add(bomb);                //被击中了，要在集合中去掉这个坦克。                enemyTanks.remove(tank);                //坦克被击中了，就让allEnemyTankNum++                //因为，这里有自己坦克被击毁也会++                //所以，加一个判断                if(tank instanceof EnemyTank)&#123;                    Recorder.addAllEnemyTankNum();                &#125;            &#125;    &#125;&#125;@Overridepublic void keyTyped(KeyEvent e) &#123;&#125;@Overridepublic void keyPressed(KeyEvent e) &#123;    if (e.getKeyCode() == KeyEvent.VK_W) &#123;//按下w        mt.setDirection(0);        //限制条件，不让自己的坦克跑出范围，下同理        if(mt.getY() &gt; 0)&#123;            mt.moveUp();        &#125;    &#125; else if (e.getKeyCode() == KeyEvent.VK_D) &#123;//按下d        mt.setDirection(1);        if(mt.getX() + 70 &lt; 1000) &#123;            mt.moveRight();        &#125;    &#125; else if (e.getKeyCode() == KeyEvent.VK_S) &#123;//按下s        mt.setDirection(2);        if(mt.getY() + 110 &lt; 750) &#123;            mt.moveDown();        &#125;    &#125; else if (e.getKeyCode() == KeyEvent.VK_A) &#123;//按下a        mt.setDirection(3);        if (mt.getX() &gt; 10) &#123;            mt.moveLeft();        &#125;    &#125;    //如果按下J键，    if(e.getKeyCode() == KeyEvent.VK_J)&#123;</code></pre><p>//            //一颗子弹销毁后，才可以发射下一颗子弹，（加一个条件）<br>//            if(mt.shot == null || !(mt.shot.isLive)) {<br>//                //调用我方发射子弹的方法<br>//                mt.shotEnemyTank();<br>//<br>//            }<br>            mt.shotEnemyTank();</p><pre><code>    &#125;    this.repaint();&#125;@Overridepublic void keyReleased(KeyEvent e) &#123;&#125;@Overridepublic void run() &#123;    while (true)&#123;        //调用方法，判断是否有敌方坦克被击中        if(mt.shot !=null &amp;&amp; mt.shot.isLive)&#123;//如果自己的子弹还存活就判断            for (int i = 0; i &lt; enemyTanks.size();i++)&#123;                EnemyTank enemyTank = enemyTanks.get(i);//取出一个敌方坦克                hitEnemyTank(enemyTank);            &#125;        &#125;        //调用方法，判断是否有己方坦克被击中        hitMyTank(mt);        //让这个面板没过100毫秒刷新一次        try &#123;            Thread.sleep(100);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        this.repaint();    &#125;&#125;</code></pre><p>}</p><p>public class Recorder {</p><pre><code>//定义变量，纪录被销毁敌人坦克的数量public static int allEnemyTankNum = 0;//定义io流对象，准备写入信息到文件public static BufferedWriter bw = null;public static BufferedReader br = null;public static String recordFile = &quot;src\\myRecord.txt&quot;;//写一个属性，用于接收敌人坦克public static Vector&lt;EnemyTank&gt; enemyTanks = null;//定义一个Node的Vector，用于保存敌人的nodeprivate static Vector&lt;Node&gt; nodes = new Vector&lt;&gt;();public static void setEnemyTanks(Vector&lt;EnemyTank&gt; enemyTanks) &#123;    Recorder.enemyTanks = enemyTanks;&#125;//返回记录游戏的目录public static String getRecordFile()&#123;    return recordFile;&#125;//写一个方法，由于读取recordFile文件//该方法在继续上局游戏的时候启动public static Vector&lt;Node&gt; getNodesAndEnemyTankRec()&#123;    try &#123;        br = new BufferedReader(new FileReader(recordFile));        //读取一下上轮击毁坦克的数量        allEnemyTankNum = Integer.parseInt(br.readLine());        //循环读取，创建nodes集合        String readLin = &quot;&quot; ;        while ((readLin = br.readLine()) != null)&#123;            String[] xyd = readLin.split(&quot; &quot;);            Node node = new Node(Integer.parseInt(xyd[0]), Integer.parseInt(xyd[1]), Integer.parseInt(xyd[2]));            nodes.add(node);        &#125;    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125; finally &#123;        try &#123;            if(br != null)&#123;                br.close();            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    return nodes;&#125;//写一个方法，在退出时保存public static void keepRecorder()&#123;    try &#123;        bw = new BufferedWriter(new FileWriter(recordFile));        bw.write(allEnemyTankNum + &quot;\r\n&quot;);        //遍历敌人坦克的Vector,然后根据情况保存就行        //OOP,定义一个属性，通过set方法,得到敌人坦克的集合        for (int i = 0; i &lt; enemyTanks.size(); i++) &#123;            //取出坦克            EnemyTank enemyTank = enemyTanks.get(i);            if(enemyTank.isLive)&#123;//建议判断（理论可以不用）                //需要保存到                String record = enemyTank.getX() + &quot; &quot; + enemyTank.getY() + &quot; &quot; + enemyTank.getDirection();                //保存                bw.write(record + &quot;\r\n&quot;);            &#125;        &#125;    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125; finally &#123;        if(bw != null)&#123;            try &#123;                bw.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;public static int getAllEnemyTankNum() &#123;    return allEnemyTankNum;&#125;public static void setAllEnemyTankNum(int allEnemyTankNum) &#123;    Recorder.allEnemyTankNum = allEnemyTankNum;&#125;//当我们击毁一个坦克的时候，allEnemyTankNum++public static void addAllEnemyTankNum()&#123;    Recorder.allEnemyTankNum++;&#125;</code></pre><p>}</p><h2 id="多用户通讯系统（简化界面版）"><a href="#多用户通讯系统（简化界面版）" class="headerlink" title="多用户通讯系统（简化界面版）"></a>多用户通讯系统（简化界面版）</h2><h3 id="common"><a href="#common" class="headerlink" title="common"></a>common</h3><p>package com.ljq.qqcommon;</p><p>import java.io.Serializable;</p><p>/**</p><ul><li>@author 刘嘉祺~</li><li>@version 1.0</li><li>表示客户端和服务端通信时候的消息对象</li><li>/</li></ul><p>public class Message implements Serializable {</p><pre><code>private static final long serialVersionUID = 1L;//保障序列化兼容性private String sender;//消息发送者private String getter;//消息接收者private String content;//消息发送内容private String sendTime;//发送时间private String mesType;//消息类型//扩展，文件相关private byte[] fileBytes;//文件字节数组private int fileLen = 0;private String src;//来源private String dest;//去哪public byte[] getFileBytes() &#123;    return fileBytes;&#125;public void setFileBytes(byte[] fileBytes) &#123;    this.fileBytes = fileBytes;&#125;public int getFileLen() &#123;    return fileLen;&#125;public void setFileLen(int fileLen) &#123;    this.fileLen = fileLen;&#125;public String getSrc() &#123;    return src;&#125;public void setSrc(String src) &#123;    this.src = src;&#125;public String getDest() &#123;    return dest;&#125;public void setDest(String dest) &#123;    this.dest = dest;&#125;public String getSender() &#123;    return sender;&#125;public void setSender(String sender) &#123;    this.sender = sender;&#125;public String getGetter() &#123;    return getter;&#125;public void setGetter(String getter) &#123;    this.getter = getter;&#125;public String getContent() &#123;    return content;&#125;public void setContent(String content) &#123;    this.content = content;&#125;public String getSendTime() &#123;    return sendTime;&#125;public void setSendTime(String sendTime) &#123;    this.sendTime = sendTime;&#125;public String getMesType() &#123;    return mesType;&#125;public void setMesType(String mesType) &#123;    this.mesType = mesType;&#125;</code></pre><p>}</p><p>public interface MessageType {</p><pre><code>//定义一些常量//常量的值不同，代表的消息类型不同String MESSAGE_LOGIN_SUCCEED = &quot;1&quot;;//表示登陆成功String MESSAGE_LOGIN_FAIL = &quot;2&quot;;//表示登陆失败String MESSAGE_COMM_MES = &quot;3&quot;;//表示普通信息String MESSAGE_GET_ONLINE_FRIEND = &quot;4&quot;;//要求返回用户在线列表String MESSAGE_RET_ONLINE_FRIEND = &quot;5&quot;;//返回用户在线列表String MESSAGE_CLIENT_EXIT = &quot;6&quot;;//客户端请求退出String MESSAGE_TO_ALL_MES = &quot;7&quot;;//群发消息String MESSAGE_FILE_MES = &quot;8&quot;;//文件消息</code></pre><p>}</p><p>public class User implements Serializable {</p><pre><code>private static final long serialVersionUID = 1L;//保障序列化兼容性private String userId;//用户名private String passwd;//用户密码public User() &#123;&#125;public User(String userId, String passwd) &#123;    this.userId = userId;    this.passwd = passwd;&#125;public String getUserId() &#123;    return userId;&#125;public void setUserId(String userId) &#123;    this.userId = userId;&#125;public String getPasswd() &#123;    return passwd;&#125;public void setPasswd(String passwd) &#123;    this.passwd = passwd;&#125;</code></pre><p>}</p><h3 id="qqclient"><a href="#qqclient" class="headerlink" title="qqclient"></a>qqclient</h3><h4 id="view"><a href="#view" class="headerlink" title="view"></a>view</h4><p>package com.ljq.qqclient.view;</p><p>import com.ljq.qqclient.service.FileClientService;<br>import com.ljq.qqclient.service.MessageClientService;<br>import com.ljq.qqclient.service.UserClientService;<br>import com.ljq.qqclient.utils.Utility;</p><p>import java.io.FileInputStream;</p><p>/**</p><ul><li>@author 刘嘉祺~</li><li>@version 1.0</li><li>该类为菜单</li><li>/</li></ul><p>public class QQView {</p><pre><code>private boolean loop = true;//控制菜单退出private String key = &quot;&quot;;//接收用户输入private UserClientService userClientService = new UserClientService();//用户的登录注册服务private MessageClientService messageClientService = new MessageClientService();//用户的私聊群聊等等private FileClientService fileClientService = new FileClientService();//用于文件传输public static void main(String[] args) &#123;    new QQView().mainMenu();    System.out.println(&quot;客户端退出&quot;);&#125;//菜单方法private void mainMenu()&#123;    while(loop)&#123;        System.out.println(&quot;===========欢迎登陆网络通信系统============&quot;);        System.out.println(&quot;\t\t1、登陆系统&quot;);        System.out.println(&quot;\t\t9、退出系统&quot;);        System.out.print(&quot;请输入你的选择： &quot;);        key = Utility.readString(1);        switch(key)&#123;            case &quot;1&quot;:                System.out.print(&quot;请输入用户号： &quot;);                String userid = Utility.readString(50);                System.out.print(&quot;请输入密  码： &quot;);                String passwd = Utility.readString(50);                //这里有好多代码，需要验证用户是否合法                //我们编写一个类UserClientService，用于服务【登录和注册】                if(userClientService.check(userid,passwd))&#123;//还没有写完 。。。先把逻辑打通                    System.out.println(&quot;=====欢迎用户&quot; + userid + &quot;登录成功=====&quot;);                    //进入二级菜单                    while(loop) &#123;                        System.out.println(&quot;\n===============网络通信系统二级菜单（用户：&quot; + userid + &quot;）===============&quot;);                        System.out.println(&quot;\t\t\t1、显示在线用户列表&quot;);                        System.out.println(&quot;\t\t\t2、群发消息&quot;);                        System.out.println(&quot;\t\t\t3、私聊消息&quot;);                        System.out.println(&quot;\t\t\t4、发送文件&quot;);                        System.out.println(&quot;\t\t\t9、退出系统&quot;);                        System.out.print(&quot;请输入你的选择： &quot;);                        key = Utility.readString(1);                        switch (key)&#123;                            case &quot;1&quot;:                                //写一个方法，获得用户来列表，写在UserClientService中                                userClientService.getOnlineFriendList();                                //System.out.println(&quot;显示在线用户列表&quot;);                                break;                            case &quot;2&quot;:                                System.out.println(&quot;输入群发内容：&quot;);                                String s = Utility.readString(100);                                //写一个方法，创建一个群发的message消息，发送给服务端                                messageClientService.sendMessageToAll(userid,s);                                break;                            case &quot;3&quot;:                                System.out.print(&quot;请输入想要聊天的用户（在线）：&quot;);                                String getterId  = Utility.readString(50);                                System.out.print(&quot;请输入你要输入的话：&quot;);                                String content = Utility.readString(100);                                //编写一个方法，将消息发给服务端(再开一个类，写消息服务)                                messageClientService.sendMessageToOne(userid,getterId,content);                                break;                            case &quot;4&quot;:                                System.out.print(&quot;请输入你要发送给的用户（在线）：&quot;);                                String s1 = Utility.readString(50);                                System.out.print(&quot;请输入你要发送的文件目录（例如：d:\\\\xxx.txt）:&quot;);                                String s2 = Utility.readString(100);                                System.out.print(&quot;请输入你要发送到对方电脑文件目录（例如：d:\\\\xxx.txt）:&quot;);                                String s3 = Utility.readString(100);                                fileClientService.sendFileToOne(userid,s1,s2,s3);                                break;                            case &quot;9&quot;:                                //调用方法，给服务器发送一个退出系统的message                                userClientService.logout();                                loop = false;                                break;                        &#125;                    &#125;                &#125;else&#123;                    System.out.println(&quot;=========登陆失败=========&quot;);                &#125;                break;            case &quot;9&quot;:                loop = false;                break;        &#125;    &#125;&#125;</code></pre><p>}</p><h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><p>package com.ljq.qqclient.service;</p><p>import com.ljq.qqcommon.Message;<br>import com.ljq.qqcommon.MessageType;</p><p>import java.io.FileOutputStream;<br>import java.io.IOException;<br>import java.io.ObjectInputStream;<br>import java.net.Socket;</p><p>/**</p><ul><li>@author 刘嘉祺~</li><li>@version 1.0</li><li>线程服务类（与服务器保持联系）</li><li>/</li></ul><p>public class ClientConnectServerThread extends Thread {</p><pre><code>private Socket socket;//该线程需要持有socket//构造器，得到一个socketpublic ClientConnectServerThread(Socket socket) &#123;    this.socket = socket;&#125;@Overridepublic void run() &#123;    //因为Thread需要在后台和服务器通讯，所以用while循环    while (true) &#123;        System.out.println(&quot;客户端线程等待读取，从服务端发送的消息&quot;);        try &#123;            ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());            //如果服务器没有发送消息，线程就会阻塞在这里            Message ms = (Message) ois.readObject();            //判断ms的类型，并作出相应的业务处理            //判断读取到的是：服务器返回在线列表            if (ms.getMesType().equals(MessageType.MESSAGE_RET_ONLINE_FRIEND)) &#123;                //得到返回的列表数据                //规定，用空格分隔                String[] onlineFriend = ms.getContent().split(&quot; &quot;);                System.out.println(&quot;\n===========当前在线用户============&quot;);                for (int i = 0; i &lt; onlineFriend.length; i++) &#123;                    System.out.println(&quot;用户： &quot; + onlineFriend[i]);                &#125;            &#125; else if (ms.getMesType().equals(MessageType.MESSAGE_COMM_MES)) &#123;                //收到私聊消息输出                System.out.println(&quot;\n&quot; + ms.getSender() + &quot; 对 &quot; + ms.getGetter() + &quot; 说： &quot; + ms.getContent());            &#125; else if (ms.getMesType().equals(MessageType.MESSAGE_TO_ALL_MES)) &#123;                System.out.println(&quot;\n&quot; + ms.getSender() + &quot; 对大家说： &quot; + ms.getContent());            &#125; else if (ms.getMesType().equals(MessageType.MESSAGE_FILE_MES)) &#123;                System.out.println(&quot;\n&quot; + ms.getSender() + &quot;给&quot; + ms.getGetter() + &quot;发送文件：&quot;                        + ms.getSrc() + &quot;到我的电脑目录&quot; + ms.getDest());                FileOutputStream fileOutputStream = new FileOutputStream(ms.getDest());                fileOutputStream.write(ms.getFileBytes());                fileOutputStream.close();                System.out.println(&quot;保存文件成功~&quot;);            &#125; else &#123;                System.out.println(&quot;是其他类型暂时先不处理&quot;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;public Socket getSocket() &#123;    return socket;&#125;</code></pre><p>}</p><p>package com.ljq.qqclient.service;</p><p>import com.ljq.qqcommon.Message;<br>import com.ljq.qqcommon.MessageType;</p><p>import java.io.*;</p><p>/**</p><ul><li>@author 刘嘉祺~</li><li>@version 1.0</li><li>该类用于文件传输服务</li><li>/</li></ul><p>public class FileClientService {</p><pre><code>/** * * @param senderId 发送者 * @param getterId 接收者 * @param src 来源 * @param dest 去哪 *///发送文件的方法public void sendFileToOne(String senderId,String getterId,String src,String dest)&#123;    Message message = new Message();    message.setSender(senderId);    message.setGetter(getterId);    message.setMesType(MessageType.MESSAGE_FILE_MES);    message.setSrc(src);    message.setDest(dest);    //将文件读入到客户端    FileInputStream fileInputStream = null;    byte[] fileBytes = new byte[(int) new File(src).length()];    try &#123;        fileInputStream = new FileInputStream(src);        fileInputStream.read(fileBytes);//将文件读入到准备好的数组中        //将文件对应的字节数组设置到消息里        message.setFileBytes(fileBytes);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125; finally &#123;        if(fileInputStream != null)&#123;            try &#123;                fileInputStream.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    //提示信息    System.out.println(&quot;\n&quot; + senderId + &quot;给&quot; + getterId + &quot;发送文件：&quot; + src + &quot;到对方电脑目录&quot; + dest);    //将message发送给客户端    try &#123;        ObjectOutputStream oos =                new ObjectOutputStream(                        ManageClientConnectServerThread.getClientConnectServerThread(senderId)                                .getSocket().getOutputStream());        oos.writeObject(message);    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>}</p><p>package com.ljq.qqclient.service;</p><p>import java.util.HashMap;</p><p>/**</p><ul><li>@author 刘嘉祺~</li><li>@version 1.0</li><li>该类负责管理ClientConnectServerThread线程</li><li>/</li></ul><p>public class ManageClientConnectServerThread {</p><pre><code>//我们把多个线程放到一个hashmap中，key代表用户id，value代表线程private static HashMap&lt;String,ClientConnectServerThread&gt; hm = new HashMap&lt;&gt;();//将某个线程加入到集合public static void addClientConnectServerThread(String userid,ClientConnectServerThread clientConnectServerThread)&#123;    hm.put(userid,clientConnectServerThread);&#125;//通过userId得到这个线程public static ClientConnectServerThread getClientConnectServerThread(String userId)&#123;    return hm.get(userId);&#125;</code></pre><p>}</p><p>package com.ljq.qqclient.service;</p><p>import com.ljq.qqcommon.Message;<br>import com.ljq.qqcommon.MessageType;</p><p>import java.io.IOException;<br>import java.io.ObjectOutputStream;<br>import java.util.Date;</p><p>/**</p><ul><li>@author 刘嘉祺~</li><li>@version 1.0</li><li>该类提供和消息相关的方法</li><li>/</li></ul><p>public class MessageClientService {</p><pre><code>/** * * @param sendId 发送者 * @param content 内容 *///群聊方法实现public void sendMessageToAll(String sendId, String content)&#123;    //建立一个消息对象    Message message = new Message();    message.setMesType(MessageType.MESSAGE_TO_ALL_MES);    message.setSender(sendId);    message.setContent(content);    message.setSendTime(new Date().toString());//将发送时间设置到消息里    System.out.println( sendId + &quot; 对大家说 &quot; + content);    //发送给服务端    try &#123;        ObjectOutputStream oos = new ObjectOutputStream                (ManageClientConnectServerThread.getClientConnectServerThread(sendId).getSocket().getOutputStream());        oos.writeObject(message);    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125;/** * * @param sendId 发送者 * @param getterId 接收者 * @param content 内容 *///私聊的方法实现public void sendMessageToOne(String sendId,String getterId,String content)&#123;    //建立一个消息对象    Message message = new Message();    message.setMesType(MessageType.MESSAGE_COMM_MES);    message.setSender(sendId);    message.setGetter(getterId);    message.setContent(content);    message.setSendTime(new Date().toString());//将发送时间设置到消息里    System.out.println( sendId + &quot; 对 &quot; + getterId + &quot; 说 &quot; + content);    //发送给服务端    try &#123;        ObjectOutputStream oos = new ObjectOutputStream                (ManageClientConnectServerThread.getClientConnectServerThread(sendId).getSocket().getOutputStream());        oos.writeObject(message);    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>}</p><p>package com.ljq.qqclient.service;</p><p>import com.ljq.qqcommon.Message;<br>import com.ljq.qqcommon.MessageType;<br>import com.ljq.qqcommon.User;</p><p>import java.io.IOException;<br>import java.io.ObjectInputStream;<br>import java.io.ObjectOutputStream;<br>import java.net.InetAddress;<br>import java.net.Socket;</p><p>/**</p><ul><li>@author 刘嘉祺~</li><li>@version 1.0</li><li>该类用于完成用户登陆验证和用户注册等等功能</li><li>/</li></ul><p>public class UserClientService {</p><pre><code>private User u = new User();//可能在其他地方使用user信息private Socket socket;//根据userId和pwd到服务端去验证用户是否合法public boolean check(String userId,String pwd)&#123;    boolean b = false;    u.setUserId(userId);    u.setPasswd(pwd);    //连接服务器，发送u    try &#123;        Socket socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;), 9999);        //得到ObjectOutputStream对象，发送u对象        ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());        oos.writeObject(u);        //读取服务器回的Message对象        ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());        Message message = (Message) ois.readObject();        if(message.getMesType().equals(MessageType.MESSAGE_LOGIN_SUCCEED))&#123;//登录ok            //创建一个和服务器保持联系的线程-》创建一个线程类ClientConnectServerThread            ClientConnectServerThread clientConnectServerThread = new ClientConnectServerThread(socket);            //启动线程            clientConnectServerThread.start();            //为了后面客户端的扩展，我们将线程放到一个集合中管理（ManageClientConnectServerThread）            ManageClientConnectServerThread.addClientConnectServerThread(userId,clientConnectServerThread);            b = true;        &#125;else&#123;            //没有登陆成功            socket.close();        &#125;    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;    return b;&#125;public void getOnlineFriendList()&#123;    //发送一个message对象，类型为MESSAGE_GET_ONLINE_FRIEND = &quot;4&quot;（要求返回用户在线列表）    Message message = new Message();    message.setMesType(MessageType.MESSAGE_GET_ONLINE_FRIEND);    message.setSender(u.getUserId());    //发送给服务器    try &#123;        //先从管理线程的类中得到这个线程，再得到线程的socket对象，在得到字节输出流，转为对象输出流        ObjectOutputStream oos = new ObjectOutputStream(                (ManageClientConnectServerThread.getClientConnectServerThread(u.getUserId())                        .getSocket().getOutputStream()));        oos.writeObject(message);//发送message，要求服务端返回用户在线列表    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125;//退出客户端，并发送个服务端一个退出系统的messagepublic void logout()&#123;    //给服务端发送message退出    Message message = new Message();    message.setMesType(MessageType.MESSAGE_CLIENT_EXIT);    message.setSender(u.getUserId());//一定要指出我是哪个客户端    try &#123;        ObjectOutputStream oos = new ObjectOutputStream(                ManageClientConnectServerThread.getClientConnectServerThread(                        u.getUserId()).getSocket().getOutputStream());        oos.writeObject(message);        System.out.println(u.getUserId() + &quot;退出系统&quot;);        System.exit(0);//退出    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>}</p><h3 id="QQserver"><a href="#QQserver" class="headerlink" title="QQserver"></a>QQserver</h3><h4 id="QQFrame"><a href="#QQFrame" class="headerlink" title="QQFrame"></a>QQFrame</h4><p>package com.ljq.qqframe;</p><p>import com.ljq.qqserver.service.QQServer;</p><p>/**</p><ul><li>@author 刘嘉祺~</li><li>@version 1.0</li><li>该类创建QQServer，启动后台的服务</li><li>/</li></ul><p>public class QQFrame_ {</p><pre><code>public static void main(String[] args) &#123;    new QQServer();&#125;</code></pre><p>}</p><h4 id="service-1"><a href="#service-1" class="headerlink" title="service"></a>service</h4><p>package com.ljq.qqserver.service;</p><p>import java.util.HashMap;<br>import java.util.Iterator;</p><p>/**</p><ul><li>@author 刘嘉祺~</li><li>@version 1.0</li><li>/</li></ul><p>public class ManageClientThreads {</p><pre><code>//我们把多个线程放到一个hashmap中，key代表用户id，value代表线程private static HashMap&lt;String, ServerConnectClientThread&gt; hm = new HashMap&lt;&gt;();//得到集合的方法public static HashMap&lt;String, ServerConnectClientThread&gt; getHm()&#123;    return hm;&#125;//增加到集合的方法public static void addClientThreads(String userId,ServerConnectClientThread serverConnectClientThread)&#123;    hm.put(userId,serverConnectClientThread);&#125;//一处一个线程的方法public static void removeServerConnectClientThread(String userId)&#123;    hm.remove(userId);&#125;//得到集合中线程方法public static ServerConnectClientThread getServerConnectClientThread(String userId)&#123;    return hm.get(userId);&#125;//编写方法，用于返回在线列表public static String getOnlineFriends()&#123;    //拿到hm集合的key集合    //遍历    Iterator&lt;String&gt; iterator = hm.keySet().iterator();    String onlineFriendList = &quot;&quot;;//要返回的列表    while (iterator.hasNext()) &#123;        onlineFriendList += iterator.next() + &quot; &quot;;    &#125;    return onlineFriendList;&#125;</code></pre><p>}</p><p>package com.ljq.qqserver.service;</p><p>import com.ljq.qqcommon.Message;<br>import com.ljq.qqcommon.MessageType;<br>import com.ljq.qqcommon.User;</p><p>import java.io.IOException;<br>import java.io.ObjectInputStream;<br>import java.io.ObjectOutputStream;<br>import java.io.Serializable;<br>import java.net.ServerSocket;<br>import java.net.Socket;<br>import java.util.HashMap;<br>import java.util.concurrent.ConcurrentHashMap;</p><p>/**</p><ul><li>@author 刘嘉祺~</li><li>@version 1.0</li><li>这是服务器，在监听9999，等待客户端连接。并保持通讯</li><li>/</li></ul><p>public class QQServer {</p><pre><code>private ServerSocket ss = null;//创建一个集合，存放多个用户，如果用这些用户登录，就认为这是合法的//可以用ConcurrentHashMap，他是线程安全的，可以处理并发集合，多线程是安全的//HashMap多线程是线程不安全的，没有处理线程安全private static ConcurrentHashMap&lt;String,User&gt; validUser = new ConcurrentHashMap&lt;&gt;();//使用静态代码块初始话用户集合static &#123;    validUser.put(&quot;100&quot;,new User(&quot;100&quot;,&quot;123456&quot;));    validUser.put(&quot;200&quot;,new User(&quot;200&quot;,&quot;123456&quot;));    validUser.put(&quot;300&quot;,new User(&quot;300&quot;,&quot;123456&quot;));    validUser.put(&quot;令狐冲&quot;,new User(&quot;令狐冲&quot;,&quot;123456&quot;));    validUser.put(&quot;任盈盈&quot;,new User(&quot;任盈盈&quot;,&quot;123456&quot;));    validUser.put(&quot;东方不败&quot;,new User(&quot;东方不败&quot;,&quot;123456&quot;));&#125;//验证用户是否有效的方法public boolean checkUser(String userId, String passwd)&#123;    //得到一个用户对象    User user = validUser.get(userId);    if (user == null)&#123;//如果集合里不存在用户。则返回一定是空        return false;    &#125;    if(! user.getPasswd().equals(passwd))&#123;//如果密码不正确        return false;    &#125;    //过关斩将，返回真    return true;&#125;public QQServer() &#123;    try &#123;        System.out.println(&quot;服务器在9999端口监听&quot;);        //启动新闻推送的线程        new Thread(new SendNewsToAllService()).start();        ss = new ServerSocket(9999);        //在某个客户端连接后需要一直等待接收        while (true) &#123;            Socket socket = ss.accept();//如果没有客户端监听，就会阻塞在这里            ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());            //第一个传输的一定是登录用户            User u = (User) ois.readObject();            //得到socket的对象输出流            ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());            //定义一个message对象用于回复客户端            Message message = new Message();            //验证登陆用户            if (checkUser(u.getUserId(), u.getPasswd()))&#123;//合法                //更改消息类型                message.setMesType(MessageType.MESSAGE_LOGIN_SUCCEED);                //写入到通道                oos.writeObject(message);                //创建一个线程，和客户端保持通讯，该线程需要持有socket                ServerConnectClientThread serverConnectClientThread =                        new ServerConnectClientThread(socket, u.getUserId());                serverConnectClientThread.start();                //吧该线程放到一个集合中便于管理                ManageClientThreads.addClientThreads(u.getUserId(), serverConnectClientThread);            &#125;else&#123;//登陆失败                System.out.println(&quot;用户:&quot; + u.getUserId()+ &quot;密码： &quot;+ u.getPasswd() + &quot;登陆失败&quot;);                message.setMesType(MessageType.MESSAGE_LOGIN_FAIL);//修改消息类型                //写入到通道                oos.writeObject(message);                //关闭socket（socket没有意义了）                socket.close();            &#125;        &#125;    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125; finally &#123;        //如果服务器退出while循环，证明不在监听，关闭资源        try &#123;            ss.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>}</p><p>package com.ljq.qqserver.service;</p><p>import com.ljq.qqcommon.Message;<br>import com.ljq.qqcommon.MessageType;<br>import com.ljq.utils.Utility;</p><p>import java.io.IOException;<br>import java.io.ObjectOutputStream;<br>import java.util.Date;<br>import java.util.HashMap;</p><p>/**</p><ul><li>@author 刘嘉祺~</li><li>@version 1.0</li><li>/</li></ul><p>public class SendNewsToAllService implements Runnable{</p><pre><code>@Overridepublic void run() &#123;    while (true)&#123;        System.out.println(&quot;请输入你要发送的新闻（输入exit退出新闻推送服务）：&quot;);        String news = Utility.readString(100);        if (&quot;exit&quot;.equals(news))&#123;//退出服务            break;        &#125;        //设立一个消息        Message message = new Message();        message.setSender(&quot;服务器&quot;);        message.setMesType(MessageType.MESSAGE_TO_ALL_MES);        message.setContent(news);        message.setSendTime(new Date().toString());        System.out.println(&quot;服务器给大家推送新闻：&quot; + news);        //得到所有在线用户，发送        HashMap&lt;String, ServerConnectClientThread&gt; hm = ManageClientThreads.getHm();        for (String userid : hm.keySet()) &#123;            try &#123;                ObjectOutputStream oos =                        new ObjectOutputStream(hm.get(userid).getSocket().getOutputStream());                oos.writeObject(message);            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><p>}</p><p>package com.ljq.qqserver.service;</p><p>import com.ljq.qqcommon.Message;<br>import com.ljq.qqcommon.MessageType;<br>import com.sun.org.apache.bcel.internal.generic.NEW;</p><p>import java.io.IOException;<br>import java.io.ObjectInputStream;<br>import java.io.ObjectOutputStream;<br>import java.net.Socket;<br>import java.util.HashMap;<br>import java.util.Iterator;</p><p>/**</p><ul><li>@author 刘嘉祺~</li><li>@version 1.0</li><li>该类对应的对象和某个客户端通讯</li><li>/</li></ul><p>public class ServerConnectClientThread extends Thread {</p><pre><code>//线程需要持有socketprivate Socket socket;private String userId;//链接到服务端的idpublic ServerConnectClientThread(Socket socket, String userId) &#123;    this.socket = socket;    this.userId = userId;&#125;public Socket getSocket() &#123;    return socket;&#125;@Overridepublic void run() &#123;//可以发送和接收客户端    while (true) &#123;        try &#123;            System.out.println(&quot;服务端和客户端&quot; + userId + &quot;保持通讯，读取数据。。&quot;);//服务端和客户端保持通讯，读取数据。。            ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());            Message message = (Message) ois.readObject();            //ms后面使用。。根据ms类型提供相应的业务服务            if (message.getMesType().equals(MessageType.MESSAGE_GET_ONLINE_FRIEND)) &#123;                //客户要求要在线列表信息            /*             用户列表格式为“100 200 令狐冲”以空格隔开            */                System.out.println(message.getSender() + &quot;要在线用户列表&quot;);                //得到在线用户列表                String onlineFriends = ManageClientThreads.getOnlineFriends();                //创建一个message，返回                Message message1 = new Message();                message1.setMesType(MessageType.MESSAGE_RET_ONLINE_FRIEND);                message1.setContent(onlineFriends);                message1.setGetter(message.getSender());                //返回给客户端                ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());                oos.writeObject(message1);            &#125; else if (message.getMesType().equals(MessageType.MESSAGE_CLIENT_EXIT)) &#123;//客户端退出                System.out.println(message.getSender() + &quot;退出&quot;);                //把该线程从管理线程的集合中移除                ManageClientThreads.removeServerConnectClientThread(message.getSender());                //关闭socket通道                socket.close();                //退出该线程                break;            &#125; else if (message.getMesType().equals(MessageType.MESSAGE_COMM_MES)) &#123;//私聊                //根据getter 的 id 得到接受者的线程 的通道                ServerConnectClientThread serverConnectClientThread =                        ManageClientThreads.getServerConnectClientThread(message.getGetter());                //得到对应的输出流，将message发送给对应的客户端                ObjectOutputStream oos =                        new ObjectOutputStream(serverConnectClientThread.getSocket().getOutputStream());                oos.writeObject(message);//提示“如果不在线可以把消息保存到数据库，实现离线留言            &#125; else if (message.getMesType().equals(MessageType.MESSAGE_TO_ALL_MES)) &#123;                //遍历管理线程的集合                HashMap&lt;String, ServerConnectClientThread&gt; hm = ManageClientThreads.getHm();                Iterator&lt;String&gt; iterator = hm.keySet().iterator();                while (iterator.hasNext()) &#123;                    String onlineFriend = iterator.next();                    if (!onlineFriend.equals(message.getSender())) &#123;//排除掉发送者                        //发送给不同的线程通道                        ObjectOutputStream oos =                                new ObjectOutputStream(hm.get(onlineFriend).getSocket().getOutputStream());                        oos.writeObject(message);                    &#125;                &#125;            &#125; else if (message.getMesType().equals(MessageType.MESSAGE_FILE_MES)) &#123;                //得到接收者线程，转发                ObjectOutputStream oos =                        new ObjectOutputStream(ManageClientThreads.getServerConnectClientThread(message.getGetter()).getSocket().getOutputStream());                oos.writeObject(message);            &#125; else &#123;                System.out.println(&quot;其他类型。。暂不处理&quot;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;        &#125;    &#125;&#125;</code></pre><p>}</p><h3 id="utils-别人写好的工具类"><a href="#utils-别人写好的工具类" class="headerlink" title="utils(别人写好的工具类)"></a>utils(别人写好的工具类)</h3><p>package com.ljq.utils;</p><p>/**<br>    工具类的作用:</p><pre><code>处理各种情况的用户输入，并且能够按照程序员的需求，得到用户的控制台输入。</code></pre><p>*/</p><p>import java.util.Scanner;</p><p>/**</p><p>*/<br>public class Utility {</p><pre><code>//静态属性。。。private static Scanner scanner = new Scanner(System.in);/** * 功能：读取键盘输入的一个菜单选项，值：1——5的范围 * @return 1——5 */public static char readMenuSelection() &#123;    char c;    for (; ; ) &#123;        String str = readKeyBoard(1, false);//包含一个字符的字符串        c = str.charAt(0);//将字符串转换成字符char类型        if (c != &#39;1&#39; &amp;&amp; c != &#39;2&#39; &amp;&amp;             c != &#39;3&#39; &amp;&amp; c != &#39;4&#39; &amp;&amp; c != &#39;5&#39;) &#123;            System.out.print(&quot;选择错误，请重新输入：&quot;);        &#125; else break;    &#125;    return c;&#125;/** * 功能：读取键盘输入的一个字符 * @return 一个字符 */public static char readChar() &#123;    String str = readKeyBoard(1, false);//就是一个字符    return str.charAt(0);&#125;/** * 功能：读取键盘输入的一个字符，如果直接按回车，则返回指定的默认值；否则返回输入的那个字符 * @param defaultValue 指定的默认值 * @return 默认值或输入的字符 */public static char readChar(char defaultValue) &#123;    String str = readKeyBoard(1, true);//要么是空字符串，要么是一个字符    return (str.length() == 0) ? defaultValue : str.charAt(0);&#125;/** * 功能：读取键盘输入的整型，长度小于2位 * @return 整数 */public static int readInt() &#123;    int n;    for (; ; ) &#123;        String str = readKeyBoard(10, false);//一个整数，长度&lt;=2位        try &#123;            n = Integer.parseInt(str);//将字符串转换成整数            break;        &#125; catch (NumberFormatException e) &#123;            System.out.print(&quot;数字输入错误，请重新输入：&quot;);        &#125;    &#125;    return n;&#125;/** * 功能：读取键盘输入的 整数或默认值，如果直接回车，则返回默认值，否则返回输入的整数 * @param defaultValue 指定的默认值 * @return 整数或默认值 */public static int readInt(int defaultValue) &#123;    int n;    for (; ; ) &#123;        String str = readKeyBoard(10, true);        if (str.equals(&quot;&quot;)) &#123;            return defaultValue;        &#125;                //异常处理...        try &#123;            n = Integer.parseInt(str);            break;        &#125; catch (NumberFormatException e) &#123;            System.out.print(&quot;数字输入错误，请重新输入：&quot;);        &#125;    &#125;    return n;&#125;/** * 功能：读取键盘输入的指定长度的字符串 * @param limit 限制的长度 * @return 指定长度的字符串 */public static String readString(int limit) &#123;    return readKeyBoard(limit, false);&#125;/** * 功能：读取键盘输入的指定长度的字符串或默认值，如果直接回车，返回默认值，否则返回字符串 * @param limit 限制的长度 * @param defaultValue 指定的默认值 * @return 指定长度的字符串 */public static String readString(int limit, String defaultValue) &#123;    String str = readKeyBoard(limit, true);    return str.equals(&quot;&quot;)? defaultValue : str;&#125;/** * 功能：读取键盘输入的确认选项，Y或N * 将小的功能，封装到一个方法中. * @return Y或N */public static char readConfirmSelection() &#123;    System.out.println(&quot;请输入你的选择(Y/N),请小心选择&quot;);    char c;    for (; ; ) &#123;//无限循环        //在这里，将接受到字符，转成了大写字母        //y =&gt; Y n=&gt;N        String str = readKeyBoard(1, false).toUpperCase();        c = str.charAt(0);        if (c == &#39;Y&#39; || c == &#39;N&#39;) &#123;            break;        &#125; else &#123;            System.out.print(&quot;选择错误，请重新输入：&quot;);        &#125;    &#125;    return c;&#125;/** * 功能： 读取一个字符串 * @param limit 读取的长度 * @param blankReturn 如果为true ,表示 可以读空字符串。  *                       如果为false表示 不能读空字符串。 *              *    如果输入为空，或者输入大于limit的长度，就会提示重新输入。 * @return */private static String readKeyBoard(int limit, boolean blankReturn) &#123;        //定义了字符串    String line = &quot;&quot;;    //scanner.hasNextLine() 判断有没有下一行    while (scanner.hasNextLine()) &#123;        line = scanner.nextLine();//读取这一行               //如果line.length=0, 即用户没有输入任何内容，直接回车        if (line.length() == 0) &#123;            if (blankReturn) return line;//如果blankReturn=true,可以返回空串            else continue; //如果blankReturn=false,不接受空串，必须输入内容        &#125;        //如果用户输入的内容大于了 limit，就提示重写输入          //如果用户如的内容 &gt;0 &lt;= limit ,我就接受        if (line.length() &lt; 1 || line.length() &gt; limit) &#123;            System.out.print(&quot;输入长度（不能大于&quot; + limit + &quot;）错误，请重新输入：&quot;);            continue;        &#125;        break;    &#125;    return line;&#125;</code></pre><p>}</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Java自学完成项目&quot;&gt;&lt;a href=&quot;#Java自学完成项目&quot; class=&quot;headerlink&quot; title=&quot;Java自学完成项目&quot;&gt;&lt;/a&gt;Java自学完成项目&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>IDEA怎样进入源码</title>
    <link href="http://example.com/2021/06/04/IEDAdebug%E6%80%8E%E6%A0%B7%E8%BF%9B%E5%85%A5%E6%BA%90%E7%A0%81/"/>
    <id>http://example.com/2021/06/04/IEDAdebug%E6%80%8E%E6%A0%B7%E8%BF%9B%E5%85%A5%E6%BA%90%E7%A0%81/</id>
    <published>2021-06-04T01:27:18.000Z</published>
    <updated>2021-06-04T01:28:23.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDEA怎样进入源码"><a href="#IDEA怎样进入源码" class="headerlink" title="IDEA怎样进入源码"></a>IDEA怎样进入源码</h1><span id="more"></span><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p><img src="https://i.loli.net/2021/06/04/KosSGFqPUYOmIfw.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;IDEA怎样进入源码&quot;&gt;&lt;a href=&quot;#IDEA怎样进入源码&quot; class=&quot;headerlink&quot; title=&quot;IDEA怎样进入源码&quot;&gt;&lt;/a&gt;IDEA怎样进入源码&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>IDEA如何查看JDK源码</title>
    <link href="http://example.com/2021/06/03/IDEA%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8BJDK%E6%BA%90%E7%A0%81/"/>
    <id>http://example.com/2021/06/03/IDEA%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8BJDK%E6%BA%90%E7%A0%81/</id>
    <published>2021-06-03T01:18:11.000Z</published>
    <updated>2021-06-03T01:19:57.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDEA如何查看JDK源码"><a href="#IDEA如何查看JDK源码" class="headerlink" title="IDEA如何查看JDK源码"></a>IDEA如何查看JDK源码</h1><span id="more"></span><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p><img src="https://i.loli.net/2021/06/03/kGwKDtZ4humA9zy.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;IDEA如何查看JDK源码&quot;&gt;&lt;a href=&quot;#IDEA如何查看JDK源码&quot; class=&quot;headerlink&quot; title=&quot;IDEA如何查看JDK源码&quot;&gt;&lt;/a&gt;IDEA如何查看JDK源码&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Javadoc</title>
    <link href="http://example.com/2021/05/27/javadoc/"/>
    <id>http://example.com/2021/05/27/javadoc/</id>
    <published>2021-05-27T02:21:53.000Z</published>
    <updated>2021-05-27T02:23:10.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="javadoc"><a href="#javadoc" class="headerlink" title="javadoc"></a>javadoc</h1><span id="more"></span><p><img src="https://i.loli.net/2021/05/27/ruKZ6U9yqoe1MVz.png"><br><img src="https://i.loli.net/2021/05/27/AJxYDWcXh65kg1m.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;javadoc&quot;&gt;&lt;a href=&quot;#javadoc&quot; class=&quot;headerlink&quot; title=&quot;javadoc&quot;&gt;&lt;/a&gt;javadoc&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java规范</title>
    <link href="http://example.com/2021/05/27/java%E8%A7%84%E8%8C%83/"/>
    <id>http://example.com/2021/05/27/java%E8%A7%84%E8%8C%83/</id>
    <published>2021-05-27T02:21:53.000Z</published>
    <updated>2021-05-27T07:32:38.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java规范"><a href="#java规范" class="headerlink" title="java规范"></a>java规范</h1><span id="more"></span><center>**规范**</center>  <br>  <p><img src="https://i.loli.net/2021/05/27/gAaOWQFG5jK3PBh.png"></p><br>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;java规范&quot;&gt;&lt;a href=&quot;#java规范&quot; class=&quot;headerlink&quot; title=&quot;java规范&quot;&gt;&lt;/a&gt;java规范&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>IDEA使用技巧和经验</title>
    <link href="http://example.com/2021/05/27/IDEA%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%92%8C%E7%BB%8F%E9%AA%8C-1/"/>
    <id>http://example.com/2021/05/27/IDEA%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%92%8C%E7%BB%8F%E9%AA%8C-1/</id>
    <published>2021-05-27T01:57:21.000Z</published>
    <updated>2021-05-31T06:26:39.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IEDA使用技巧和经验"><a href="#IEDA使用技巧和经验" class="headerlink" title="IEDA使用技巧和经验"></a>IEDA使用技巧和经验</h1><span id="more"></span><h2 id="设置字体颜色和主题"><a href="#设置字体颜色和主题" class="headerlink" title="设置字体颜色和主题"></a>设置字体颜色和主题</h2><p><img src="https://i.loli.net/2021/05/31/Yr987t6RNFo2IMe.png"></p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ol><li>删除当前行, 默认是 ctrl + Y 自己配置 ctrl + d </li><li>复制当前行, 自己配置 ctrl + alt + 向下光标 </li><li>补全代码 alt + / </li><li>添加注释和取消注释 ctrl + / 【第一次是添加注释，第二次是取消注释】 </li><li>导入该行需要的类 先配置 auto import , 然后使用 alt+enter 即可 </li><li>快速格式化代码 ctrl + alt + L </li><li>快速运行程序 自己定义 alt + R </li><li>生成构造器等 alt + insert [提高开发效率] </li><li>查看一个类的层级关系 ctrl + H [学习继承后，非常有用] </li><li>将光标放在一个方法上，输入 ctrl + B , 可以定位到方法 [学继承后，非常有用] </li><li>自动的分配变量名 , 通过 在后面假 .var [老师最喜欢的] </li><li>还有很多其它的快捷键<h2 id="自定义模板"><a href="#自定义模板" class="headerlink" title="自定义模板"></a>自定义模板</h2><img src="https://i.loli.net/2021/05/31/xlMBZLRIXfNKFcj.png"> </li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;IEDA使用技巧和经验&quot;&gt;&lt;a href=&quot;#IEDA使用技巧和经验&quot; class=&quot;headerlink&quot; title=&quot;IEDA使用技巧和经验&quot;&gt;&lt;/a&gt;IEDA使用技巧和经验&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
