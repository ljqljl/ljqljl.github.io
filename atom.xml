<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>6 + 7</title>
  
  <subtitle>无</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-12-31T08:04:15.166Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>愚人丶不愚</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>spring复习</title>
    <link href="http://example.com/2021/12/30/spring%E5%A4%8D%E4%B9%A0/"/>
    <id>http://example.com/2021/12/30/spring%E5%A4%8D%E4%B9%A0/</id>
    <published>2021-12-30T08:19:00.000Z</published>
    <updated>2021-12-31T08:04:15.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring复习"><a href="#spring复习" class="headerlink" title="spring复习"></a>spring复习</h1><span id="more"></span><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul><li>spring，开源免费</li><li>轻量级，非入侵式</li><li>控制反转（IOC）， 面向切面编程（AOP）</li><li>支持事务的处理，对框架整合的支持</li></ul><h1 id="ioc理论推导"><a href="#ioc理论推导" class="headerlink" title="ioc理论推导"></a>ioc理论推导</h1><ul><li>使用set接口实现持久层链接服务层，已经发生了革命性的变化！</li><li>之前，程序是主动创建，控制权在程序员手里！</li><li>使用set注入后，程序不在具有主动性，而是变成被动接受的对象！</li><li>这种思想，从本质上解决了问题，我们程序员不用再去管理对象创建了。系统耦合性大大降低~，可以更加专注在业务的实现上！这是IOC的原型！</li><li>控制反转是一种思想，di是控制反转的一种实现</li><li>解耦，ioc容器出现了</li><li>控制反转是一种通过描述（xml或注解）并通过第三方去生产或获取特定对象的方式。在spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection，DI）（需要用set）</li><li>spring控制反转的过程（bean），用的时候直接在容器中拿就好了<br><img src="https://s2.loli.net/2021/12/31/rAYOJUb3CR2FGxi.png"></li><li>到现在，彻底不用去程序中修改，要实现不同的操作，需要在xml配置文件中进行修改，对象由Spring来创建，管理，装配！（IOC）</li><li>value:具体的值，基本数据类型、ref：引用类型，可引用其他的bean</li><li>ApplicationContext context = new ClassPathXmlApplicationContext（”beans.xml”）；//获取ApplicationContext ：拿到容器</li><li>容器在手，天下我有，需要什么，就直接get什么（context.getBean(“”)）</li></ul><h1 id="IOC创建对象的方式"><a href="#IOC创建对象的方式" class="headerlink" title="IOC创建对象的方式"></a>IOC创建对象的方式</h1><ul><li>使用无参构造创建对象，默认！</li><li>假设我们要使用有参构造器创建对象</li></ul><ol><li>按下标赋值<br>&lt;constructor-arg index=”0” value=”哈哈哈”&gt;</li><li>按类型（不推荐）</li><li>直接通过参数名<br>&lt;constructor-arg name=”name” value=”哈哈哈”&gt;</li></ol><ul><li>在配置文件加载的时候，容器就被初始化了</li></ul><h1 id="spring的配置"><a href="#spring的配置" class="headerlink" title="spring的配置"></a>spring的配置</h1><h2 id="别名（没用，name也可以）"><a href="#别名（没用，name也可以）" class="headerlink" title="别名（没用，name也可以）"></a>别名（没用，name也可以）</h2><ul><li>&lt;alias name=”user” alias=”userNew”/&gt;//可以使用别名取到这个对象</li></ul><h2 id="Bean的配置"><a href="#Bean的配置" class="headerlink" title="Bean的配置"></a>Bean的配置</h2><ul><li>id：唯一标识</li><li>class：bean对象对应的全限定名</li><li>name:别名</li></ul><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><ul><li>一般用于团队开发使用，它可以将多个配置文件，导入合并为一个</li><li>&lt;import resource=”beans.xml”&gt;</li></ul><h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><h2 id="构造器注入（前面说了）"><a href="#构造器注入（前面说了）" class="headerlink" title="构造器注入（前面说了）"></a>构造器注入（前面说了）</h2><h2 id="set方式注入（重点）"><a href="#set方式注入（重点）" class="headerlink" title="set方式注入（重点）"></a>set方式注入（重点）</h2><ul><li>set注入</li></ul><ol><li>依赖：bean对象的创建依赖于容器！</li><li>注入：bean对象中所有属性，有容器来注入！</li></ol><ul><li><p>普通注入 value</p></li><li><p>Bean 注入（引用）（ref）</p></li><li><p>数组注入</p><pre><code>  &lt;property name=&quot;card&quot;&gt;      &lt;array&gt;          &lt;value&gt;红楼梦&lt;/value&gt;          &lt;value&gt;红楼梦&lt;/value&gt;          &lt;value&gt;红楼梦&lt;/value&gt;          &lt;value&gt;红楼梦&lt;/value&gt;      &lt;/array&gt;  &lt;/property&gt;    </code></pre></li><li><p>list</p><pre><code>  &lt;property name=&quot;card&quot;&gt;      &lt;list&gt;          &lt;value&gt;红楼梦&lt;/value&gt;          &lt;value&gt;红楼梦&lt;/value&gt;          &lt;value&gt;红楼梦&lt;/value&gt;          &lt;value&gt;红楼梦&lt;/value&gt;      &lt;/list&gt;  &lt;/property&gt; </code></pre></li><li><p>map</p><pre><code>  &lt;property name=&quot;card&quot;&gt;      &lt;map&gt;          &lt;entry key=&quot;&quot; value=&quot;&quot;&gt;&lt;/entry&gt;          ...          ...      &lt;/map&gt;  &lt;/property&gt;</code></pre></li><li><p>set</p><pre><code>  &lt;property name=&quot;card&quot;&gt;      &lt;list&gt;          &lt;value&gt;红楼梦&lt;/value&gt;          &lt;value&gt;红楼梦&lt;/value&gt;          &lt;value&gt;红楼梦&lt;/value&gt;          &lt;value&gt;红楼梦&lt;/value&gt;      &lt;/list&gt;  &lt;/property&gt; </code></pre></li><li><p>null</p><pre><code>  &lt;property name=&quot;&quot;&gt;      &lt;null&gt;  &lt;/propertry&gt;</code></pre></li><li><p>properties</p><pre><code>  &lt;property name=&quot;&quot;&gt;      &lt;props&gt;          &lt;prop key=&quot;&quot;&gt;...&lt;/prop&gt;          ...      &lt;/props&gt;  &lt;/property&gt;</code></pre></li></ul><h2 id="拓展方式注入-不重要"><a href="#拓展方式注入-不重要" class="headerlink" title="拓展方式注入(不重要)"></a>拓展方式注入(不重要)</h2><ul><li><p>p命名空间：可以直接注入属性的值：省略&lt;property&gt;(要加约束，对应set注入)</p></li><li><p>c命名空间 ，通过构造器注入&lt;construct-args&gt;（要加约束，对应构造器注入 ）</p><h2 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h2></li><li><p>singleton：单例模式（spring默认模式）</p></li><li><p>prototype：原型模式、每次从容器中get的时候，都会产生一个新的对象！</p></li><li><p>request、<br>session、<br>application、这些个只能在web开发中使用到</p></li><li><p>websocket</p></li></ul><h1 id="Bean的自动装配"><a href="#Bean的自动装配" class="headerlink" title="Bean的自动装配"></a>Bean的自动装配</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;spring复习&quot;&gt;&lt;a href=&quot;#spring复习&quot; class=&quot;headerlink&quot; title=&quot;spring复习&quot;&gt;&lt;/a&gt;spring复习&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>springcloud系统自学篇</title>
    <link href="http://example.com/2021/12/30/springcloud%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%AD%A6%E7%AF%87/"/>
    <id>http://example.com/2021/12/30/springcloud%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%AD%A6%E7%AF%87/</id>
    <published>2021-12-30T06:41:00.000Z</published>
    <updated>2021-12-31T06:37:01.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="springcloud系统自学篇"><a href="#springcloud系统自学篇" class="headerlink" title="springcloud系统自学篇"></a>springcloud系统自学篇</h1><span id="more"></span><h1 id="微服务技术栈"><a href="#微服务技术栈" class="headerlink" title="微服务技术栈"></a>微服务技术栈</h1><p><img src="https://s2.loli.net/2021/12/30/8HnrIUw2AclmfWb.png"><br><img src="https://s2.loli.net/2021/12/30/mdpXciNatzTOBuQ.png"></p><h1 id="实用篇"><a href="#实用篇" class="headerlink" title="实用篇"></a>实用篇</h1><h2 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h2><h2 id="分布式服务架构案例"><a href="#分布式服务架构案例" class="headerlink" title="分布式服务架构案例"></a>分布式服务架构案例</h2><h2 id="eureka注册中心"><a href="#eureka注册中心" class="headerlink" title="eureka注册中心"></a>eureka注册中心</h2><h2 id="Ribbon负载均衡原理"><a href="#Ribbon负载均衡原理" class="headerlink" title="Ribbon负载均衡原理"></a>Ribbon负载均衡原理</h2><h2 id="nacos注册中心"><a href="#nacos注册中心" class="headerlink" title="nacos注册中心"></a>nacos注册中心</h2><h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><h1 id="面试篇"><a href="#面试篇" class="headerlink" title="面试篇"></a>面试篇</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;springcloud系统自学篇&quot;&gt;&lt;a href=&quot;#springcloud系统自学篇&quot; class=&quot;headerlink&quot; title=&quot;springcloud系统自学篇&quot;&gt;&lt;/a&gt;springcloud系统自学篇&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构和算法缓慢学习篇</title>
    <link href="http://example.com/2021/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%BC%93%E6%85%A2%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <id>http://example.com/2021/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%BC%93%E6%85%A2%E5%AD%A6%E4%B9%A0%E7%AF%87/</id>
    <published>2021-12-30T06:11:00.000Z</published>
    <updated>2021-12-31T06:36:59.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构和算法缓慢学习篇"><a href="#数据结构和算法缓慢学习篇" class="headerlink" title="数据结构和算法缓慢学习篇"></a>数据结构和算法缓慢学习篇</h1><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据结构和算法缓慢学习篇&quot;&gt;&lt;a href=&quot;#数据结构和算法缓慢学习篇&quot; class=&quot;headerlink&quot; title=&quot;数据结构和算法缓慢学习篇&quot;&gt;&lt;/a&gt;数据结构和算法缓慢学习篇&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>服务器网站</title>
    <link href="http://example.com/2021/12/27/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://example.com/2021/12/27/%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2021-12-27T10:03:00.000Z</published>
    <updated>2021-12-27T10:04:15.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="https-msdn-itellyou-cn"><a href="#https-msdn-itellyou-cn" class="headerlink" title="https://msdn.itellyou.cn/"></a><a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn/</a></h1><h1 id="https-hellowindows-cn"><a href="#https-hellowindows-cn" class="headerlink" title="https://hellowindows.cn/"></a><a href="https://hellowindows.cn/">https://hellowindows.cn/</a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;https-msdn-itellyou-cn&quot;&gt;&lt;a href=&quot;#https-msdn-itellyou-cn&quot; class=&quot;headerlink&quot; title=&quot;https://msdn.itellyou.cn/&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot系统自学</title>
    <link href="http://example.com/2021/12/17/springboot%20%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%AD%A6/"/>
    <id>http://example.com/2021/12/17/springboot%20%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%AD%A6/</id>
    <published>2021-12-17T06:41:00.000Z</published>
    <updated>2021-12-30T03:18:02.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot系统自学"><a href="#SpringBoot系统自学" class="headerlink" title="SpringBoot系统自学"></a>SpringBoot系统自学</h1><span id="more"></span><h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><ul><li><p>简化spring的</p></li><li><p>要网络的</p></li><li><p>  @RestController<br>  @RequestMapping(“/books”)<br>  public class BookController {</p><pre><code>  @GetMapping  public String getById()&#123;      System.out.println(&quot;run...&quot;);      return &quot;run....&quot;;  &#125;</code></pre><p>  }</p><p>  Application入口</p><p>  @SpringBootApplication<br>  public class Springboot0101LjqApplication {</p><pre><code>  public static void main(String[] args) &#123;      SpringApplication.run(Springboot0101LjqApplication.class, args);  &#125;</code></pre><p>  }</p></li><li><p><img src="https://s2.loli.net/2021/12/17/iNeSE7A2kR8GUPo.png"></p></li><li><p>基于官网搭建，也可以用阿里云的，一样</p></li><li><p>没网可以手工创建</p></li></ul><ol><li>手工导入坐标（继承+添加）</li><li>手工创建引导类<h3 id="入门案例解析"><a href="#入门案例解析" class="headerlink" title="入门案例解析"></a>入门案例解析</h3></li></ol><ul><li>parent</li></ul><ol><li><p>定义一系列的的坐标版本</p></li><li><p>定义一系列的常用坐标组合</p></li><li><p>直接使用组合</p></li><li><p>基于官网：parent-&gt;dependencies(定义一堆信息)</p><p> 基于阿里云：直接引用dependencies</p></li><li><p>他是个依赖管理，而不是个依赖，减少依赖冲突。</p></li></ol><ul><li>starter</li></ul><ol><li>一个starter包含了若干个pom依赖坐标</li><li>减少依赖配置的</li><li>如果使用任意坐标时候仅书写GAV中的G和A，V由SpringBoot提供，除非SpringBoot未提供</li><li>如果坐标发生错误，在指定Version（要小心版本冲突问题）</li></ol><ul><li>引导类</li></ul><ol><li>Boot工程的执行入口，运行main就可以启动</li><li>SpringBoot工程运行后初始化Spring容器，扫描引导类所在的包加载bean</li></ol><ul><li>内嵌Tomcat</li></ul><ol><li>工作原理：将Tomcat服务器作为对象运行，并将对象交给Spring容器管理</li><li>变更内嵌服务器的思想是去除现有的服务器，添加全新的服务器<h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3></li></ol><ul><li>教你一招：复制工程</li></ul><ol><li>保留工程基础结构</li><li>抹掉原始工程痕迹</li><li>具体实现：制作一个模板仅保留src和pom.xml,修改pom中的artifactId，删除name标签</li></ol><ul><li>属性配置</li></ul><ol><li>SpringBoot中导入对应starter后，提供对应配置属性</li><li>书写SpringBoot配置采用关键字+提示形式书写</li><li>主流为yml格式</li><li>格式优先级：properties》yml》yaml</li><li>不同配置为你教案中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留</li></ol><ul><li>教你一招：属性提示消失怎么办</li></ul><ol><li>Facets</li></ol><ul><li>配置文件分类</li><li>yaml文件</li></ul><ol><li>一种数据序列化格式</li><li>优点：1，容易阅读<br>2，容易与脚本语言交互3，以数据为核心，重数据轻格式</li><li>YAML文件扩展名<br>yml,yaml</li></ol><ul><li>yaml数据读取</li></ul><ol><li>@Value</li><li>env</li><li>@ConfigurationProperties，封装一个类，定义为Spring管理的bean，否则无法进行属性注入<h3 id="整合三方数据-（要学会怎样适合所有内容）"><a href="#整合三方数据-（要学会怎样适合所有内容）" class="headerlink" title="整合三方数据 （要学会怎样适合所有内容）"></a>整合三方数据 （要学会怎样适合所有内容）</h3></li></ol><ul><li>整合JUnit</li></ul><ol><li><p>核心：@SpringBootTest</p></li><li><p>自动装配的形式添加要测试的对象、</p></li><li><p>测试类如果不在引导类所在包或者其子包，会报错，可以指定（classes=。。。）</p></li></ol><ul><li>整合MyBatis</li></ul><ol><li>重点：</li></ol><p>核心配置：数据库连接相关信息（连什么？连谁？什么权限）</p><p>映射配置：SQL映射（XML/注解）<br>2. 步骤：</p><p>1）选择当前模块所需的技术集</p><p>2）数据库链接信息转换未配置信息</p><p>3）sql映射，添加@Mapper被容器识别到</p><ol start="3"><li>mysql 8+的问题，</li></ol><p>时区问题：?serverTimezone=UTC</p><p>驱动类过时：加cj</p><ul><li>整合MyBatis-Plus</li></ul><ol><li>MyBatis-Plus 和 MyBatis的区别</li></ol><p>导入坐标不同</p><p>数据层实现简化</p><ol start="2"><li>坐标手工加</li><li>定义数据层接口与映射配置，继承BaseMapper</li></ol><ul><li>整合Druid（略）</li><li>整合任意的第三方技术</li></ul><ol><li>导入对应的starter</li><li>配置对应的设置或采用默认配置<h3 id="基于SpringBoot的SSMP整合案例"><a href="#基于SpringBoot的SSMP整合案例" class="headerlink" title="基于SpringBoot的SSMP整合案例"></a>基于SpringBoot的SSMP整合案例</h3></li></ol><ul><li>lombok：实体类简化</li><li>手工导入starter坐标</li><li>配置数据源与MyBatisPlus对应的配置</li><li>开发Dao接口</li><li>制作测试类的Dao功能是否有效</li><li>开启mp的日志：加配置</li><li>MP分页：</li></ul><ol><li><p>在config包里写个拦截器</p><p> @Configuration</p><p> public class MPConfig {</p><pre><code> @Bean public MybatisPlusInterceptor  mybatisPlusInterceptor()&#123;     MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();     mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());     return mybatisPlusInterceptor; &#125;</code></pre><p> }</p></li><li><pre><code> IPage page = new Page(2, 6); empDao.selectPage(page,null); System.out.println(page.getCurrent()); System.out.println(page.getSize()); System.out.println(page.getTotal()); System.out.println(page.getPages());</code></pre></li></ol><ul><li>按条件查询<pre><code>  String name = &quot;K&quot;;  LambdaQueryWrapper&lt;Emp&gt; lqw = new LambdaQueryWrapper&lt;&gt;();  lqw.like(name != null,Emp::getEname, name);  empDao.selectList(lqw);</code></pre></li><li>业务层-快速开发</li></ul><ol><li>使用MyBatisPlus提供有业务通用接口（ISerivce&lt;T&gt;）快速开发Service。</li><li>业务层通用实现类（ServiceImpl&lt;M，T&gt;）快速开发Service</li><li>在通用类基础上做功能重载或功能追加</li><li>注意重载时不要覆盖原始操作，避免原始提供的功能丢失</li></ol><ul><li>表现层标准开发</li></ul><ol><li>基于Resful制作表现层接口</li></ol><p>1）新增：POST</p><p>2）删除：DELETE</p><p>3）修改：PUT</p><p>4）查询：GET</p><ol start="2"><li>接收参数</li></ol><p>1）实体数据：@RequestBody</p><p>2）路径变量：@PathVariable</p><ul><li>表现层消息一致性处理</li></ul><ol><li><p>设计表现层返回结果的模型类，用于后按与前端进行数据格式统一，也称为“前后端数据协议”</p><p> public class R {</p><pre><code> private Boolean flag; private Object data; public R()&#123;&#125; public R(Boolean flag)&#123;     this.flag = flag; &#125; public R(Boolean flag,Object data)&#123;     this.flag = flag;     this.data = data; &#125;</code></pre><p> }</p></li></ol><p>@GetMapping</p><pre><code>public R getAll()&#123;    return new R(true,empService.list());&#125;@PostMappingpublic R save(@RequestBody Emp emp)&#123;    return new R(empService.save(emp));&#125;@PutMappingpublic R update(@RequestBody Emp emp)&#123;    return new R(empService.updateById(emp));&#125;@DeleteMapping(&quot;&#123;id&#125;&quot;)public R delete(@PathVariable Integer id)&#123;    return new R(empService.removeById(id));&#125;@GetMapping(&quot;&#123;id&#125;&quot;)public R getById(@PathVariable Integer id)&#123;    return new R(true,empService.getById(id));&#125;@GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)public R getPage(@PathVariable Integer currentPage,@PathVariable Integer pageSize)&#123;    return new R(true,empService.getPage(currentPage,pageSize));&#125;</code></pre><h3 id="前后端协议联调"><a href="#前后端协议联调" class="headerlink" title="前后端协议联调"></a>前后端协议联调</h3><ul><li>显示列表</li></ul><ol><li>单体项目中页面放置在resources/static目录下</li><li>created钩子函数用于初始化页面时发起调用</li><li>页面使用axios发送异步请求获取数据后确认前后端是否联通</li><li>将查询数据返回到页面，利用前端数据双向绑定进行数据展示</li></ol><ul><li>添加</li></ul><ol><li>请求方式使用POST调用后台对应操作</li><li>添加操作结束后动态刷新页面加载数据</li><li>根据操作结果不同，显示对应的信息提示</li><li>弹出添加Div时清除表单数据</li></ol><ul><li>删除</li></ul><ol><li>请求方式使用Delete调用后台对应操作</li><li>删除操作需要传递当前行数据对应的id值到后台</li><li>删除操作结束后动态刷新页面加载数据</li><li>根据操作结果不同，显示对应的提示信息</li><li>删除操作前弹出提示框避免误操作</li></ol><ul><li>修改</li></ul><ol><li>请求方式使用PUT调用后台对应操作</li><li>修改操作结束后动态刷新界面加载数据（同新增）</li><li>根据操作结果不同，显示对应的提示信息（同新增）</li></ol><ul><li>业务消息一致性处理</li></ul><ol><li>使用注解@RestControllerAdvice定义SpringMVC异常处理器用来处理异常的</li><li>异常处理器必须被扫描加载，否则无法生效</li><li>表现层返回结果的模型类中添加消息属性用来传递消息到界面 </li></ol><ul><li>分页</li></ul><ol><li>使用el分页组件</li><li>定义分页组件绑定的数据模型</li><li>异步调用获取分页数据</li><li>分页数据页面回显示</li></ol><ul><li>按条件查询</li></ul><ol><li>定义查询条件数据模型（当前封装到分页数据模型中）</li><li>异步调用分页功能并通过请求参数传递数据到后台</li></ol><h1 id="应用篇"><a href="#应用篇" class="headerlink" title="应用篇"></a>应用篇</h1><h2 id="运维实用篇"><a href="#运维实用篇" class="headerlink" title="运维实用篇"></a>运维实用篇</h2><h3 id="打包与运行"><a href="#打包与运行" class="headerlink" title="打包与运行"></a>打包与运行</h3><ul><li>程序打包与运行（windows版）</li></ul><ol><li>springboot工程可以基于java环境下独立运行jar文件启动服务</li><li>springboot工程执行mvn命令package进行打包</li><li>执行jar命令：java -jar 工程名 .jar（要有打包插件）</li><li>spring-boot-maven-plugin插件作用</li></ol><ul><li>程序运行（Linux版）</li></ul><ol><li>基于Linux（CenterOS7）</li><li>安装JDK，且版本不低于打包时使用的JDK版本</li><li>安装包保存在/user/local/自定义目录中或$HOME下</li><li>其他操作参照Windows版进行</li></ol><h3 id="配置高级"><a href="#配置高级" class="headerlink" title="配置高级"></a>配置高级</h3><ul><li>临时属性设计</li></ul><ol><li>启动SpringBoot程序时，可以选择是否使用命令行属性为SpringBoot程序传递启动属性</li></ol><ul><li>配置文件分类</li></ul><ol><li>配置文件分为四种</li></ol><p>1）项目路径配置文件：服务于开发人员与测试</p><p>2）项目类路径config目录中配置文件：服务于项目经理整体调控</p><p>3）工程路径配置文件：服务于运维人员配置涉密线上环境</p><p>4）工程路径中config目录中配置文件：服务于运维经理整体调控</p><ol start="2"><li>多层级配置文件间的属性采用叠加并覆盖的形式作用于程序</li></ol><ul><li>自定义配置文件</li></ul><ol><li>重要说明</li></ol><p>1）单服务器项目：使用自定义配置文件需求较低</p><p>2）多服务器项目：使用自定义配置文件需求较高，将所有配置放在一个目录中，统一管理</p><p>3）基于springcloud技术，所有的服务器将不再设置配置文件，而是通过配置中心进行设定，动态加载配置信息</p><ol start="2"><li>配置文件可以修改名称，通过启动参数设定</li><li>配置文件可以修改路径，通过启动参数设定</li><li>微服务开发中配置文件通过配置中心进行设置</li></ol><ul><li>总结</li></ul><ol><li>springboot在开发和运行环境均支持使用临时参数修改工程配置</li><li>springboot支持4级配置文件，应用于开发与线上环境进行配置的灵活设置</li><li>springboot支持使用自定义配置问你件的形式修改配置文件存储位置</li><li>基于微服务开发时配置文件将使用配置中心进行管理<h3 id="多环境开发"><a href="#多环境开发" class="headerlink" title="多环境开发"></a>多环境开发</h3></li></ol><ul><li>多环境开发（YAML版）</li></ul><ol><li>多环境开发需要设置若干种常用环境，例如开发、生产、测试环境</li><li>yaml格式中设置多环境使用—区分环境设置边界</li><li>每种环境的区别在于加载的配置属性不同</li><li>启用某种环境时需要指定启动时使用该环境<br><img src="https://s2.loli.net/2021/12/29/AoG15VZj2wOfdEc.png"></li><li>多环境开发配置文件书写技巧（一）：</li></ol><p>1）主配置文件中设置公共配置（全局）</p><p>2）环境分类配置文件中常用于设置冲突属性（局部）</p><ol start="6"><li>推荐使用独立文件配置，便于线上系统维护更新并保障系统安全性</li></ol><ul><li>多环境开发（Properties版）</li></ul><ol><li>和yml一样，就是书写格式不同</li><li>properties文件多环境配置仅支持多文件格式</li><li>多环境开发独立配置文件书写技巧（二）<br><img src="https://s2.loli.net/2021/12/29/2xoz7gRvAFwrtYp.png"><br><img src="https://s2.loli.net/2021/12/29/gnEiGIRWHwUxqN5.png"></li><li>多环境开发使用group属性设置配置文件分组，便于线上维护管理</li></ol><ul><li>多环境开发控制</li></ul><ol><li>Maven与SpringBoot多环境兼容</li></ol><p>1）Maven中设置多环境属性</p><p>2） SpringBoot中引用Maven属性</p><pre><code>spring:    profiles:        active: @profiles.active@</code></pre><p>3）执行Maven打包指令，并在生成的boot打包文件，jar文件中查看对应信息</p><ol start="2"><li>当Maven与SpringBoot同时对多环境进行控制时，以Maven为主，SpringBoot使用@..@占位符读取Maven对应的配置属性</li><li>基于SpringBoot读取Maven配置属性的前提下，如果Idea下测试工程时pom.xml每次更新需要手动compile方可生效<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3></li></ol><ul><li>日志基础</li></ul><ol><li>日志的作用：编程期调试代码、运营期记录信息</li><li>日志的级别</li></ol><p>1） TRACE：运行堆栈信息，使用率低</p><p>2）DEBUG：程序员调试代码使用</p><p>3）INFO：记录运维过程数据</p><p>4）WARN：记录运维过程报警数据</p><p>5）ERROR：记录错误堆栈信息</p><p>6）FATAL：灾难信息，合并计入ERROR</p><ol start="2"><li>设置日志输出级别<br><img src="https://s2.loli.net/2021/12/30/rCemYJVEaXWPpS4.png"></li><li>设置日志组，控制指定包对应的日志输出级别，也可以直接控制指定包对应的日志输出级别<br><img src="https://s2.loli.net/2021/12/30/KDYZN3XfAank19g.png"></li><li>可以基于lombok提供的@slf4j注解为类快速添加日志对象</li></ol><ul><li><p>日志输出格式控制<br><img src="https://s2.loli.net/2021/12/30/UVLANdsuSCo2Ich.png"><br><img src="https://s2.loli.net/2021/12/30/vLEiPOfdyD2hxC3.png"></p></li><li><p>日志文件<br><img src="https://s2.loli.net/2021/12/30/drEGw1P9umzUKBC.png"></p></li></ul><h2 id="开发实用篇"><a href="#开发实用篇" class="headerlink" title="开发实用篇"></a>开发实用篇</h2><h3 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h3><h3 id="配置高级-1"><a href="#配置高级-1" class="headerlink" title="配置高级"></a>配置高级</h3><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h3 id="数据层解决方案"><a href="#数据层解决方案" class="headerlink" title="数据层解决方案"></a>数据层解决方案</h3><h3 id="整合第三方技术"><a href="#整合第三方技术" class="headerlink" title="整合第三方技术"></a>整合第三方技术</h3><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><h1 id="原理篇"><a href="#原理篇" class="headerlink" title="原理篇"></a>原理篇</h1><h1 id="番外篇"><a href="#番外篇" class="headerlink" title="番外篇"></a>番外篇</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SpringBoot系统自学&quot;&gt;&lt;a href=&quot;#SpringBoot系统自学&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot系统自学&quot;&gt;&lt;/a&gt;SpringBoot系统自学&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>新找到了一个自学网站（》-《）</title>
    <link href="http://example.com/2021/12/09/%E9%9A%8F%E7%AC%9402/"/>
    <id>http://example.com/2021/12/09/%E9%9A%8F%E7%AC%9402/</id>
    <published>2021-12-09T09:09:00.000Z</published>
    <updated>2021-12-04T09:10:26.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="https-www-r2coding-com-README"><a href="#https-www-r2coding-com-README" class="headerlink" title="https://www.r2coding.com/#/README"></a><a href="https://www.r2coding.com/#/README">https://www.r2coding.com/#/README</a></h1><p>纯静态，简捷好用，给作者点赞</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;https-www-r2coding-com-README&quot;&gt;&lt;a href=&quot;#https-www-r2coding-com-README&quot; class=&quot;headerlink&quot; title=&quot;https://www.r2coding.com/#/README&quot;</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Scala</title>
    <link href="http://example.com/2021/11/05/scala/"/>
    <id>http://example.com/2021/11/05/scala/</id>
    <published>2021-11-05T13:31:00.000Z</published>
    <updated>2021-11-09T13:48:27.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h1><span id="more"></span><h1 id="Scala0"><a href="#Scala0" class="headerlink" title="Scala0"></a>Scala0</h1><p><img src="https://s3.bmp.ovh/imgs/2021/11/41dc2e3ba13cee19.jpg"></p><h1 id="Scala1"><a href="#Scala1" class="headerlink" title="Scala1"></a>Scala1</h1><p><img src="https://s3.bmp.ovh/imgs/2021/11/f34050bf7a62ca74.jpg"></p><h1 id="Scala2"><a href="#Scala2" class="headerlink" title="Scala2"></a>Scala2</h1><p><img src="https://s3.bmp.ovh/imgs/2021/11/972404eea3100cec.jpg"></p><h1 id="Scala3"><a href="#Scala3" class="headerlink" title="Scala3"></a>Scala3</h1><p><img src></p><h1 id="Scala4"><a href="#Scala4" class="headerlink" title="Scala4"></a>Scala4</h1><p><img src></p><h1 id="Scala5"><a href="#Scala5" class="headerlink" title="Scala5"></a>Scala5</h1><p><img src></p><h1 id="Scala6"><a href="#Scala6" class="headerlink" title="Scala6"></a>Scala6</h1><p><img src></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Scala&quot;&gt;&lt;a href=&quot;#Scala&quot; class=&quot;headerlink&quot; title=&quot;Scala&quot;&gt;&lt;/a&gt;Scala&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hive</title>
    <link href="http://example.com/2021/11/02/Hive/"/>
    <id>http://example.com/2021/11/02/Hive/</id>
    <published>2021-11-02T03:41:00.000Z</published>
    <updated>2021-11-09T13:48:20.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h1><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Hive&quot;&gt;&lt;a href=&quot;#Hive&quot; class=&quot;headerlink&quot; title=&quot;Hive&quot;&gt;&lt;/a&gt;Hive&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hadoop</title>
    <link href="http://example.com/2021/10/26/hadoop/"/>
    <id>http://example.com/2021/10/26/hadoop/</id>
    <published>2021-10-26T11:34:00.000Z</published>
    <updated>2021-11-11T02:27:43.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h1><span id="more"></span><h1 id="大数据概论"><a href="#大数据概论" class="headerlink" title="大数据概论"></a>大数据概论</h1><p><img src="https://i.loli.net/2021/11/04/WLtSfnUDN4svF3I.jpg"></p><h1 id="Hadoop-入门"><a href="#Hadoop-入门" class="headerlink" title="Hadoop(入门)"></a>Hadoop(入门)</h1><p><img src="https://i.loli.net/2021/11/04/Xh3W65bwQDrJSyM.jpg"><br><img src="https://i.loli.net/2021/11/04/3O687NJAanIpuj9.jpg"></p><h1 id="Hadoop（HDFS）"><a href="#Hadoop（HDFS）" class="headerlink" title="Hadoop（HDFS）"></a>Hadoop（HDFS）</h1><p><img src="https://i.loli.net/2021/11/04/tYsieAWwSQ31uqC.jpg"></p><h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><p><img src="https://s3.bmp.ovh/imgs/2021/11/6106cb1e993211e2.jpg"><br><img src="https://i.loli.net/2021/11/09/ZoyiwWsgx5C6Kkp.jpg"><br><img src="https://s3.bmp.ovh/imgs/2021/11/cf205720d320429d.jpg"></p><h1 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h1><p><img src="https://i.loli.net/2021/11/11/Vvols5DWEGCZjJI.jpg"><br><img src="https://i.loli.net/2021/11/11/jLEMRznZOyNgJ7U.jpg"></p><h1 id="尚硅谷大数据技术之Hadoop（生产调优手册）"><a href="#尚硅谷大数据技术之Hadoop（生产调优手册）" class="headerlink" title="尚硅谷大数据技术之Hadoop（生产调优手册）"></a>尚硅谷大数据技术之Hadoop（生产调优手册）</h1><p><img src="https://s3.bmp.ovh/imgs/2021/11/4f448881a24f8820.jpg"><br><img src="https://i.loli.net/2021/11/11/KwWmLSivJ7AtuTx.jpg"></p><h1 id="尚硅谷大数据技术之Hadoop源码解析"><a href="#尚硅谷大数据技术之Hadoop源码解析" class="headerlink" title="尚硅谷大数据技术之Hadoop源码解析"></a>尚硅谷大数据技术之Hadoop源码解析</h1><p><img src="https://s3.bmp.ovh/imgs/2021/11/e325fce5ec64b3a0.jpg"><br><img src="https://i.loli.net/2021/11/11/GUPBFyHauMsoSZJ.jpg"><br><img src="https://s3.bmp.ovh/imgs/2021/11/60685ff9bc4a2cd5.jpg"><br><img src="https://s3.bmp.ovh/imgs/2021/11/2debb48ad8316dee.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Hadoop&quot;&gt;&lt;a href=&quot;#Hadoop&quot; class=&quot;headerlink&quot; title=&quot;Hadoop&quot;&gt;&lt;/a&gt;Hadoop&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Mybatis</title>
    <link href="http://example.com/2021/10/16/mybatis/"/>
    <id>http://example.com/2021/10/16/mybatis/</id>
    <published>2021-10-16T09:38:00.000Z</published>
    <updated>2021-11-17T13:43:07.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><span id="more"></span><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><ol><li>三层架构<ul><li>界面层： 和用户打交道的， 接收用户的请求参数， 显示处理结果的。（jsp ，html ，servlet）<br>业务逻辑层： 接收了界面层传递的数据，计算逻辑，调用数据库，获取数据<br>数据访问层： 就是访问数据库， 执行对数据的查询，修改，删除等等的。</li></ul></li></ol><pre><code> * 三层对应的包   界面层： controller包 （servlet）   业务逻辑层： service 包（XXXService类）   数据访问层： dao包（XXXDao类） * 三层中类的交互   用户使用界面层--&gt; 业务逻辑层---&gt;数据访问层（持久层）--&gt;数据库（mysql）  * 三层对应的处理框架   界面层---servlet---springmvc（框架）   业务逻辑层---service类--spring（框架）   数据访问层---dao类--mybatis（框架）</code></pre><ol start="2"><li></li></ol><ul><li><p>框架<br>框架是一个舞台， 一个模版</p></li><li><p>模版：</p><ol><li>规定了好一些条款，内容。</li><li>加入自己的东西</li></ol></li><li><p>框架是一个模块</p></li></ul><pre><code>1.框架中定义好了一些功能。这些功能是可用的。2.可以加入项目中自己的功能， 这些功能可以利用框架中写好的功能。</code></pre><ul><li><p>框架是一个软件，半成品的软件，定义好了一些基础功能， 需要加入你的功能就是完整的。<br>基础功能是可重复使用的，可升级的。</p></li><li><p>框架特点：</p></li></ul><pre><code>1. 框架一般不是全能的， 不能做所有事情2. 框架是针对某一个领域有效。 特长在某一个方面，比如mybatis做数据库操作强，但是他不能做其它的。3. 框架是一个软件</code></pre><ul><li><p>mybatis框架</p><p>一个框架，早期叫做ibatis,  代码在github。<br>mybatis是 MyBatis SQL Mapper Framework for Java （sql映射框架）</p><p>1）sql mapper :sql映射</p><pre><code>  可以把数据库表中的一行数据  映射为 一个java对象。</code></pre><p>  一行数据可以看做是一个java对象。操作这个对象，就相当于操作表中的数据</p></li></ul><p>   2） Data Access Objects（DAOs） : 数据访问 ， 对数据库执行增删改查。</p><p> mybatis提供了哪些功能：</p><ol><li><p>提供了创建Connection ,Statement, ResultSet的能力 ，不用开发人员创建这些对象了</p></li><li><p>提供了执行sql语句的能力， 不用你执行sql</p></li><li><p>提供了循环sql， 把sql的结果转为java对象， List集合的能力</p><p>   while (rs.next()) {</p><pre><code>   Student stu = new Student();   stu.setId(rs.getInt(&quot;id&quot;));   stu.setName(rs.getString(&quot;name&quot;));   stu.setAge(rs.getInt(&quot;age&quot;));   //从数据库取出数据转为 Student 对象，封装到 List 集合   stuList.add(stu);</code></pre><p>   }</p></li><li><p>提供了关闭资源的能力，不用你关闭Connection, Statement, ResultSet</p></li></ol><ul><li><p>开发人员做的是： 提供sql语句</p></li><li><p>最后是： 开发人员提供sql语句–mybatis处理sql—开发人员得到List集合或java对象（表中的数据）</p></li><li><p>总结：</p></li></ul><p>  mybatis是一个sql映射框架，提供的数据库的操作能力。增强的JDBC,</p><p>  使用mybatis让开发人员集中精神写sql就可以了，不必关心Connection,Statement,ResultSet的创建，销毁，sql的执行。 </p><h2 id="第二章："><a href="#第二章：" class="headerlink" title="第二章："></a>第二章：</h2><p>  1 主要类的介绍</p><p>   1） Resources： mybatis中的一个类， 负责读取主配置文件</p><pre><code>  InputStream in = Resources.getResourceAsStream(&quot;mybatis.xml&quot;);2)SqlSessionFactoryBuilder : 创建SqlSessionFactory对象，      SqlSessionFactoryBuilder builder  = new SqlSessionFactoryBuilder();    //创建SqlSessionFactory对象    SqlSessionFactory factory = builder.build(in);</code></pre><p>  3）SqlSessionFactory ： 重量级对象， 程序创建一个对象耗时比较长，使用资源比较多。<br>        在整个项目中，有一个就够用了。</p><pre><code> SqlSessionFactory:接口  ， 接口实现类： DefaultSqlSessionFactory  SqlSessionFactory作用： 获取SqlSession对象。SqlSession sqlSession = factory.openSession();  openSession()方法说明：   1. openSession() ：无参数的， 获取是非自动提交事务的SqlSession对象    2. openSession(boolean): openSession(true)  获取自动提交事务的SqlSession.                              openSession(false)  非自动提交事务的SqlSession对象</code></pre><p> 4)SqlSession:<br>   SqlSession接口 ：定义了操作数据的方法 例如 selectOne() ,selectList() ,insert(),update(), delete(), commit(), rollback()<br>   SqlSession接口的实现类DefaultSqlSession。</p><pre><code>使用要求： SqlSession对象不是线程安全的，需要在方法内部使用， 在执行sql语句之前，使用openSession()获取SqlSession对象。在执行完sql语句后，需要关闭它，执行SqlSession.close(). 这样能保证他的使用是线程安全的。</code></pre><p>第三章：</p><ol><li><p>动态代理： 使用SqlSession.getMapper(dao接口.class) 获取这个dao接口的对象</p></li><li><p>传入参数： 从java代码中把数据传入到mapper文件的sql语句中。<br>1）parameterType ： 写在mapper文件中的 一个属性。 表示dao接口中方法的参数的数据类型。</p><pre><code>例如StudentDao接口 public Student  selectStudentById(Integer id) </code></pre><ol start="2"><li>一个简单类型的参数：<br>简单类型： mybatis把java的基本数据类型和String都叫简单类型。<br>在mapper文件获取简单类型的一个参数的值，使用 #{任意字符}</li></ol><p> 接口：public Student  selectStudentById(Integer id)<br> mapper:select id,name, email,age from student where id=#{studentId}</p></li></ol><pre><code>3) 多个参数，使用@Param命名参数  接口 public List&lt;Student&gt; selectMulitParam(@Param(&quot;myname&quot;) String name, @Param(&quot;myage&quot;) Integer age)  使用  @Param(&quot;参数名&quot;)  String name  mapper文件：     &lt;select&gt;         select * from student where name=#&#123;myname&#125; or age=#&#123;myage&#125;      &lt;/select&gt;4) 多个参数，使用java对象   语法 #&#123;属性名&#125;</code></pre><p>   vo: value object , 放一些存储数据的类。比如说 提交请求参数， name ,age<br>         现在想把name ,age 传给一个service 类。</p><p>   vo: view object , 从servlet把数据返回给浏览器使用的类，表示显示结果的类。</p><p>   pojo: 普通的有set， get方法的java类。 普通的java对象</p><pre><code>      Servlet --- StudentService( addStudent( MyParam  param)  )</code></pre><p>   entity（domain域）: 实体类， 和数据库中的表对应的类， </p><pre><code>5) # 和  $  select id,name, email,age from student where id=#&#123;studentId&#125;  # 的结果： select id,name, email,age from student where id=?    select id,name, email,age from student where id=$&#123;studentId&#125;  $ 的结果：select id,name, email,age from student where id=1001  String sql=&quot;select id,name, email,age from student where id=&quot; + &quot;1001&quot;;  使用的Statement对象执行sql， 效率比PreparedStatement低。  $:可以替换表名或者列名， 你能确定数据是安全的。可以使用$  # 和 $区别  1. #使用 ？在sql语句中做站位的， 使用PreparedStatement执行sql，效率高  2. #能够避免sql注入，更安全。  3. $不使用占位符，是字符串连接方式，使用Statement对象执行sql，效率低  4. $有sql注入的风险，缺乏安全性。  5. $:可以替换表名或者列名</code></pre><ol start="3"><li><p>mybatis的输出结果<br>mybatis执行了sql语句，得到java对象。</p><p> 1）resultType结果类型， 指sql语句执行完毕后， 数据转为的java对象， java类型是任意的。<br>   resultType结果类型的它值 1. 类型的全限定名称   2. 类型的别名， 例如 java.lang.Integer别名是int</p><pre><code>处理方式：   1. mybatis执行sql语句， 然后mybatis调用类的无参数构造方法，创建对象。    2. mybatis把ResultSet指定列值付给同名的属性。</code></pre></li></ol><pre><code>        &lt;select id=&quot;selectMultiPosition&quot; resultType=&quot;com.bjpowernode.domain.Student&quot;&gt;      select id,name, email,age from student    &lt;/select&gt;      对等的jdbc      ResultSet rs = executeQuery(&quot; select id,name, email,age from student&quot; )      while(rs.next())&#123;           Student  student = new Student();                student.setId(rs.getInt(&quot;id&quot;));                student.setName(rs.getString(&quot;name&quot;))      &#125;</code></pre><ol start="2"><li>定义自定义类型的别名<br> 1）在mybatis主配置文件中定义，使<typeAlias>定义别名<br>  2）可以在resultType中使用自定义别名</typeAlias></li></ol><p>   3）resultMap:结果映射， 指定列名和java对象的属性对应关系。<br>        1）你自定义列值赋值给哪个属性<br>         2）当你的列名和属性名不一样时，一定使用resultMap</p><pre><code>     resultMap和resultType不要一起用，二选一</code></pre><h2 id="第四章动态sql"><a href="#第四章动态sql" class="headerlink" title="第四章动态sql"></a>第四章动态sql</h2><pre><code>动态sql: sql的内容是变化的，可以根据条件获取到不同的sql语句。        主要是where部分发生变化。动态sql的实现，使用的是mybatis提供的标签， &lt;if&gt; ,&lt;where&gt;,&lt;foreach&gt;1)&lt;if&gt;是判断条件的，语法&lt;if test=&quot;判断java对象的属性值&quot;&gt;            部分sql语句        &lt;/if&gt;2)&lt;where&gt; 用来包含 多个&lt;if&gt;的， 当多个if有一个成立的， &lt;where&gt;会自动增加一个where关键字，            并去掉 if中多余的 and ，or等。3）&lt;foreach&gt; 循环java中的数组，list集合的。 主要用在sql的in语句中。    学生id是 1001,1002,1003的三个学生    select * from student where id in (1001,1002,1003)    public List&lt;Student&gt; selectFor(List&lt;Integer&gt; idlist)    List&lt;Integer&gt; list = new ...    list.add(1001);    list.add(1002);    list.add(1003);    dao.selectFor(list)    &lt;foreach collection=&quot;&quot; item=&quot;&quot; open=&quot;&quot; close=&quot;&quot; separator=&quot;&quot;&gt;            #&#123;xxx&#125;    &lt;/foreach&gt;    collection:表示接口中的方法参数的类型， 如果是数组使用array , 如果是list集合使用list    item:自定义的，表示数组和集合成员的变量    open:循环开始是的字符    close:循环结束时的字符    separator:集合成员之间的分隔符4）sql代码片段， 就是复用一些语法    步骤    1.先定义 &lt;sql id=&quot;自定义名称唯一&quot;&gt;  sql语句， 表名，字段等 &lt;/sql&gt;    2.再使用， &lt;include refid=&quot;id的值&quot; /&gt;</code></pre><h2 id="第五章："><a href="#第五章：" class="headerlink" title="第五章："></a>第五章：</h2><pre><code>1. 数据库的属性配置文件： 把数据库连接信息放到一个单独的文件中。 和mybatis主配置文件分开。    目的是便于修改，保存，处理多个数据库的信息。    1）在resources目录中定义一个属性配置文件， xxxx.properties ,例如 jdbc.properties        在属性配置文件中， 定义数据，格式是 key=value         key： 一般使用 . 做多级目录的。        例如 jdbc.mysql.driver    , jdbc.driver, mydriver        jdbc.driver=com.mysql.jdbc.Driver        jdbc.url=jdbc:mysql//.....        jdbc.username=root        jdbc.password=123456            2）在mybatis的主配置文件，使用&lt;property&gt; 指定文件的位置        在需要使用值的地方， $&#123;key&#125;2.mapper文件，使用package指定路径    &lt;mappers&gt;            &lt;!--第二种方式： 使用包名            name: xml文件（mapper文件）所在的包名, 这个包中所有xml文件一次都能加载给mybatis            使用package的要求：            1. mapper文件名称需要和接口名称一样， 区分大小写的一样            2. mapper文件和dao接口需要在同一目录        --&gt;        &lt;package name=&quot;com.bjpowernode.dao&quot;/&gt;    &lt;/mappers&gt;</code></pre><p>第六章：PageHelper</p><p> PageHelper做数据分页的。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Mybatis&quot;&gt;&lt;a href=&quot;#Mybatis&quot; class=&quot;headerlink&quot; title=&quot;Mybatis&quot;&gt;&lt;/a&gt;Mybatis&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>SpringBoot</title>
    <link href="http://example.com/2021/10/13/springboot/"/>
    <id>http://example.com/2021/10/13/springboot/</id>
    <published>2021-10-13T01:34:00.000Z</published>
    <updated>2021-10-28T01:37:48.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><span id="more"></span><h1 id="在项目中学习："><a href="#在项目中学习：" class="headerlink" title="在项目中学习："></a>在项目中学习：</h1><p>D:\暴富小队项目相关</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SpringBoot&quot;&gt;&lt;a href=&quot;#SpringBoot&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot&quot;&gt;&lt;/a&gt;SpringBoot&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Maven(这篇非自己整理)</title>
    <link href="http://example.com/2021/10/09/Maven/"/>
    <id>http://example.com/2021/10/09/Maven/</id>
    <published>2021-10-09T11:55:00.000Z</published>
    <updated>2021-10-09T11:59:27.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Maven-这篇非自己整理"><a href="#Maven-这篇非自己整理" class="headerlink" title="Maven(这篇非自己整理)"></a>Maven(这篇非自己整理)</h1><span id="more"></span><h1 id="转自："><a href="#转自：" class="headerlink" title="转自："></a>转自：</h1><p><a href="https://www.bilibili.com/video/BV1x5411P7Hh?p=2&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1x5411P7Hh?p=2&amp;spm_id_from=pageDriver</a></p><h1 id="《《文章很长，目录在右下角》》"><a href="#《《文章很长，目录在右下角》》" class="headerlink" title="《《文章很长，目录在右下角》》"></a>《《文章很长，目录在右下角》》</h1><h1 id="第一章-Maven简介"><a href="#第一章-Maven简介" class="headerlink" title="第一章 Maven简介"></a>第一章 Maven简介</h1><h2 id="1-1-软件开发中的阶段"><a href="#1-1-软件开发中的阶段" class="headerlink" title="1.1 软件开发中的阶段"></a>1.1 软件开发中的阶段</h2><p>需要分析： 分析项目具体完成的功能，有什么要求， 具体怎么实现。</p><p>设计阶段：根据分析的结果， 设计项目的使用什么技术， 解决难点。</p><p>开发阶段：编码实现功能。 编译代码。自我测试</p><p>测试阶段：专业的测试人员，测整个项目的功能十分符合设计要求。出一个测试报告。</p><p>项目的打包，发布阶段： 给用户安装项目</p><h2 id="1-2-Maven能做什么"><a href="#1-2-Maven能做什么" class="headerlink" title="1.2 Maven能做什么"></a>1.2 Maven能做什么</h2><p>1）项目的自动构建，帮助开发人员做项目代码的编译，测试， 打包，安装，部署等工作。</p><p>2）管理依赖（管理项目中使用的各种jar包）。</p><p>​      依赖：项目中需要使用的其他资源，  常见的是jar 。 比如项目要使用mysql驱动。我们就说项目依赖mysql驱动。</p><h2 id="1-3-没有使用maven怎么管理依赖"><a href="#1-3-没有使用maven怎么管理依赖" class="headerlink" title="1.3 没有使用maven怎么管理依赖"></a>1.3 没有使用maven怎么管理依赖</h2><p>管理jar ，需要从网络中单独下载某个jar </p><p>需要选择正确版本</p><p>手工处理jar文件之间的依赖。 a.jar里面要使用b.jar的类。</p><h2 id="1-4-什么是maven"><a href="#1-4-什么是maven" class="headerlink" title="1.4 什么是maven"></a>1.4 什么是maven</h2><p>maven是apache基金会的开源项目，使用java语法开发。 Maven 这个单词的本意是：专家，内行。读音是[‘meɪv(ə)n]  或  [‘mevn]。</p><p>maven是项目的自动化构建工具。 管理项目的依赖。</p><h2 id="1-5-maven中的概念"><a href="#1-5-maven中的概念" class="headerlink" title="1.5 maven中的概念"></a>1.5 maven中的概念</h2><p>①POM<br>②约定的目录结构<br>③坐标<br>④依赖管理<br>⑤仓库管理<br>⑥生命周期<br>⑦插件和目标<br>⑧继承<br>⑨聚合</p><h2 id="1-6-maven工具的获取和安装"><a href="#1-6-maven工具的获取和安装" class="headerlink" title="1.6 maven工具的获取和安装"></a>1.6 maven工具的获取和安装</h2><p>地址： <a href="http://maven.apache.org/">http://maven.apache.org/</a>  从中下载  .zip文件。 使用的 apache-maven-3.3.9-bin.zip</p><p>安装：</p><ol><li><p>确定JAVA_HOME 指定jdk的安装目录， 如果没有JAVA_HOME， 需要在windows的环境变量中创建JAVA_HOME, 它的值是jdk的安装目录</p></li><li><p>解压缩  apache-maven-3.3.9-bin.zip ，把解压后的文件放到一个目录中。 </p><p>目录的路径不要有中文， 不要有空格。</p></li><li><p>把maven安装目录中下的bin的路径添加到path中</p></li><li><p>测试maven的安装。 在命令行执行 mvn     -v</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\NING MEI&gt;mvn -v</span><br><span class="line">Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)</span><br><span class="line">Maven home: D:\tools\apache-maven-3.3.9\bin\..</span><br><span class="line">Java version: 1.8.0_101, vendor: Oracle Corporation</span><br><span class="line">Java home: C:\Program Files\Java\jdk1.8.0_101\jre</span><br><span class="line">Default locale: zh_CN, platform encoding: GBK</span><br><span class="line">OS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;dos&quot;</span><br></pre></td></tr></table></figure></li></ol><p>maven解压后的目录结构</p><p><img src="images/image-20201015162301261.png" alt="image-20201015162301261">    </p><p>maven的其他安装方式：</p><ol><li><p>确定JAVA_HOME是否有效</p></li><li><p>在环境变量中，创建一个叫做M2_HOME (或者MAVEN_HOME) ，它的值是maven的安装目录</p><p>M2_HOME=D:\tools\apache-maven-3.3.9</p></li><li><p>在path环境变量中，加入 %M2_HOME%\bin    </p></li><li><p>测试maven的安装，在命令行执行 mvn  -v</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\NING MEI&gt;mvn -v</span><br><span class="line">Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)</span><br><span class="line">Maven home: D:\tools\apache-maven-3.3.9\bin\..</span><br><span class="line">Java version: 1.8.0_101, vendor: Oracle Corporation</span><br><span class="line">Java home: C:\Program Files\Java\jdk1.8.0_101\jre</span><br><span class="line">Default locale: zh_CN, platform encoding: GBK</span><br><span class="line">OS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;dos&quot;</span><br></pre></td></tr></table></figure></li></ol><h1 id="第二章Maven的核心概念"><a href="#第二章Maven的核心概念" class="headerlink" title="第二章Maven的核心概念"></a>第二章Maven的核心概念</h1><h2 id="2-1-约定的目录结构"><a href="#2-1-约定的目录结构" class="headerlink" title="2.1 约定的目录结构"></a>2.1 约定的目录结构</h2><p>maven项目使用的大多人 遵循的目录结构。 叫做约定的目录结构。</p><p>一个maven项目是一个文件夹。 比如项目叫做Hello</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Hello 项目文件夹</span><br><span class="line">    \src</span><br><span class="line">    \main叫做主程序目录（完成项目功能的代码和配置文件）</span><br><span class="line">             \java          源代码（包和相关的类定义）</span><br><span class="line">     \resources    配置文件</span><br><span class="line">    \test               放置测试程序代码的（开发人员自己写的测试代码）</span><br><span class="line">     \java          测试代码的（junit）</span><br><span class="line">     \resources     测试程序需要的配置文件</span><br><span class="line">    \pom.xml                maven的配置文件， 核心文件</span><br></pre></td></tr></table></figure><p>maven的使用方式：</p><p>1）maven可以独立使用： 创建项目，编译代码，测试程序，打包，部署等等</p><p>2）maven和idea一起使用：通过idea借助maven，实现编码，测试，打包等等</p><h2 id="2-2-POM"><a href="#2-2-POM" class="headerlink" title="2.2 POM"></a>2.2 POM</h2><p>POM： Project Object Model 项目对象模型， maven把项目当做模型处理。 操作这个模型就是操作项目。</p><p>maven通过pom.xml文件实现 项目的构建和依赖的管理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- project是根标签， 后面的是约束文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="comment">&lt;!-- pom模型的版本， 就是4.0.0 --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 坐标 --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ch01-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-3-坐标"><a href="#2-3-坐标" class="headerlink" title="2.3 坐标"></a>2.3 坐标</h2><p>坐标组成是 groupid, artifiactId, version。  坐标概念来自数学。·</p><p>坐标作用：确定资源的，是资源的唯一标识。 在maven中，每个资源都是坐标。 坐标值是唯一的。简称叫gav</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ch01-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">groupId: 组织名称，代码。 公司，团体或者单位的标识。 这个值常使用的公司域名的倒写。</span><br><span class="line">         例如：学校的网站 www.bjpowernode.com, groupId: com.bjpowernode</span><br><span class="line"></span><br><span class="line">         如果项目规模比较大， 也可以是 域名倒写+大项目名称。</span><br><span class="line">     例如： www.baidu.com ,  无人车： com.baidu.appollo</span><br><span class="line">artifactId:项目名称， 如果groupId中有项目， 此时当前的值就是子项目名。 项目名称是唯一的。</span><br><span class="line">version：版本， 项目的版本号， 使用的数字。 三位组成。 例如 主版本号.次版本号.小版本号， 例如： 5.2.5。</span><br><span class="line">         注意：版本号中有-SNAPSHOT， 表示快照，不是稳定的版本。      </span><br><span class="line">   </span><br><span class="line">packaging 项目打包的类型， 有jar ，war， ear， pom等等 默认是jar</span><br></pre></td></tr></table></figure><p>项目使用gav：</p><p>1.每个maven项目，都需要有一个自己的gav</p><p>2.管理依赖，需要使用其他的jar ，也需要使用gav作为标识。</p><p>搜索坐标的地址： <a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p><h2 id="2-4-依赖-dependency"><a href="#2-4-依赖-dependency" class="headerlink" title="2.4 依赖 dependency"></a>2.4 依赖 dependency</h2><p>依赖：项目中要使用的其他资源（jar）。  </p><p>需要使用maven表示依赖，管理依赖。 通过使用dependency和gav一起完成依赖的使用</p><p>需要在pom.xml文件中，使用dependencies 和dependency， 还有gav 完成依赖的说明。</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- mysql驱动 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">maven使用gav作为标识，从互联网下载依赖的jar。 下载到你的本机上。  由maven管理项目使用的这些jar</span><br></pre></td></tr></table></figure><h2 id="2-5-仓库"><a href="#2-5-仓库" class="headerlink" title="2.5 仓库"></a>2.5 仓库</h2><p>仓库是存东西的，maven的仓库存放的是：</p><ol><li><p>maven工具自己的jar包。</p></li><li><p>第三方的其他jar， 比如项目中要使用mysql驱动。</p></li><li><p>自己写的程序，可以打包为jar 。 存放到仓库。</p></li></ol><p>仓库的分类：</p><ol><li><p>本地仓库（本机仓库）： 位于你自己的计算机， 它是磁盘中的某个目录。</p><p>本地仓库：默认路径，是你登录操作系统的账号的目录中/.m2/repository</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\NING MEI\.m2\repository</span><br></pre></td></tr></table></figure><p>修改本地仓库的位置：修改maven工具的配置文件（maven的安装路径\conf\setting.xml）</p><p>​    步骤：</p><p>​     1）创建一个目录，作为仓库使用。  目录不要有中文和空格。 目录不要太深。</p><p>​           例如： D:\openrepository</p><p>​     2）修改setting.xml文件，指定 D:\openrepository这个目录</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:/openrepository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    3) 把我给你提供的 仓库的资源 拷贝到 D:/openrepository</p></li><li><p>远程仓库： 需要通过联网访问的</p><p>1）中央仓库： 一个ftp服务器， 存放了所有的资源。 </p><p>2）中央仓库的镜像： 就是中央仓库的拷贝。 在各大主要城市都有镜像。</p><p>3）私服：在局域网中使用的。 私服就是自己的仓库服务器。 在公司内部使用的。</p></li></ol><p>maven使用仓库： maven自动使用仓库， 当项目启动后， 执行了maven的命令， maven首先访问的是本地仓库， 从仓库中获取所需的jar， 如果本地仓库没有 ，需要访问私服或者中央仓库或者镜像。</p><p><img src="images/image-20201016114322189.png" alt="image-20201016114322189">    </p><h2 id="2-6-maven的生命周期，插件和命令"><a href="#2-6-maven的生命周期，插件和命令" class="headerlink" title="2.6 maven的生命周期，插件和命令"></a>2.6 maven的生命周期，插件和命令</h2><p>maven的生命周期： 项目构建的各个阶段。 包括 清理， 编译， 测试，报告，打包，安装，部署</p><p>插件：要完成构建项目的各个阶段，要使用maven的命令， 执行命令的功能是通过插件完成的。插件就是jar，一些类。</p><p>命令： 执行maven功能是 由命令发出的。 比如 mvn compile</p><p>单元测试（junit）：</p><p>junit是一个单元测试的工具， 在java中经常使用。</p><p>单元：在java中指的是方法。  一个方法就是一个单元， 方法是测试的最小单位。</p><p>作用：使用junit去测试方法是否完成了要求。 开发人员自测。</p><p>使用单元测试：</p><p>1）加入junit的依赖（一些类和方法）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2)在src/test/java 目录中创建测试类文件。 写测试代码</p><p>   单元测试使用的建议：</p><p>​    1.测试类的定义， 名称一般是Test+要测试的类名称</p><p>​    2.测试类它的包名和要测试的类包名一样。</p><p>​    3.在类中定义方法，要测试代码。</p><p>​       方法的定义：public方法， </p><p>​                               没有返回值</p><p>​                               方法名称自定义（建议 Test+测试的方法名称）</p><p>​                               方法没有参数</p><p>   4.在测试类中的方法，可以单独执行。 测试类也可以单独执行</p><p>   5.在方法的上面加入@Test</p><p>命令：</p><p>1） mvn clean: 清理命令， 作用删除以前生成的数据， 删除target目录。</p><p>​      插件： maven-clean-plugin   ， 版本是 2.5</p><p>2）mvn compile:编译命令，执行的代码编译， 把src/main/java目录中的java代码编译为class文件。</p><p>​     同时把class文件拷贝到 target/classes目录。 这个目录classes是存放类文件的根目录（也叫做类路径，classpath）</p><p>​    插件： maven-compiler-plugin 版本3.1。  编译代码的插件</p><p>​                maven-resources-plugin 版本2.6 。 资源插件， 处理文件的。 作用是把src/main/resources目录中的                </p><p>​                                                             文件拷贝target/classes目录中。</p><p>3）mvn test-compile: 编译命令， 编译src/test/java目录中的源文件， 把生成的class拷贝到target/test-classes目录。同时把src/test/resources目录中的文件拷贝到 test-clasess目录</p><p>​    插件： maven-compiler-plugin 版本3.1。  编译代码的插件</p><p>​                maven-resources-plugin 版本2.6 。 资源插件， 处理文件的</p><p>4）mvn test:测试命令， 作用执行 test-classes目录的程序， 测试src/main/java目录中的主程序代码是否符合要求。</p><p>​     插件： maven-surefire-plugin 版本 2.12.4</p><p>5）mvn package:打包，作用是把项目中的资源class文件和配置文件都放到一个压缩文件中， 默认压缩文件是jar类型的。 web应用是war类型， 扩展是jar，war的。</p><p>​    插件：maven-jar-plugin 版本 2.4。 执行打包处理。 生成一个jar扩展的文件， 放在target目录下.</p><p>​               打包的文件包含的是 src/main目录中的所有的生成的class和配置文件和test无关。</p><p>​    生成的是 ch01-maven-1.0-SNAPSHOT.jar</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ch01-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">打包的文件名： artifactId-version.packaging</span><br></pre></td></tr></table></figure><p>6）mvn install : 把生成的打包的文件 ，安装到maven仓库。</p><p>​     插件： maven-install-plugin 版本 2.4 。 把生成的jar文件安装到本地仓库。 </p><p>​    查看查看中的jar文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ch01-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">groupId中的值， 如果有 &quot;.&quot; 前和后都是独立的文件夹。 com\bjpowernode</span><br><span class="line">artifactId, 独立的文件夹</span><br><span class="line">version，独立的文件夹</span><br></pre></td></tr></table></figure><h2 id="2-7-自定义配置插件"><a href="#2-7-自定义配置插件" class="headerlink" title="2.7 自定义配置插件"></a>2.7 自定义配置插件</h2><p>在pom.xml文件中， build标签中。设置插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置构建项目相关的内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span> <span class="comment">&lt;!-- 指定编译代码的jdk版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span> <span class="comment">&lt;!-- 运行java程序使用的jdk版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span> </span><br></pre></td></tr></table></figure><h1 id="第三章-Maven和idea的集成"><a href="#第三章-Maven和idea的集成" class="headerlink" title="第三章 Maven和idea的集成"></a>第三章 Maven和idea的集成</h1><h2 id="3-1-idea中集成maven"><a href="#3-1-idea中集成maven" class="headerlink" title="3.1 idea中集成maven"></a>3.1 idea中集成maven</h2><p>idea中有一个自带的maven。  我们要让idea使用自己安装的maven。</p><ol><li>选择File- Settings </li></ol><p><img src="images/image-20201016151034872.png" alt="image-20201016151034872">    </p><p><img src="images/image-20201016151528678.png" alt="image-20201016151528678">    </p><p>设置项： -DarchetypeCatalog=internal</p><p>2） File - Other Settings</p><p><img src="images/image-20201016151823967.png" alt="image-20201016151823967"></p><p>同上的设置</p><h2 id="3-2-创建基于maven的普通java项目"><a href="#3-2-创建基于maven的普通java项目" class="headerlink" title="3.2 创建基于maven的普通java项目"></a>3.2 创建基于maven的普通java项目</h2><p><img src="images/image-20201016161028977.png" alt="image-20201016161028977">    </p><h2 id="3-3-创建web项目"><a href="#3-3-创建web项目" class="headerlink" title="3.3 创建web项目"></a>3.3 创建web项目</h2><p><img src="images/image-20201016170153694.png" alt="image-20201016170153694">    </p><h2 id="3-4-导入module到idea"><a href="#3-4-导入module到idea" class="headerlink" title="3.4 导入module到idea"></a>3.4 导入module到idea</h2><p><img src="images/image-20201017085816226.png" alt="image-20201017085816226">    </p><h1 id="4-第四章-依赖管理"><a href="#4-第四章-依赖管理" class="headerlink" title="4. 第四章 依赖管理"></a>4. 第四章 依赖管理</h1><p>依赖范围：使用scope表示依赖的范围。 </p><p>依赖范围表示： 这个依赖（jar和里面类）在项目构建的那个阶段起作用。</p><p>依赖范围scope ：</p><p>​     compile:默认， 参与构建项目的所有阶段</p><p>​     test：测试，在测试阶段使用， 比如执行mvn test会使用junit 。</p><p>​    provided: 提供者。 项目在部署到服务器时，不需要提供这个依赖的jar ， 而是由服务器这个依赖的jar包</p><p>​                      明显的是servlet 和jsp 依赖</p><h1 id="5-第五章-常用设置"><a href="#5-第五章-常用设置" class="headerlink" title="5. 第五章 常用设置"></a>5. 第五章 常用设置</h1><p>1)讲的是properties它里面的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span> 源码编译 jdk 版本</span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span> 运行代码的 jdk 版本</span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span> 项目</span><br><span class="line">构建使用的编码，避免中文乱码</span><br><span class="line"><span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8</span><br><span class="line"><span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span> 生成报告的编码</span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>全局变量</li></ol><p>在properties定义标签，这个标签就是一个变量， 标签的文本就是变量的值。 </p><p>使用全局变量表示 多个依赖使用的版本号。</p><p>使用步骤：</p><p>1.在properties标签中，定义一个标签，指定版本的值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--自定义变量--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.2.5.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用全局变量， 语法 ${变量名}</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）使用资源插件</p><p>处理的配置文件的信息， maven默认处理配置文件</p><p>①：maven会把src/main/resources目录中的文件， 拷贝到target/classes目录下</p><p>②：maven只处理src/main/java目录中的 .java文件，把这些java文件编译为class，拷贝到 target/classes目录中。 不处理其他文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--资源插件</span></span><br><span class="line"><span class="comment">      告诉maven把 src/main/java目录中的 指定扩展名的文件 拷贝到 target/classes目录中。</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span><span class="comment">&lt;!--所在的目录--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--包括目录下的.properties,.xml 文件都会扫描到--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  filtering 选项 false 不启用过滤器， *.property 已经起到过</span></span><br><span class="line"><span class="comment">        滤的作用了 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Maven-这篇非自己整理&quot;&gt;&lt;a href=&quot;#Maven-这篇非自己整理&quot; class=&quot;headerlink&quot; title=&quot;Maven(这篇非自己整理)&quot;&gt;&lt;/a&gt;Maven(这篇非自己整理)&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Ajax</title>
    <link href="http://example.com/2021/10/09/ajax/"/>
    <id>http://example.com/2021/10/09/ajax/</id>
    <published>2021-10-09T02:32:00.000Z</published>
    <updated>2021-10-09T02:34:12.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><span id="more"></span><h1 id="Ajax学习途径-狂神说Java"><a href="#Ajax学习途径-狂神说Java" class="headerlink" title="Ajax学习途径-狂神说Java"></a>Ajax学习途径-狂神说Java</h1><p><a href="https://mp.weixin.qq.com/s/tB4YX4H59wYS6rxaO3K2_g">=点击这里跳转=</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Ajax&quot;&gt;&lt;a href=&quot;#Ajax&quot; class=&quot;headerlink&quot; title=&quot;Ajax&quot;&gt;&lt;/a&gt;Ajax&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>JDBC 和数据库连接池</title>
    <link href="http://example.com/2021/10/05/JDBC%20%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <id>http://example.com/2021/10/05/JDBC%20%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</id>
    <published>2021-10-05T12:31:00.000Z</published>
    <updated>2021-10-09T12:07:53.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDBC-和数据库连接池"><a href="#JDBC-和数据库连接池" class="headerlink" title="JDBC 和数据库连接池"></a>JDBC 和数据库连接池</h1><span id="more"></span><h1 id="《《文章很长，目录在右下角》》"><a href="#《《文章很长，目录在右下角》》" class="headerlink" title="《《文章很长，目录在右下角》》"></a>《《文章很长，目录在右下角》》</h1><h1 id="JDBC-概述"><a href="#JDBC-概述" class="headerlink" title="JDBC 概述"></a>JDBC 概述</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><img src="https://s3.bmp.ovh/imgs/2021/10/c9f674c8aaf9cb48.png"></p><h2 id="JDBC-带来的好处"><a href="#JDBC-带来的好处" class="headerlink" title="JDBC 带来的好处"></a>JDBC 带来的好处</h2><p><img src="https://s3.bmp.ovh/imgs/2021/10/dce0233f06508a88.png"></p><h2 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h2><p><img src="https://s3.bmp.ovh/imgs/2021/10/27f78862ddee3653.png"></p><h2 id="JDBC-快速入门"><a href="#JDBC-快速入门" class="headerlink" title="JDBC 快速入门"></a>JDBC 快速入门</h2><ul><li>JDBC 程序编写步骤<br><img src="https://s3.bmp.ovh/imgs/2021/10/9cd7d3c65a20581d.png"></li><li>JDBC 第一个程序 com.hspedu.jdbc Jdbc01.java<h2 id="获取数据库连接-5-种方式"><a href="#获取数据库连接-5-种方式" class="headerlink" title="获取数据库连接 5 种方式"></a>获取数据库连接 5 种方式</h2></li><li>方式 1<br><img src="https://s3.bmp.ovh/imgs/2021/10/64e986e768ffb241.png"></li><li>方式 2<br><img src="https://s3.bmp.ovh/imgs/2021/10/21cfc01375e29b07.png"></li><li>方式 3<br><img src="https://s3.bmp.ovh/imgs/2021/10/74c051cd939fd8b8.png"></li><li>方式 4<br><img src="https://s3.bmp.ovh/imgs/2021/10/b12524787a3e1145.png"></li><li>方式 5<br><img src="https://s3.bmp.ovh/imgs/2021/10/90cdeb4387ff4076.png"><h2 id="ResultSet-结果集"><a href="#ResultSet-结果集" class="headerlink" title="ResultSet[结果集]"></a>ResultSet[结果集]</h2></li><li>基本介绍<br><img src="https://s3.bmp.ovh/imgs/2021/10/8551ed06b7d9d84a.png"><br><img src="https://s3.bmp.ovh/imgs/2021/10/fff3f0984e710482.png"><h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2></li><li> 基本介绍<br><img src="https://s3.bmp.ovh/imgs/2021/10/b80e2155309b9408.png"><h2 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h2></li><li>基本介绍<br><img src="https://s3.bmp.ovh/imgs/2021/10/6950b84905145a26.png"></li><li>预处理好处</li></ul><ol><li>不再使用+来拼接sql代码，减少语法错误</li><li>有效解决了sql注入问题</li><li>大大减少了编译次数，提高了效率</li></ol><h2 id="JDBC-的相关-API-小结"><a href="#JDBC-的相关-API-小结" class="headerlink" title="JDBC 的相关 API 小结"></a>JDBC 的相关 API 小结</h2><p><img src="https://s3.bmp.ovh/imgs/2021/10/ccff81583ff3c4d4.png"><br><img src="https://s3.bmp.ovh/imgs/2021/10/f64ebb4830af1699.png"></p><h2 id="封装-JDBCUtils-【关闭连接-得到连接】-已写，略"><a href="#封装-JDBCUtils-【关闭连接-得到连接】-已写，略" class="headerlink" title="封装 JDBCUtils 【关闭连接, 得到连接】(已写，略)"></a>封装 JDBCUtils 【关闭连接, 得到连接】(已写，略)</h2><ul><li>获取连接和关闭资源代码重复，且经常用到，所以封装成工具类<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2></li><li>基本介绍<br><img src="https://s3.bmp.ovh/imgs/2021/10/3080138a54ee7d7d.png"></li><li>不使用事务可能出现的问题模拟-模拟经典的转账业务<h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2></li><li>基本介绍<br><img src="https://s3.bmp.ovh/imgs/2021/10/1eff47a4a6893818.png"></li><li>应用实例<br><img src="https://s3.bmp.ovh/imgs/2021/10/802cbf0a91626094.png"><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2></li><li>传统获取 Connection 问题分析<br><img src="https://s3.bmp.ovh/imgs/2021/10/431e73304e1840f5.png"></li><li>数据库连接池种类<br><img src="https://s3.bmp.ovh/imgs/2021/10/3fa007b0168360fd.png"></li><li>c3p0和druid（详细代码写在练习里）</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JDBC-和数据库连接池&quot;&gt;&lt;a href=&quot;#JDBC-和数据库连接池&quot; class=&quot;headerlink&quot; title=&quot;JDBC 和数据库连接池&quot;&gt;&lt;/a&gt;JDBC 和数据库连接池&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Oracle笔记</title>
    <link href="http://example.com/2021/09/18/Oracle%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/09/18/Oracle%E7%AC%94%E8%AE%B0/</id>
    <published>2021-09-18T07:47:00.000Z</published>
    <updated>2021-09-26T07:41:27.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Oracle笔记"><a href="#Oracle笔记" class="headerlink" title="Oracle笔记"></a>Oracle笔记</h1><span id="more"></span><h1 id="《《文章很长，目录在右下角》》"><a href="#《《文章很长，目录在右下角》》" class="headerlink" title="《《文章很长，目录在右下角》》"></a>《《文章很长，目录在右下角》》</h1><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><ul><li>create user  用户名  identified  by  密码  【account  lock | unlock】<h3 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h3></li><li>解锁：alter  user  用户名  account  lock | unlock</li><li>修改密码：alter  user  用户名 identified  by  密码</li><li>删除用户：drop user 用户名 cascade;  – cascade: 表示级联删除<h3 id="常见角色"><a href="#常见角色" class="headerlink" title="常见角色"></a>常见角色</h3></li><li>connect角色:具有权限create  session</li><li>resource角色：创建数据库对象（如：创建数据库表、序列、存储过程等等）</li><li>dba角色：所有的权限<h3 id="给用户授权角色或权限"><a href="#给用户授权角色或权限" class="headerlink" title="给用户授权角色或权限"></a>给用户授权角色或权限</h3></li><li>授权：grant  角色 | 权限  to  用户 | 角色</li><li>回收：revoke  角色  | 权限  from  用户 | 角色<h3 id="查看用户角色"><a href="#查看用户角色" class="headerlink" title="查看用户角色"></a>查看用户角色</h3><img src="https://s3.bmp.ovh/imgs/2021/09/dd39c12d95da0e6c.png"><h2 id="表空间管理"><a href="#表空间管理" class="headerlink" title="表空间管理"></a>表空间管理</h2><h3 id="创建表空间"><a href="#创建表空间" class="headerlink" title="创建表空间"></a>创建表空间</h3></li><li>create  tablespace  表空间名  datafile  ‘文件地址1’  size  值M, ‘文件地址n’  size  值M<h3 id="修改表空间"><a href="#修改表空间" class="headerlink" title="修改表空间"></a>修改表空间</h3></li><li>alter  database  datafile  ‘文件地址’  resize  值M; –修改数据文件的大小</li><li>alter  tablespace  表空间名  add  datafile  ‘文件地址’  size  值M;  –增加数据文件<h3 id="删除表空间"><a href="#删除表空间" class="headerlink" title="删除表空间"></a>删除表空间</h3></li><li>drop  tablespace  表空间名  including  contents  and  datafiles;</li></ul><p>– including  contents  and  datafiles:表示同时删除数据文件</p><h3 id="创建用户时指定默认的表空间"><a href="#创建用户时指定默认的表空间" class="headerlink" title="创建用户时指定默认的表空间"></a>创建用户时指定默认的表空间</h3><ul><li>create  user  用户名 IDENTIFIED  by  密码  account  unlock default  tablespace  表空间名<h3 id="修改用户默认的表空间"><a href="#修改用户默认的表空间" class="headerlink" title="修改用户默认的表空间"></a>修改用户默认的表空间</h3></li><li>alter  user  用户名  default  tablespace  表空间名<h3 id="在指定表空间中创建表"><a href="#在指定表空间中创建表" class="headerlink" title="在指定表空间中创建表"></a>在指定表空间中创建表</h3></li><li>create  table  表名(…)  tablespace  表空间名<h3 id="移动表至指定的表空间"><a href="#移动表至指定的表空间" class="headerlink" title="移动表至指定的表空间"></a>移动表至指定的表空间</h3></li><li>alter  table  表名  move  tablespace  表空间名<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2></li><li>varchar2、nvarchar2、clob 对应mysql中的text</li><li>number、char、date（不会根据时区转换时间）、timestamp（会根据时区转换时间）<h2 id="获取系统时间"><a href="#获取系统时间" class="headerlink" title="获取系统时间"></a>获取系统时间</h2></li><li>select  sysdate,systimestamp,current_timestamp  from  dual;<h2 id="方案scham"><a href="#方案scham" class="headerlink" title="方案scham"></a>方案scham</h2></li><li>mysql中：方案名指的是数据库名</li><li>Oracle中：方案名指的是用户名<h2 id="SQL的分类（掌握）"><a href="#SQL的分类（掌握）" class="headerlink" title="SQL的分类（掌握）"></a>SQL的分类（掌握）</h2><img src="https://s3.bmp.ovh/imgs/2021/09/33be449daf7ea743.png"><h3 id="使用DDL操作数据库对象（掌握）"><a href="#使用DDL操作数据库对象（掌握）" class="headerlink" title="使用DDL操作数据库对象（掌握）"></a>使用DDL操作数据库对象（掌握）</h3></li><li>创建数据库（掌握）<br><img src="https://s3.bmp.ovh/imgs/2021/09/06d90e06a4f0981c.png"><br><img src="https://s3.bmp.ovh/imgs/2021/09/fd59733559782089.png"><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3></li><li>检查约束</li><li>create  table  表名(列名  数据类型 check(检查条件) );<h3 id="数据表管理"><a href="#数据表管理" class="headerlink" title="数据表管理"></a>数据表管理</h3></li><li>复制表：create  table  表名  as  select  *  from  旧表名  [where  条件];</li><li>修改列的默认值：alter  table  表名  modify  列名  default  值;<h2 id="DML数据管理"><a href="#DML数据管理" class="headerlink" title="DML数据管理"></a>DML数据管理</h2></li><li>新增单条数据<br>insert  into  表名(字段列表)  values(值列表)</li></ul><p>注意：其中关键字into不能省略</p><pre><code>    values不能使用value</code></pre><ul><li>批量插入数据</li></ul><p>insert  all  into 表名(字段列表)  values(值列表)</p><p>……</p><p>into 表名(字段列表)  values(值列表) </p><p>select * from dual;</p><hr><p>insert  into  表名(字段列表)</p><p>select  值列表  from  dual</p><p>union  all</p><p>……</p><p>select  值列表  from  dual;</p><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><ul><li>唯一性结果集（去重）</li></ul><p>select  distinct  列名1,….  from  表名 …..</p><ul><li>联合查询（并集）</li></ul><p>select语句1   union  [all]  select语句2;</p><p>union 会去掉结果集中重复的行</p><p>union  all  不会去除结果集中重复的行</p><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>内连接（inner  join）（必须使用on条件）</p><p>必须符合条件的数据（两个表中必须都有对应的数据）才会被查出<br>到结果集中</p><p>外连接（out  join）（必须使用on条件）</p><p>左外连接（left  join）</p><p>以左表为主：左表中存在的数据都会被查询到结果集中，如果右表<br>没有对应的数据，则以空填充</p><p>右外连接（right  join）</p><p>以右表为主：右表中存在的数据都会被查询到结果集中，如果左表<br>没有对应的数据，则以空填充</p><p>全外连接（full  join）</p><p>被连接的两个表中存在的数据都会被查询到结果集中，如果对方的<br>表没有对应的数据，则以空填充</p><p>交叉连接（cross  join）</p><p>求两个表的笛卡尔积</p><h3 id="子查询（嵌套查询）"><a href="#子查询（嵌套查询）" class="headerlink" title="子查询（嵌套查询）"></a>子查询（嵌套查询）</h3><p>–使用子查询作为条件值时，查询条件使用的比较运算符，子查询<br>查出的结果集必须是一行一列</p><p>select * from “users” where id=(select id from<br>“admin”);</p><p>–any:和子查询的结果集中的每一个值进行比较，只要有一个符<br>合条件，则保留该行</p><p>–all:和子查询的结果集中的每一个值进行比较，只要有一个不<br>符合条件，则不保留该行</p><p>select * from “users” where id&gt; all(select id from<br>“admin” );</p><p>–子查询查出的结果集只能有一列</p><p>select * from “users” where id in (select username<br>from “admin”);</p><p>–在子查询中设置条件，对子查询没有行数和列数的要求</p><p>select * from “users” where exists</p><p>(select * from “admin” where “users”.id = “admin”.id)<br>;</p><h2 id="伪列"><a href="#伪列" class="headerlink" title="伪列"></a>伪列</h2><ul><li><p>ROWID：插入数据时产生，存储于表中；数据行所在的物理地址</p></li><li><p>ROWNUM：查询数据时产生，存在于结果集中；结果集中的行号</p><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2></li><li><p>–使用子查询，给伪列ROWNUM取别名</p></li><li><p>select  *  from  (select  ROWNUM  别名,*  from  表名)   where  别名&gt;…..;</p><h2 id="SQL语句执行顺序"><a href="#SQL语句执行顺序" class="headerlink" title="SQL语句执行顺序"></a>SQL语句执行顺序</h2></li><li><p>SQL语句编写的顺序</p></li><li><p>Select … from … where … group by … having … order by …</p></li><li><p>SQL语句执行的顺序</p></li><li><p>FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT -&gt; ORDER BY</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2></li><li><p>已经编译后的select语句</p></li><li><p>create  [or  replace]  view  视图名称  as  select语句;</p><h2 id="同义词（了解）"><a href="#同义词（了解）" class="headerlink" title="同义词（了解）"></a>同义词（了解）</h2></li><li><p>create  [or  replace]  [public]  SYNONYM  同义词名  for  数据库对象名</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2></li><li><p>提高查询的效率，但会影响更新（增删改）的效率</p></li><li><p>create  [unique|bitmap]  index  索引名  on  表名(列名)  [rerverse]</p><h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><pre><code>  生成自增的数据  创建序列语法  CREATE SEQUENCE 序列名  [START WITH 起始值]  [INCREMENT BY 步进值]  [MAXVALUE 最大值|NOMAXVALUE]  [MINVALUE 最小值|NOMINVALUE]  [CYCLE|NOCYCLE]  [CACHE 个数|NOCACHE]  create  [or  replace]  sequence  序列名;  --刚刚创建的序列对象，不能直接查询currval（伪列）值  --必须先查询一次nextval（伪列）之后，才可以查询currval的值  select SEQ_USERS.nextval from dual;  select SEQ_USERS.currval from dual;  --删除序列  DROP  SEQUENCE  序列名;  --通过序列实现自增id  insert  into  表名(id,字段列表)  values(序列名.nextval,值列表);</code></pre></li></ul><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><pre><code>    --创建触发器    --触发时间点：before（操作之前触发）,after(操作之后触发)    --触发的操作：insert（新增操作），delete（删除操作），update（更新操作）    --触发器的级别：for each row（行级触发器）；不加for each row关键字则为语句级    --:new 表示将要被插入的新行    --:old 表示将要被删除的旧行    create  [or  replace]  trigger  before|after  insert|delete|update  on  表名     for  each  row    begin            功能语句 -- 实现主键自增：select 序列.nextval into :new.id from dual;    end;</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre><code>    Oracle自带的函数    单行函数    字符串函数    对字符串进行操作，    例如：            length(字符串)  -- 获取字符串长度            substr(字符串, 起始下标 [, 长度])  -- 截取字符串：起始下标从1开始    等等。    数值函数    对数值进行计算或操作，返回一个数字。例如：ABS()、MOD()、ROUND()等等。    转换函数    将一种数据类型转换成另外一种类型：    例如：TO_CHAR(日期,&#39;yyyy-mm-dd hh24:mi:ss&#39;)            TO_DATE(&#39;2021-06-10 11:11:11&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;)    TO_NUMBER(&#39;123&#39;)等等。    日期函数    对时间和日期进行操作的函数。    例如：     SYSDATE()  -- 获取当前日期    ADD_MONTHS(日期, 数值)  -- 给指定日期添加月份    等等。    聚合函数    count()、avg()、sum()、max()、min()    存储过程和函数    -- 创建存储过程    -- 参数类型：in：输入参数（可省略）  out：输出参数（不可省略） in out：既是输入参数又是输出参数    create [or replace] procedure 【schema.】存储过程名【(参数1  [in | &lt;out&gt; | &lt;in out&gt;]  数据类型, …. )】    is 或 as    -- 变量声明位置    变量名  数据类型;    begin    -- 功能代码    end;    -- 调用存储过程    -- 语法一    call 存储过程名【(参数列表)】;     -- 语法二    exec 存储过程名【(参数列表)】;    -- 语法三    【set serveroutput on】    begin            存储过程名【(参数列表)】;    end;    create [or replace] function 【schema.】函数名(参数1  数据类型, ….) return 返回值类型    is    begin    -- 功能代码    end;    -- 调用函数    call 函数名(参数列表);    -- 创建带输出参数的存储过程    create or replace procedure proc_add(num1 in number,num2 number, v_result out number)    as    begin    v_result := num1 + num2;    end;        -- 调用带输出参数的存储过程    declare    v_r number;    begin    proc_add(1,2,v_r);    dbms_output.put_line(v_r);    end;    程序包    -- 创建程序包（类似声明接口）    create [or replace] package 包名 is    procedure 存储过程名1(参数1  数据类型, …. );    procedure 存储过程名n(参数1  数据类型, …. );     function 函数名1(参数1  数据类型, ….) return 返回值类型;     function 函数名n(参数1  数据类型, ….) return 返回值类型;    end;    -- 创建程序包体（类似创建实现类）    create package body 包名 is    -- 实现存储过程    procedure 存储过程名1(参数1  数据类型, …. )    is    begin    -- 功能代码    end;    procedure 存储过程名n(参数1  数据类型, …. )    is    begin    -- 功能代码    end;    -- 创建函数    function 函数名1(参数1  数据类型, ….) return 返回值类型    is    begin    -- 功能代码    end;    function 函数名n(参数1  数据类型, ….) return 返回值类型    is    begin    -- 功能代码    end;    end;    -- 调用包中的存储过程或程序    call 包名.存储过程名1 (参数列表);    call 包名.存储过程名n (参数列表);    call 包名.函数名1 (参数列表);    call 包名.函数名n (参数列表);</code></pre><h2 id="PL-SQL编程（略）"><a href="#PL-SQL编程（略）" class="headerlink" title="PL/SQL编程（略）"></a>PL/SQL编程（略）</h2><p>详情见：D:\中软学习篇\J1604A班的笔记\阶段3</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Oracle笔记&quot;&gt;&lt;a href=&quot;#Oracle笔记&quot; class=&quot;headerlink&quot; title=&quot;Oracle笔记&quot;&gt;&lt;/a&gt;Oracle笔记&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>EL和JSTL</title>
    <link href="http://example.com/2021/09/17/EL%E5%92%8CJSTL%E3%80%81/"/>
    <id>http://example.com/2021/09/17/EL%E5%92%8CJSTL%E3%80%81/</id>
    <published>2021-09-17T02:44:00.000Z</published>
    <updated>2021-09-18T01:59:58.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EL和JSTL笔记"><a href="#EL和JSTL笔记" class="headerlink" title="EL和JSTL笔记"></a>EL和JSTL笔记</h1><span id="more"></span><h1 id="《《文章很长，目录在右下角》》"><a href="#《《文章很长，目录在右下角》》" class="headerlink" title="《《文章很长，目录在右下角》》"></a>《《文章很长，目录在右下角》》</h1><h1 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>获取数据</li><li>执行运算</li><li>调用Java方法</li><li>降低Java代码与HTML之间的耦合度</li><li>注意：JSP脚本(&lt;% %&gt;)中不能使用EL表达式<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><img src="https://s3.bmp.ovh/imgs/2021/09/2282edfaf9da1202.png"><br><img src="https://s3.bmp.ovh/imgs/2021/09/321d051b0940b664.png"><h2 id="关键字empty"><a href="#关键字empty" class="headerlink" title="关键字empty"></a>关键字empty</h2><img src="https://s3.bmp.ovh/imgs/2021/09/62e851b97f7d78ba.png"><br><img src="https://s3.bmp.ovh/imgs/2021/09/05488f8186855290.png"><h1 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h1><img src="https://s3.bmp.ovh/imgs/2021/09/ddbb0a9efcaf7c82.png"><br><img src="https://s3.bmp.ovh/imgs/2021/09/7f472675222d1def.png"><br><img src="https://s3.bmp.ovh/imgs/2021/09/71e42b72d591f7c3.png"><br><img src="https://s3.bmp.ovh/imgs/2021/09/4c62c86315504db6.png"><br><img src="https://s3.bmp.ovh/imgs/2021/09/00e51bf888eca031.png"><br><img src="https://s3.bmp.ovh/imgs/2021/09/6c0b34b5e48c2efc.png"></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;EL和JSTL笔记&quot;&gt;&lt;a href=&quot;#EL和JSTL笔记&quot; class=&quot;headerlink&quot; title=&quot;EL和JSTL笔记&quot;&gt;&lt;/a&gt;EL和JSTL笔记&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>servlet和jsp笔记</title>
    <link href="http://example.com/2021/09/14/servlet%E5%92%8Cjsp%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/09/14/servlet%E5%92%8Cjsp%E7%AC%94%E8%AE%B0/</id>
    <published>2021-09-14T07:07:00.000Z</published>
    <updated>2021-09-17T02:44:42.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="servlet和jsp笔记"><a href="#servlet和jsp笔记" class="headerlink" title="servlet和jsp笔记"></a>servlet和jsp笔记</h1><span id="more"></span><h1 id="《《文章很长，目录在右下角》》"><a href="#《《文章很长，目录在右下角》》" class="headerlink" title="《《文章很长，目录在右下角》》"></a>《《文章很长，目录在右下角》》</h1><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="应用程序分层开发（MVC）"><a href="#应用程序分层开发（MVC）" class="headerlink" title="应用程序分层开发（MVC）"></a>应用程序分层开发（MVC）</h3><p><img src="https://s3.bmp.ovh/imgs/2021/09/898dbdb996412b9a.png"></p><h3 id="Servlet简介"><a href="#Servlet简介" class="headerlink" title="Servlet简介"></a>Servlet简介</h3><p>server  applet（服务端应用小程序）<br><img src="https://s3.bmp.ovh/imgs/2021/09/9a937530ed18959a.png"></p><h3 id="Eclipse中创建服务器-略"><a href="#Eclipse中创建服务器-略" class="headerlink" title="Eclipse中创建服务器(略)"></a>Eclipse中创建服务器(略)</h3><h3 id="Eclipse创建Web项目（略）"><a href="#Eclipse创建Web项目（略）" class="headerlink" title="Eclipse创建Web项目（略）"></a>Eclipse创建Web项目（略）</h3><h3 id="使用Servlet基本步骤"><a href="#使用Servlet基本步骤" class="headerlink" title="使用Servlet基本步骤"></a>使用Servlet基本步骤</h3><ol><li>创建一个类，并继承HttpServlet类</li><li>重写HttpServlet类中的二个方法doPost()和doGet()，并在其中编写处理请求的代码</li><li>配置项目WEB-INF\web.xml  a、servlet元素中的servlet-name和servlet-mapping中的servlet-name的内容一致 b、url-pattern的内容要和页面form元素的action属性的值一致（不含斜杠）<br><img src="https://s3.bmp.ovh/imgs/2021/09/2c91521ff1d13b29.png"></li><li>创建JSP页面，编写form表单</li><li>部署项目：将web项目部署到Tomcat服务器上<br><img src="https://s3.bmp.ovh/imgs/2021/09/efda014c0b5ef62b.png"><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><h3 id="访问：http-127-0-0-1-8080-项目名-页面-html"><a href="#访问：http-127-0-0-1-8080-项目名-页面-html" class="headerlink" title="访问：http://127.0.0.1:8080/项目名/页面.html"></a>访问：<a href="http://127.0.0.1:8080/%E9%A1%B9%E7%9B%AE%E5%90%8D/%E9%A1%B5%E9%9D%A2.html">http://127.0.0.1:8080/项目名/页面.html</a></h3><h3 id="GET和POST方式请求的区别"><a href="#GET和POST方式请求的区别" class="headerlink" title="GET和POST方式请求的区别"></a>GET和POST方式请求的区别</h3>携带数据的方式 GET： URL（网址）?key=value&amp;key=value<pre><code> 会将数据以键值对的方式拼接在URL之后（会显示在地址栏中），并且是将所有数据一次性提交到后台，对数据长度有限制 缺点：不安全（如果包含敏感数据，如密码，都会显示在地址栏中），很难实现文件上传</code></pre> POST：将数据以数据包的形式提交到后台（至少是一个数据包），理论上对数据长度无限制<h3 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h3></li></ol><ul><li>生命周期的三个阶段</li></ul><p>创建对象并初始化、为项目提供服务、销毁</p><ol><li>服务器（Tomcat）启动时，不会创建Servlet对象</li><li>当请求Servlet时，Servlet对象才被创建</li><li>一个生命周期中，init方法只会被执行一次</li><li>默认情况下，Servlet是单例模式的</li><li>由于Servlet对象可能会被多线程同时访问，所以Servlet是线程不安全的</li><li>Servlet对象销毁时会调用destroy()方法（回收资源），但调用destroy()方法不会销毁Servlet对象</li></ol><ul><li>生命周期中的三个方法</li></ul><ol><li>初始化方法：init</li><li>提供服务的方法：service</li><li>销毁的方法：destroy</li></ol><ul><li><p>提供服务的三个方法<br><img src="https://s3.bmp.ovh/imgs/2021/09/78c9b8ce551c28bd.png"></p><h3 id="通配符映射"><a href="#通配符映射" class="headerlink" title="通配符映射"></a>通配符映射</h3><p><img src="https://s3.bmp.ovh/imgs/2021/09/7070a34d5cde1559.png"></p><h3 id="处理中文乱码问题"><a href="#处理中文乱码问题" class="headerlink" title="处理中文乱码问题"></a>处理中文乱码问题</h3><p>  // 设置Post方式请求内容的编码<br>  request.setCharacterEncoding(“utf-8”);<br>  // 设置响应的内容类型<br>  response.setContentType(“text/html; charset=UTF-8”);<br>  // 设置响应的编码<br>  response.setCharacterEncoding(“utf-8”);</p>  <!-- tomcat\config\server.xml    URIEncoding：用于设置get方式请求数据的编码 --><p>  &lt;Connector port=”8080” protocol=”HTTP/1.1”</p><pre><code>          connectionTimeout=&quot;20000&quot;          redirectPort=&quot;8443&quot; URIEncoding=&quot;utf-8&quot;/&gt;</code></pre><h3 id="老师的代码"><a href="#老师的代码" class="headerlink" title="老师的代码"></a>老师的代码</h3><p>  package com.servlet;</p><p>  import java.io.IOException;<br>  import java.io.PrintWriter;</p><p>  import javax.servlet.ServletException;<br>  import javax.servlet.http.HttpServlet;<br>  import javax.servlet.http.HttpServletRequest;<br>  import javax.servlet.http.HttpServletResponse;<br>  /*</p><ul><li>1、创建类并继承HttpServlet类</li><li>2、实现处理请求的方法 doGet、doPost、doDelete、doPut  （提交表单的四种方式get post delete  put）</li><li>/<br>public class LoginServlet extends HttpServlet {<br>   public LoginServlet() {<pre><code>   System.out.println(&quot;LoginServlet对象被创建！&quot;);</code></pre>   }<br>   // 初始化当前Servlet对象的方法（不需要重写）<br>   // 只有在第一次请求该Servlet时，被执行一次<br>   @Override<br>   public void init() throws ServletException {<pre><code>   System.out.println(&quot;init方法被执行了！&quot;);   super.init();</code></pre>   }<br>   // 提供服务的方法（不需要重写）<br>   // 每请求一次会被执行一次<br>   @Override<br>   protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<pre><code>   System.out.println(&quot;service方法被执行了！&quot;);   String method = req.getMethod();   System.out.println(&quot;method = &quot; + method);</code></pre>//        if (“GET”.equals(method)) {<br>//            doGet(req, resp);<br>//        } else if (“POST”.equals(method)) {<br>//            doPost(req, resp);<br>//        }<pre><code>   super.service(req, resp);</code></pre>   }<br>   // 销毁当前Servlet对象的方法（不需要重写）<br>   // 只有Tomcat服务结束时，被执行一次<br>   @Override<br>   public void destroy() {<pre><code>   System.out.println(&quot;destroy方法被执行了！&quot;);   super.destroy();</code></pre>   }<br>   /*<ul><li>参数一：请求对象，请求对象中保存着客户端的所有信息</li><li>参数二：响应对象，向客户端响应的内容以及一些设置，都在响应对象中</li><li>/<br>@Override<br>protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br>   System.out.println(“get请求成功”);   // 解决响应的乱码问题<br>   resp.setCharacterEncoding(“utf-8”);<br>   resp.setContentType(“text/html; charset=UTF-8”);   // 获取客户端提交的表单中的数据<br>   String phone = req.getParameter(“phone”);<br>   String password = req.getParameter(“password”);<br>   System.out.println(“Get获取的手机号：” + phone);<br>   System.out.println(“Get获取的密码：” + password);</li></ul></li></ul><p>  //        byte[] data = phone.getBytes(“ISO-8859-1”);<br>  //        String result = new String(data,”utf-8”);</p><pre><code>      // 获取响应的输出流</code></pre><p>  //        resp.getOutputStream();</p><pre><code>      PrintWriter writer = resp.getWriter();      writer.write(&quot;登录成功&quot;);      // 刷新缓冲区（清空缓冲区）      writer.flush();      // 关闭流      writer.close();  &#125;    @Override  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;      System.out.println(&quot;post请求成功&quot;);            // 解决POST方式请求的乱码（获取请求的数据之前）      req.setCharacterEncoding(&quot;UTF-8&quot;);      // 解决响应乱码问题(响应的内容被转换成二进制时使用的字符集)      resp.setCharacterEncoding(&quot;UTF-8&quot;);      // 告诉浏览器，应该以什么字符集解析响应内容      resp.setContentType(&quot;text/html;charset=UTF-8&quot;);            // 获取客户端提交的表单中的数据      String phone = req.getParameter(&quot;phone&quot;);      String password = req.getParameter(&quot;password&quot;);      System.out.println(&quot;post获取的手机号：&quot; + phone);      System.out.println(&quot;post获取的密码：&quot; + password);            // 获取响应的输出流</code></pre><p>  //        resp.getOutputStream();</p><pre><code>      PrintWriter writer = resp.getWriter();      writer.write(&quot;&lt;font color=&#39;green&#39;&gt;登录成功&lt;/font&gt;&quot;);      // 刷新缓冲区（清空缓冲区）      writer.flush();      // 关闭流      writer.close();  &#125;</code></pre><p>  }</p></li></ul><hr><pre><code>package com.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class UserServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doPost(req, resp);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        // 处理乱码        req.setCharacterEncoding(&quot;utf-8&quot;);        resp.setCharacterEncoding(&quot;utf-8&quot;);        resp.setContentType(&quot;text/html;charset=utf-8&quot;);                // 获取当前要执行的操作        String operation = req.getParameter(&quot;operation&quot;);        switch(operation) &#123;        case &quot;login&quot;:            // 执行登录操作            login(req,resp);            break;        case &quot;register&quot;:            // 执行注册操作            register(req,resp);            break;        case &quot;update&quot;:            // 执行更新用户信息            update(req,resp);            break;        case &quot;delete&quot;:            // 执行删除用户操作            delete(req,resp);            break;        &#125;    &#125;    private void delete(HttpServletRequest req, HttpServletResponse resp) &#123;        System.out.println(&quot;删除用户&quot;);    &#125;    private void update(HttpServletRequest req, HttpServletResponse resp) &#123;        System.out.println(&quot;更新用户&quot;);            &#125;    private void register(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;        System.out.println(&quot;注册用户&quot;);        // 获取客户端的值        String username = req.getParameter(&quot;username&quot;);        String password = req.getParameter(&quot;password&quot;);        String repassword = req.getParameter(&quot;repassword&quot;);        PrintWriter writer = resp.getWriter();                if (username==null || &quot;&quot;.equals(username)) &#123;            writer.write(&quot;用户名不能为空&quot;);        &#125;else &#123;            writer.write(&quot;您输入的用户名：&quot; + username + &quot; 密码：&quot; + password);        &#125;        writer.flush();        writer.close();    &#125;    private void login(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;        System.out.println(&quot;登录系统&quot;);        // 获取客户端的值        String username = req.getParameter(&quot;username&quot;);        String password = req.getParameter(&quot;password&quot;);                PrintWriter writer = resp.getWriter();        writer.write(&quot;您输入的用户名：&quot; + username + &quot; 密码：&quot; + password);        writer.flush();        writer.close();    &#125;&#125;</code></pre><hr><p>（这个界面就写一个）</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!--         action：url        method：提交表单的四种方式get（默认值） post delete  put     --&gt;    &lt;form action=&quot;user&quot; method=&quot;post&quot;&gt;        &lt;!-- 隐藏域 --&gt;        &lt;input type=&quot;hidden&quot; name=&quot;operation&quot; value=&quot;login&quot;&gt;         手机号：&lt;input name=&quot;phone&quot; type=&quot;text&quot;/&gt;&lt;br/&gt;        密 码：&lt;input name=&quot;password&quot; type=&quot;password&quot;/&gt;&lt;br/&gt;        &lt;input value=&quot;POST登录&quot; type=&quot;submit&quot;/&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;4.0&quot;&gt;&lt;display-name&gt;day26-servlet01&lt;/display-name&gt;&lt;!-- 配置Servlet和URL之间的映射关系 --&gt;&lt;servlet&gt;    &lt;servlet-name&gt;loginServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.servlet.LoginServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;loginServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/login&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet&gt;    &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.servlet.UserServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/html/user&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/user&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;welcome-file-list&gt;    &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;    &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;    &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;    &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt;</code></pre><h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><h3 id="JSP简介"><a href="#JSP简介" class="headerlink" title="JSP简介"></a>JSP简介</h3><p><img src></p><h3 id="JSP页面中的注释"><a href="#JSP页面中的注释" class="headerlink" title="JSP页面中的注释"></a>JSP页面中的注释</h3><ul><li><p>html注释：”小于号”!–  注释内容客户端可见，无法注释java代码  –&gt;</p></li><li><p>jsp注释：&lt;%–  注释内容客户端不可见，可以注释java代码  –%&gt;</p><h3 id="Jsp小脚本-和-表达式"><a href="#Jsp小脚本-和-表达式" class="headerlink" title="Jsp小脚本 和 表达式"></a>Jsp小脚本 和 表达式</h3><p><img src="https://s3.bmp.ovh/imgs/2021/09/20ab13026a10f80a.png"></p><h3 id="表达式和小脚本中循环的使用"><a href="#表达式和小脚本中循环的使用" class="headerlink" title="表达式和小脚本中循环的使用"></a>表达式和小脚本中循环的使用</h3><p><img src="https://s3.bmp.ovh/imgs/2021/09/4093b4ec667f053e.png"></p><h3 id="JSP声明（了解）"><a href="#JSP声明（了解）" class="headerlink" title="JSP声明（了解）"></a>JSP声明（了解）</h3><p><img src="https://s3.bmp.ovh/imgs/2021/09/faff7fec63e3320c.png"></p><h3 id="page指令"><a href="#page指令" class="headerlink" title="page指令"></a>page指令</h3><p><img src="https://s3.bmp.ovh/imgs/2021/09/45c20ae8343c5da3.png"></p><h3 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h3></li><li><p>作用：将其他页面的内容导入至当前页面中<br>&lt;% include file = time.jsp %&gt;</p><h3 id="导入文件"><a href="#导入文件" class="headerlink" title="导入文件"></a>导入文件</h3><p><img src="https://s3.bmp.ovh/imgs/2021/09/365da1f13d800a7f.png"><br><img src="https://s3.bmp.ovh/imgs/2021/09/b5ea8db8206f2a9e.png"></p><h3 id="JSP执行流程"><a href="#JSP执行流程" class="headerlink" title="JSP执行流程"></a>JSP执行流程</h3><p><img src="https://s3.bmp.ovh/imgs/2021/09/4f6c0af954758917.png"></p><h3 id="Jsp内置对象"><a href="#Jsp内置对象" class="headerlink" title="Jsp内置对象"></a>Jsp内置对象</h3><p><img src="https://s3.bmp.ovh/imgs/2021/09/e93b6aec51d2f449.png"><br><img src="https://s3.bmp.ovh/imgs/2021/09/d835f733b0b26d41.png"></p><h3 id="请求转发（forward）和重定向（sendRedirect）"><a href="#请求转发（forward）和重定向（sendRedirect）" class="headerlink" title="请求转发（forward）和重定向（sendRedirect）"></a>请求转发（forward）和重定向（sendRedirect）</h3><p><img src="https://i.loli.net/2021/09/15/IcKXZAf6o1EG9mD.png"></p><h3 id="请求转发和重定向的区别"><a href="#请求转发和重定向的区别" class="headerlink" title="请求转发和重定向的区别"></a>请求转发和重定向的区别</h3><p><img src="https://i.loli.net/2021/09/15/NFXWRUtzvK2fcHy.png"></p><h3 id="Session对象"><a href="#Session对象" class="headerlink" title="Session对象"></a>Session对象</h3></li></ul><ol><li>用户请求服务器，此时服务器判断该请求中是否具有sessionid；如果有则根据请求中的sessionid找到对应的session对象；如果没有则创建session对象</li><li>服务响应客户端，此时服务器会将sessionid添加到响应中，并携带个客户端；客户端会将该id存储起来；当客户端下一次请求同一项目时，就会将sessionid加入到请求中</li><li>关闭浏览器时，只能清除sessionid，而不能真正的清除session对象，因为session对象是，存储在服务器端的内存中</li><li>真正销毁session对象的两个条件；1、达到了session的最大有效时间（最后一次访问session对象开始计算）           2、调用session.invalidate()<br><img src="https://s3.bmp.ovh/imgs/2021/09/ffb3ae28efe2180d.png"><br><img src="https://s3.bmp.ovh/imgs/2021/09/d130fec71578ef64.png"><h3 id="毁session"><a href="#毁session" class="headerlink" title="毁session"></a>毁session</h3></li></ol><ul><li><p>真正销毁session对象的两个条件；1、达到了session的最大有效时间（最后一次访问session对象开始计算）                2、调用session.invalidate() </p></li><li><p>部分浏览器关闭会清除sessionid，清除sessionid后在访问相同的网站，也同样会被认为是一个新的用户，这就和清除了session的现象一致；并不是真正的销毁session对象</p><h3 id="session作用域"><a href="#session作用域" class="headerlink" title="session作用域"></a>session作用域</h3><p>使用范围：在session的有效期内，整个项目都可以访问<br>时间范围：创建开始，到任一销毁条件满足，导致session被销毁时结束</p></li></ul><h3 id="session相关信息"><a href="#session相关信息" class="headerlink" title="session相关信息"></a>session相关信息</h3><p><img src="https://s3.bmp.ovh/imgs/2021/09/295626e0b5544640.png"></p><h3 id="Cookie对象"><a href="#Cookie对象" class="headerlink" title="Cookie对象"></a>Cookie对象</h3><p><img src="https://s3.bmp.ovh/imgs/2021/09/7e69b508ccf1b700.png"></p><h3 id="各种对象"><a href="#各种对象" class="headerlink" title="各种对象"></a>各种对象</h3><p><img src="https://s3.bmp.ovh/imgs/2021/09/2834c21fd4fecc48.png"><br><img src="https://s3.bmp.ovh/imgs/2021/09/2834c21fd4fecc48.png"><br><img src="https://s3.bmp.ovh/imgs/2021/09/d7cfca2c61934da7.png"><br><img src="https://s3.bmp.ovh/imgs/2021/09/b595811f72d31361.png"><br><img src="https://s3.bmp.ovh/imgs/2021/09/c3608803fcc641a7.png"></p><h3 id="Servlet过滤器"><a href="#Servlet过滤器" class="headerlink" title="Servlet过滤器"></a>Servlet过滤器</h3><ul><li>实现步骤<br>一、创建一个类，实现javax.servlet.Filter接口，并实现其中的方法</li></ul><p>Filter接口的主要方法：</p><pre><code>init(FilterConfig)：//初始化，从网站配置文件web.xml中读取过滤器参数设置doFilter(ServletRequest,ServletResponse,FilterChain)：//执行过滤操作destory()：//删除过滤器对象实例</code></pre><p>二、配置过滤器</p><pre><code>    &lt;filter&gt;        &lt;filter-name&gt;过滤器名字&lt;/filter-name&gt;        &lt;filter-class&gt;过滤器类名&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;参数名&lt;/param-name&gt;            &lt;param-value&gt;参数值&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;过滤器名字&lt;/filter-name&gt;        &lt;url-pattern&gt;访问路径&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;</code></pre><p><img src="https://s3.bmp.ovh/imgs/2021/09/39cbc8fd016b5ae3.png"><br><img src="https://s3.bmp.ovh/imgs/2021/09/da7c409013d96407.png"><br><img src="https://s3.bmp.ovh/imgs/2021/09/5c0dab2e71fc22a9.png"></p><h3 id="Servlet监听器"><a href="#Servlet监听器" class="headerlink" title="Servlet监听器"></a>Servlet监听器</h3><p><img src="https://s3.bmp.ovh/imgs/2021/09/eb20480534621883.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;servlet和jsp笔记&quot;&gt;&lt;a href=&quot;#servlet和jsp笔记&quot; class=&quot;headerlink&quot; title=&quot;servlet和jsp笔记&quot;&gt;&lt;/a&gt;servlet和jsp笔记&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>xml笔记</title>
    <link href="http://example.com/2021/09/14/xml%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/09/14/xml%E7%AC%94%E8%AE%B0/</id>
    <published>2021-09-14T06:58:00.000Z</published>
    <updated>2021-09-14T07:02:48.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xml笔记"><a href="#xml笔记" class="headerlink" title="xml笔记"></a>xml笔记</h1><span id="more"></span><h1 id="《《文章很长，目录在右下角》》"><a href="#《《文章很长，目录在右下角》》" class="headerlink" title="《《文章很长，目录在右下角》》"></a>《《文章很长，目录在右下角》》</h1><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><pre><code>package com.util;import java.io.File;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.NamedNodeMap;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import com.sun.org.apache.xerces.internal.dom.DeferredElementImpl;import com.sun.org.apache.xerces.internal.dom.DeferredNotationImpl;/** 解析xml的两种方式*     DOM（Document Object Model）方式：*         首先将整个xml文档加载到内存中，并将文档转换成文档对象，文档中的元素也会被分别转换成对象*         优点：读写方便，查找元素对象也更加的方便快捷*         缺点：太消耗内存，只适合小文件，不适合大文件*     SAX方法：*         事件驱动的方式进行文档的解析*         优点：消耗内存很少，适合处理大文件*         缺点：读写查找元素没有DOM方式快捷方便* * JDK提供了DOM和SAX方式* 常用第三方提供的xml解析的类库：JDOM、DOM4J、XPath* */public class DomParseXML &#123;    public static void main(String[] args) &#123;        try &#123;            /******************** JDK提供的DOM方式解析XML的实现 **********************/            // 1、常见DOM方式解析XML的工厂类的对象            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();            // 2、创建文档对象的建造者对象（建造者模式）            DocumentBuilder docBuilder = factory.newDocumentBuilder();                        // 创建文件对象            File xml = new File(&quot;config/users.xml&quot;);            System.out.println(xml.exists());            // 3、通过文档建造者创建文档对象            Document doc = docBuilder.parse(xml);                        // 4、通过文档对象获取元素对象或属性值或元素内容。。。            // 必须在xml的验证文件(DTD/XSD)中，将id属性设置为ID            Element userElement = doc.getElementById(&quot;id1&quot;);            System.out.println(&quot;class = &quot; + userElement.getAttribute(&quot;class&quot;));            // 根据标签的名称获取节点对象的集合            NodeList userList = doc.getElementsByTagName(&quot;user&quot;);                        for (int i = 0; i &lt; userList.getLength(); i++) &#123;                Node user = userList.item(i);                // Node.getAttributes()：获取所有属性的集合                NamedNodeMap attrs = user.getAttributes();                // 根据属性的名称，获取属性的节点对象                Node attrClass = attrs.getNamedItem(&quot;class&quot;);                // 获取属性的值                String classValue = attrClass.getNodeValue();                System.out.println(classValue);                // 获取属性id的值                System.out.println(attrs.getNamedItem(&quot;id&quot;).getNodeValue());                                // 获取所有子元素的集合                NodeList childNodes = user.getChildNodes();                for (int j = 0; j &lt; childNodes.getLength(); j++) &#123;                    Node child = childNodes.item(j);                    // 判断节点的类型，筛选出需要的元素对象（文本节点不是我们需要的）                    // 元素对象的类型：DeferredElementImpl                    // 文本节点的类型：DeferredTextImpl                    if (child instanceof DeferredElementImpl) &#123;//                        child.getAttributes().getNamedItem(&quot;value&quot;).getNodeValue();                        // 获取元素的内容                        String textContent = child.getTextContent();                        System.out.println(textContent);                    &#125;                &#125;            &#125;                    &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h2 id="SAX"><a href="#SAX" class="headerlink" title="SAX"></a>SAX</h2><pre><code>package com.util;import java.io.File;import javax.xml.parsers.SAXParser;import javax.xml.parsers.SAXParserFactory;import org.xml.sax.Attributes;import org.xml.sax.SAXException;import org.xml.sax.helpers.DefaultHandler;public class SaxParseXML &#123;    public static void main(String[] args) &#123;        try &#123;            // 1、创建SAX解析工厂            SAXParserFactory factory = SAXParserFactory.newInstance();            // 2、创建SAX解析器的对象            SAXParser parser = factory.newSAXParser();            // 创建xml文件对象            File xml = new File(&quot;config/users.xml&quot;);            // 通过自定义Handler类，创建handler对象//            SaxParseXMLHandler handler = new SaxParseXMLHandler();            // 通过匿名内部类的方式，创建Handler对象            DefaultHandler handler = new DefaultHandler() &#123;                @Override                public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123;                    // 如果开始标签的名称是user                    if (&quot;user&quot;.equals(qName)) &#123;                        // 根据属性的名称，获取属性的值                        String classValue = attributes.getValue(&quot;class&quot;);                        System.out.println(classValue);                    &#125; else if (&quot;id&quot;.equals(qName)) &#123;                        // 输出id标签中value属性的值                        System.out.println(attributes.getValue(&quot;value&quot;));                    &#125;                &#125;                                // 读取到元素内容时，调用此方法                @Override                public void characters(char[] ch, int start, int length) throws SAXException &#123;                    System.out.println(new String(ch,start,length).trim());                &#125;                        &#125;;            // 解析xml            parser.parse(xml, handler);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;package com.util;import org.xml.sax.Attributes;import org.xml.sax.SAXException;import org.xml.sax.helpers.DefaultHandler;public class SaxParseXMLHandler extends DefaultHandler &#123;    // 读取文档开始标签，会调用该方法    @Override    public void startDocument() throws SAXException &#123;    &#125;    // 读取文档结束标签，会调用该方法    @Override    public void endDocument() throws SAXException &#123;    &#125;        // 读取到一个元素的开始标签，会调用该方法    @Override    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123;        // 如果开始标签的名称是user        if (&quot;user&quot;.equals(qName)) &#123;            // 根据属性的名称，获取属性的值            String classValue = attributes.getValue(&quot;class&quot;);            System.out.println(classValue);        &#125;    &#125;    // 读取到元素内容时，调用此方法    // 参数一：是整个文档的内容（不含&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;）    // 参数二：当前读取的内容的偏移量（起始下标）    // 参数三：内容的长度    @Override    public void characters(char[] ch, int start, int length) throws SAXException &#123;            &#125;        // 读取到一个元素的结束标签，会调用该方法    @Override    public void endElement(String uri, String localName, String qName) throws SAXException &#123;            &#125;    &#125;</code></pre><h2 id="JDOM"><a href="#JDOM" class="headerlink" title="JDOM"></a>JDOM</h2><pre><code>package com.util;import java.io.File;import java.io.IOException;import java.util.List;import org.jdom2.Document;import org.jdom2.Element;import org.jdom2.JDOMException;import org.jdom2.input.DOMBuilder;import org.jdom2.input.SAXBuilder;import org.w3c.dom.Attr;import org.w3c.dom.CDATASection;import org.w3c.dom.Comment;import org.w3c.dom.DOMConfiguration;import org.w3c.dom.DOMException;import org.w3c.dom.DOMImplementation;import org.w3c.dom.DocumentFragment;import org.w3c.dom.DocumentType;import org.w3c.dom.EntityReference;import org.w3c.dom.NamedNodeMap;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.w3c.dom.ProcessingInstruction;import org.w3c.dom.Text;import org.w3c.dom.UserDataHandler;public class JDomParseXML &#123;    public static void main(String[] args) &#123;        try &#123;            SAXBuilder builder = new SAXBuilder();            Document doc = builder.build(new File(&quot;config/users.xml&quot;));            // 获取根元素（users）            Element root = doc.getRootElement();            // 根据标签名获取子元素            Element user = root.getChild(&quot;user&quot;);            // 根据属性名，获取属性值            System.out.println(user.getAttributeValue(&quot;class&quot;));            // 获取所有子元素的集合            List&lt;Element&gt; children = user.getChildren();            for (Element element : children) &#123;                // 获取元素的内容                System.out.println(element.getText());            &#125;                    &#125; catch (JDOMException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h2 id="DOM4J"><a href="#DOM4J" class="headerlink" title="DOM4J"></a>DOM4J</h2><pre><code>package com.util;import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.util.List;import org.dom4j.Attribute;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.Node;import org.dom4j.io.SAXReader;public class DOM4jParseXML &#123;    public static void main(String[] args) &#123;        try &#123;            // 创建读取文件的阅读器对象            SAXReader reader = new SAXReader();            // 读取xml文件            Document doc = reader.read(new File(&quot;config/users.xml&quot;));                        // 通过XPath查找username元素对象            Node node = doc.selectSingleNode(&quot;/users/user/username&quot;);            System.out.println(node);            System.out.println(node.getName());            System.out.println(node.getText());                                                // 获取根元素            Element root = doc.getRootElement();                        // 根据元素的ID属性获取元素对象（要求ID必须大写）//            Element user = root.elementByID(&quot;1&quot;);//            System.out.println(user);                        // 获取所有标签为user的子元素（获取所有指定标签名的子元素）            List&lt;Element&gt; childrens = root.elements(&quot;user&quot;);            for (Element child : childrens) &#123;                // getParent():获取父元素对象                System.out.println(child.getParent().getName());                // 根据属性名称，获取属性对象//                Attribute attr = child.attribute(&quot;class&quot;);//                // Attribute.getStringValue()：获取属性值//                System.out.println(attr.getStringValue());//                System.out.println(attr.getValue());                                // 获取属性值                System.out.println(child.attributeValue(&quot;class&quot;));                                // 获取user元素下的所有子元素                List&lt;Element&gt; userChildrens = child.elements();                for (Element ele : userChildrens) &#123;                    // Element.getStringValue()：获取元素的内容                    System.out.println(ele.getStringValue());                    System.out.println(ele.getText());                    System.out.println(ele.getTextTrim());                &#125;            &#125;                        /********************* 生成xml文件 **********************/            // 追加一个属性            root.addAttribute(&quot;class&quot;, &quot;com.entity.User&quot;);            // 新建一个Element对象            Element user = root.addElement(&quot;user&quot;);            Element id = user.addElement(&quot;id&quot;);            Element username = user.addElement(&quot;username&quot;);            Element password = user.addElement(&quot;password&quot;);            id.addText(&quot;2&quot;);            username.addText(&quot;李四&quot;);            password.addText(&quot;abc&quot;);            // 新建一个文件输出流            FileWriter writer = new FileWriter(&quot;E:/user.xml&quot;);            // 写出到新的xml文件中            root.write(writer);            writer.close();                    &#125; catch (DocumentException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;     &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;xml笔记&quot;&gt;&lt;a href=&quot;#xml笔记&quot; class=&quot;headerlink&quot; title=&quot;xml笔记&quot;&gt;&lt;/a&gt;xml笔记&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript笔记</title>
    <link href="http://example.com/2021/08/31/JavaScript%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/08/31/JavaScript%E7%AC%94%E8%AE%B0/</id>
    <published>2021-08-31T09:42:57.000Z</published>
    <updated>2021-11-04T06:27:36.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript笔记"><a href="#JavaScript笔记" class="headerlink" title="JavaScript笔记"></a>JavaScript笔记</h1><span id="more"></span><h1 id="《《文章很长，目录在右下角》》"><a href="#《《文章很长，目录在右下角》》" class="headerlink" title="《《文章很长，目录在右下角》》"></a>《《文章很长，目录在右下角》》</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><ul><li><p>JavaScript是一种弱类型的语言：变量的类型可以随着赋值的类型不同而发生变化</p></li><li><p>强类型的语言：一个变量一旦声明为某种类型，该变量的数据类型就不可再变</p></li><li><p>JavaScript是解释型的语言</p></li><li><p>动态的语言：可以在程序运行的过程中，给对象增加或删除成员（属性、方法）</p><h2 id="使用JavaScript的三种形式"><a href="#使用JavaScript的三种形式" class="headerlink" title="使用JavaScript的三种形式"></a>使用JavaScript的三种形式</h2>  <!DOCTYPE html>  <html>      <head>          <meta charset="utf-8">          <title>使用js的三种形式</title>          <!--           使用JavaScript的三种形式              1、行内：事件的属性上使用JavaScript代码              2、内嵌：script标签内写JavaScript代码              3、外部：先创建js文件，在js文件中编写js代码，然后通过script标签引入外部的js文件                  src：指定外部js文件的地址                  引入js文件的script标签内部不能写js代码                  引入js文件的script标签虽然内容为空，但也不能使用自封形式                  js文件中，直接写js代码即可，不需要script标签          -->          <script type="text/javascript">          function inner_m(){              alert('我被鼠标击中了...');          }          </script>          <script type="text/javascript" src="./js/index.js"></script>      </head>      <body>          <input type="button" value="点我试一试（行内）" onclick="alert('我被鼠标击中了...');">          <input type="button" value="点我试一试（内嵌）" onclick="inner_m();">          <input type="button" value="点我试一试（外部）" onclick="outer_m();">      </body>  </html>## 注释// 单行注释</li></ul><p>/* 多行注释 */</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="https://s3.bmp.ovh/imgs/2021/09/517e4f5c1de563ef.png"></p><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;声明变量&lt;/title&gt;        &lt;script&gt;        // 声明变量并赋值： var 变量名 = 值;        // 声明常量并赋值： const 变量名 = 值;        var i = 1;        // 等价于java中的System.out.println();        console.log(i);        // 获取变量的类型: typeof 变量名; // 该表达式的返回值，就是变量的数据类型名称        var t = typeof i;        console.log(&quot;变量i的数据类型：&quot; + t);        console.log(&quot;变量t的数据类型：&quot; + typeof t);                // 修改变量i的数据类型        i = &quot;1&quot;;        console.log(&quot;变量i的数据类型：&quot; + typeof i);        i = true;        console.log(&quot;变量i的数据类型：&quot; + typeof i);        i = null;        console.log(&quot;变量i的数据类型：&quot; + typeof i);        i = new XMLHttpRequest();        console.log(&quot;变量i的数据类型：&quot; + typeof i);        i = undefined;        console.log(&quot;变量i的数据类型：&quot; + typeof i);                // instanceof不要用于原始类型        i = new XMLHttpRequest();        console.log(&quot;判断变量i是否输入Object类型：&quot; + (i instanceof Object));                        var und;        console.log(und);        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="关键字typeof"><a href="#关键字typeof" class="headerlink" title="关键字typeof"></a>关键字typeof</h2><p><img src="https://s3.bmp.ovh/imgs/2021/09/337dede967653303.png"></p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;演示JavaScript中的String类型的使用&lt;/title&gt;        &lt;script&gt;        var str = &quot;abcdefgh,ijklmn   &quot;;        console.log(&quot;原始字符串：&quot; + str);        // length属性获取字符串的长度        console.log(&quot;字符串的长度：&quot; + str.length);                // 截取字符串 参数1：开始下标  参数2：结束下标        console.log(&quot;截取的开始下标为3，结束下标为5：&quot; + str.substring(3,5));        // 截取字符串 参数1：开始下标  参数2：截取的字符个数（长度）        console.log(&quot;从下标3开始截取5个字符：&quot; + str.substr(3,5));                // 删除两头的空格        console.log(&quot;trim():删除两端空格：&quot; + str.trim());        // 删除左侧的空格        console.log(&quot;trimLeft():删除两端空格：&quot; + str.trimLeft());        // 删除右侧的空格        console.log(&quot;trimRight():删除两端空格：&quot; + str.trimRight());                // 拆分字符串        var arr = str.split(&quot;,&quot;);        console.log(&quot;以逗号拆分字符串：&quot; + arr[0]);        console.log(&quot;以逗号拆分字符串：&quot; + arr[1]);                // 替换字符        console.log(&quot;mn替换成xyz：&quot; + str.replace(&quot;mn&quot;,&quot;xyz&quot;));                // 查找指定字符串的下标        console.log(&quot;indexOf:查找abc的下标：&quot; + str.indexOf(&quot;abc&quot;));        // 查找指定字符串的下标        console.log(&quot;lastIndexOf:查找abc的下标：&quot; + str.lastIndexOf(&quot;abc&quot;));        // 是否包含指定的字符串        // console.log(&quot;contains:是否包含abc：&quot; + str.contains(&quot;abc&quot;,0));        // 判断是否指定的字符串开头        console.log(&quot;startsWith:判断字符串是否以abc开头：&quot; + str.startsWith(&quot;abc&quot;));        // 判断是否指定的字符串结尾        console.log(&quot;endsWith:判断字符串是否以abc结尾：&quot; + str.endsWith(&quot;abc&quot;));        // 连接字符串        console.log(&quot;concat:连接字符串：&quot; + str.concat(&quot;oooo&quot;));        console.log(&quot;+:连接字符串：&quot; + str + &quot;oooo&quot;);                                        // 将字符串转换成大写        console.log(&quot;大写：&quot; + str.toUpperCase());        console.log(&quot;原变量str的值不变：&quot; + str);        str = &quot;ABC&quot;;        // 将字符串转换成小写        console.log(&quot;小写：&quot; + str.toLowerCase());                        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;类型转换&lt;/title&gt;        &lt;script&gt;        var i = 1;        // 将Number类型的变量i转换为String类型        var str = i.toString();        console.log(&quot;转换后的数据类型：&quot; + typeof str);        console.log(&quot;转换后原变量i的数据类型：&quot; + typeof i);                // 第二种转换形式（只要是通过new出来的对象，数据类型都是Object类型）        i = 1;        str = new String(i);        console.log(&quot;转换后的数据类型：&quot; + typeof str);        console.log(&quot;转换后的数据类型：&quot; + str);                i = 10;        // 基模式：根据指定的进制将Number类型的值，转换成字符串        console.log(&quot;将10转换为2进制的字符串：&quot; + i.toString(2));        console.log(&quot;将10转换为8进制的字符串：&quot; + i.toString(8));        console.log(&quot;将10转换为16进制的字符串：&quot; + i.toString(16));                        // 字符串转换成数字        var s = &quot;123&quot;;        // 将字符串转换为整型值        var int_ = parseInt(s);        console.log(&quot;将\&quot;123\&quot;转为整型数据：&quot; + typeof int_);        console.log(&quot;将\&quot;123\&quot;转为整型数据：&quot; + int_);                // 如果参数是小数，小数部分会被丢弃        console.log(&quot;将\&quot;123.123\&quot;转为整型数据：&quot; + typeof parseInt(&quot;123.123&quot;));        console.log(&quot;将\&quot;123.123\&quot;转为整型数据：&quot; + parseInt(&quot;123.123&quot;));                // 如果字符串是以数字开头的就可以转换成功，直到第一个不为数字的字符，其后所有字符都被丢弃        console.log(&quot;将\&quot;123abc\&quot;转为整型数据：&quot; + typeof parseInt(&quot;123abc123&quot;));        console.log(&quot;将\&quot;123abc\&quot;转为整型数据：&quot; + parseInt(&quot;123abc123&quot;));                // 如果字符串是不是以数字开头的，也可以转换成功，转换后的值是NaN（Not a Number）        console.log(&quot;将\&quot;abc123\&quot;转为整型数据：&quot; + typeof parseInt(&quot;abc123&quot;));        console.log(&quot;将\&quot;abc123\&quot;转为整型数据：&quot; + parseInt(&quot;abc123&quot;));                        // 将字符串转换为浮点型值        console.log(&quot;将\&quot;123.123\&quot;转为浮点型数据：&quot; + typeof parseFloat(&quot;123.123&quot;));        console.log(&quot;将\&quot;123.123\&quot;转为浮点型数据：&quot; + parseFloat(&quot;123.123&quot;));                // 如果字符串是以数字开头的就可以转换成功，直到第一个不为数字或小数点的字符，其后所有字符都被丢弃        console.log(&quot;将\&quot;123.1abc\&quot;转为浮点型数据：&quot; + typeof parseFloat(&quot;123.1abc123&quot;));        console.log(&quot;将\&quot;123.1abc\&quot;转为浮点型数据：&quot; + parseFloat(&quot;123.1abc123&quot;));                // 如果字符串是不是以数字开头的，也可以转换成功，转换后的值是NaN（Not a Number）        console.log(&quot;将\&quot;abc123.1\&quot;转为浮点型数据：&quot; + typeof parseFloat(&quot;abc123.1&quot;));        console.log(&quot;将\&quot;abc123.1\&quot;转为浮点型数据：&quot; + parseFloat(&quot;abc123.1&quot;));                // parseInt(&quot;123abc&quot;)转换的结果：123;        // new Number(&quot;123abc&quot;)转换的结果：NaN;        var num = new Number(&quot;123abc&quot;);        console.log(&quot;将\&quot;123\&quot;转为Number类型的数据：&quot; + typeof num);        console.log(&quot;将\&quot;123\&quot;转为Number类型的数据：&quot; + (num + 1));        // NaN:自己都不等于自己，所以不能用双等号来判断一个变量是否是NaN        console.log(&quot;判断num的值是否是NaN：&quot; + (NaN == NaN));        console.log(&quot;判断num的值是否是NaN：&quot; + (num == NaN));        console.log(&quot;isNaN判断num的值是否是NaN：&quot; + isNaN(num));                // 其他的数据类型转换成布尔类型        num = 0;        var bool = new Boolean(num);        console.log(&quot;将数字转换为boolean类型：&quot; + typeof bool);        console.log(&quot;将数字转换为boolean类型：&quot; + bool);        // javascript中的流程控制和java中的一样（if、if-else、while、do-while、for）        // 当其他类型用作布尔表达式时，js会自动将数据转换成boolean类型        if(num)&#123;                    &#125;else&#123;            console.log(&quot;0会被转换为false&quot;);        &#125;        // 0、null、undefined、空字符串 会被转换为false，其余的值都会被转换为true        console.log(&quot;将0转换为boolean类型：&quot; + new Boolean(0));        console.log(&quot;将null转换为boolean类型：&quot; + new Boolean(null));        console.log(&quot;将undefined转换为boolean类型：&quot; + new Boolean(undefined));        console.log(&quot;将空字符串转换为boolean类型：&quot; + new Boolean(&quot;&quot;));        console.log(&quot;将\&quot;false\&quot;转换为boolean类型：&quot; + new Boolean(&quot;false&quot;));        if(0 &amp;&amp; null)&#123;                    &#125;else&#123;            console.log(&quot;0会被转换为false&quot;);        &#125;                        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;运算符&lt;/title&gt;        &lt;script&gt;        var i = 1;        var str = &quot;1&quot;;        var i2 = 2;        var str2 = &quot;2&quot;;        var i3 = 3;        var i4 = 3;                // ==：只比较值（内容），不比较数据类型；只要内容相同，就返回true；否则返回false        // 相当于 内容1 == 内容2 || 数据类型1 == 数据类型2        console.log( i == str );        // ===：即比较值（内容），也比较数据类型；数据类型和内容都相同时，结果为true；否则结果为false        // 相当于  内容1 == 内容2 &amp;&amp; 数据类型1 == 数据类型2        console.log( i === str );        // !=：内容和数据类型，都不相同时，返回true；否则返回false        // 相当于  内容1 != 内容2 &amp;&amp; 数据类型1 != 数据类型2        console.log( i2 != str2 );        // !==：内容和数据类型，只要有一项不同，就返回true；否则返回false        // 相当于  内容1 != 内容2 || 数据类型1 != 数据类型2        console.log( i2 !== str2 );        console.log( i3 !== str2 );        console.log( i3 !== i4 );        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script&gt;        var arr = [1,2,3,4,5,6];        for(var i=0;i&lt;arr.length;i++)&#123;            console.log(arr[i]);        &#125;        // index：每循环一次，index就会获取数组arr的一个下标        // for(var prop : 对象)&#123;&#125; ：每循环一次，prop就会获取对象的一个属性（用于遍历对象上的属性，如果将一个对象看做map集合的话，遍历的就是map的key）        for(var index in arr)&#123;            console.log(arr[index]);        &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;数组&lt;/title&gt;        &lt;script&gt;        // 声明数组，并创建数组对象赋值        // 数组常量：[值1,值2,...,值n]        var arr1 = [1,2,3];        console.log(arr1[4]);        // 创建数组对象：new Array(长度); 默认的元素值都是undefined        var arr2 = new Array(3);        for(var i = 0; i &lt; arr2.length; i++)&#123;            console.log(arr2[i]);        &#125;                // js没有数组和collection集合之分的        var arr3 = new Array();        arr3[0] = 10;        arr3[3] = 10;        console.log(arr3.length);        console.log(arr3[0]);        console.log(arr3[1]);        console.log(arr3[2]);        console.log(arr3[3]);        console.log(arr3[4]);                        var arr4 = new Array(1,4,5,67,8,2);        console.log(arr4[0]);        console.log(arr4[1]);        console.log(arr4[2]);        console.log(arr4[3]);        console.log(arr4[4]);                // forEach(方法名);  循环执行参数方法        arr4.forEach(loop);        // 参数一：获取数组中的元素值   参数二：获取数组的下标        function loop(value,index)&#123;            console.log(value + &quot;-&quot; + index);        &#125;                &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;函数&lt;/title&gt;        &lt;script&gt;        // 声明函数  function 函数名(变量名1,...,变量名n)&#123; [return [返回值];] &#125;        // 注意：参数直接参数名即可，一定不能使用var进行声明        function add(a,b)&#123;            console.log(&quot;a=&quot; + a);            console.log(&quot;b=&quot; + b);            return a + b;        &#125;        // 调用方法        var result = add(1,2);        console.log(&quot;result=&quot;+result);                // function(变量名1,...,变量名n)&#123;&#125; 声明一个匿名方法        // 函数的声明方式二：var 方法名 = function(变量名1,...,变量名n)&#123;&#125;        var m1 = function(a)&#123;            console.log(&quot;a=&quot;+a);        &#125;        // 调用方法        m1(100);        var m3 = m1;        // 调用方法        m3(200);                function m4(m5)&#123;            m5(500);        &#125;        m4(m3);                // 获取方法参数的个数        console.log(&quot;获取参数的个数：&quot; + m1.length);        // 获取方法的源代码        console.log(m1);        console.log(m1.valueOf());        console.log(m1.toString());                m1.name = &quot;m1方法&quot;;        // 遍历m1上的属性        // for(var property in m1)&#123;        //     console.log(&quot;property = &quot; + property);        // &#125;                // 类型是Function        console.log(typeof m1);                        // 函数的声明方式三：var 方法名 = new Function([&quot;参数列表&quot;],[&quot;方法体&quot;]);        var m2 = new Function(&quot;a&quot;,&quot;console.log(a)&quot;);        // 调用方法        m2(10);                        // 方法重载        function f()&#123;            console.log(&quot;没有参数的方法&quot;);            var result = 0;            // arguments:获取方法的参数（实参）列表（数组）            for(var index in arguments)&#123;                // 如果参数的数据类型是function，则调用该方法                // if(typeof arguments[index] == &quot;function&quot;)&#123;                if(arguments[index] instanceof Function)&#123;                    // 调用传入的方法                    arguments[index]();                &#125; else &#123;                    console.log(&quot;参数：&quot; + arguments[index]);                    result += arguments[index];                &#125;            &#125;            return result;        &#125;        // function f(a)&#123;        //     console.log(&quot;有一个参数的方法&quot;);        // &#125;        var sum = f(1,2,3,4,5,6,7,8,9,10,function()&#123;            console.log(&quot;参数传入的匿名方法&quot;);        &#125;);        console.log(sum);        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;对象&lt;/title&gt;        &lt;script&gt;        // 创建对象：new Object();        var obj1 = new Object();        // 给对象添加一个name属性：对象名.属性名 = 值;        obj1.name = &quot;张三&quot;;        obj1.age = 18;        // 给对象添加方法        obj1.print = function()&#123;            // this指向当前对象的引用            console.log(&quot;姓名：&quot; + this.name + &quot; 年龄：&quot; + this.age);        &#125;;        // 删除指定对象的属性：delete 对象名.属性名;        delete obj1.age;        console.log(obj1);        console.log(obj1.name);        console.log(obj1.age);        // 调用print方法        obj1.print();                // 方式二：创建对象  &#123;&quot;属性1&quot;:值1,...,&quot;属性n&quot;:值n&#125;        var user = &#123;&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:20,&quot;sex&quot;:&quot;男&quot;,                    &quot;print&quot;:function()&#123;                        console.log(&quot;user&quot;);                    &#125;&#125;;        // 访问属性：对象.属性名     对象[&quot;属性名&quot;]        console.log(user.name);        console.log(user.age);        console.log(user.sex);        user.print();        var name = &quot;name&quot;;        console.log(user[name]);        console.log(user[&quot;age&quot;]);        console.log(user[&quot;sex&quot;]);                // 遍历对象的属性        for(var property in user)&#123;            console.log(&quot;属性：&quot; + property + &quot; - 值：&quot; + user[property]);        &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;异常&lt;/title&gt;        &lt;script&gt;        function div(a,b)&#123;            var result = 0;            try&#123;                // result = a/b;                // 抛出一个异常                throw new RangeException();            &#125; catch(e)&#123;                console.log(&quot;异常：&quot; + e);            &#125; finally &#123;                console.log(&quot;finally&quot;);            &#125;            return result;        &#125;        // js中除0的结果是：无穷大        var result = div(10,0);        console.log(result);        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="获取文档中的元素对象"><a href="#获取文档中的元素对象" class="headerlink" title="获取文档中的元素对象"></a>获取文档中的元素对象</h2><p><img src="https://s3.bmp.ovh/imgs/2021/09/4e4ec0d5ddcd67eb.png"><br>获取元素对象</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;获取元素对象&lt;/title&gt;        &lt;script&gt;        // 整个的HTML文档会被转换成一个 document 的对象        // 声明获取元素对象的方法        function getEle()&#123;            // getElementById(id值):根据ID获取元素对象，如果有多个相同id的元素，getElementById方法只会获取第一个id值和参数相同的元素            // 获取id=p1的p元素            // js中遵守了HTML规范，元素id的唯一性            var p = document.getElementById(&quot;p1&quot;);            // 注意：浏览器解析HTML文档，是自上而下解析的；            // 如果获取元素对象的js代码，在要获取的元素被解析之前执行，则无法获取元素对象            // 解决方式有两种            // 1、将获取元素对象的js代码，放到被获取的元素之后            // 2、在body的onload事件中执行获取元素对象的js代码            console.log(p);        &#125;        // 调用获取元素对象的方法        getEle();        &lt;/script&gt;    &lt;/head&gt;    &lt;!-- onload事件：在文档解析完成之后，才会触发该事件 --&gt;    &lt;body onload=&quot;getEle()&quot;&gt;        &lt;p id=&quot;p1&quot;&gt; 段落内容-1 &lt;/p&gt;        &lt;p id=&quot;p1&quot;&gt; 段落内容-2 &lt;/p&gt;        &lt;input id=&quot;username&quot; value=&quot;admin&quot; type=&quot;text&quot; /&gt;    &lt;/body&gt;        &lt;!-- &lt;script&gt;    // 整个的HTML文档会被转换成一个 document 的对象    // 声明获取元素对象的方法    function getEle()&#123;        // 根据ID获取元素对象        // 获取id=p1的p元素        var p = document.getElementById(&quot;p1&quot;);        // 注意：浏览器解析HTML文档，是自上而下解析的；        // 如果获取元素对象的js代码，在要获取的元素被解析之前执行，则无法获取元素对象        // 解决方式有两种        // 1、将获取元素对象的js代码，放到被获取的元素之后        console.log(p);    &#125;    // 调用获取元素对象的方法    getEle();    &lt;/script&gt; --&gt;&lt;/html&gt;</code></pre><p>获取多个元素对象</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;p id=&quot;p1&quot; class=&quot;p1&quot; name=&quot;n1&quot;&gt; 段落内容-1 &lt;/p&gt;        &lt;p id=&quot;p1&quot; class=&quot;p1 p2&quot; name=&quot;n1&quot;&gt; 段落内容-2 &lt;/p&gt;        &lt;input id=&quot;username&quot; class=&quot;p2&quot; name=&quot;n2&quot; value=&quot;admin&quot; type=&quot;text&quot; /&gt;    &lt;/body&gt;    &lt;script&gt;    function getEles()&#123;        // 获取多个元素        // getElementsByClassName(class属性值)：获取所有class属性含有参数值的元素对象        // 注意：IE浏览器不支持getElementsByClassName方法        var arr = document.getElementsByClassName(&quot;p1&quot;);        console.log(arr);        console.log(arr[0]);        console.log(arr[1]);        // getElementsByName(name属性值):获取所有name属性和参数值相同的元素对象        var arrByName = document.getElementsByName(&quot;n1&quot;);        console.log(arrByName);                // getElementsByTagName(标签名):根据标签的名称获取元素对象        var arrByTagName = document.getElementsByTagName(&quot;p&quot;);        console.log(arrByTagName);        console.log(arrByTagName[0]);        console.log(arrByTagName[1]);        console.log(arrByTagName[&quot;n1&quot;]);        console.log(arrByTagName[&quot;p1&quot;]);        console.log(arrByTagName.n1);        console.log(arrByTagName.p1);            &#125;    getEles();    &lt;/script&gt;&lt;/html&gt;</code></pre><h2 id="获取元素内容"><a href="#获取元素内容" class="headerlink" title="获取元素内容"></a>获取元素内容</h2><p><img src="https://s3.bmp.ovh/imgs/2021/09/3b5e7dbc790368b5.png"><br>获取和设置元素的内容</p><pre><code>&lt;!DOCTYPE html&gt;&lt;h获取和设置元素的内容tml&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;获取和设置元素的内容&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;p id=&quot;p1&quot;&gt; 段落内容-1 &lt;/p&gt;        &lt;p id=&quot;p2&quot;&gt; pre --- &lt;span&gt;段落内容-2&lt;/span&gt; --- next &lt;/p&gt;                &lt;p id=&quot;p3&quot;&gt;&lt;/p&gt;        &lt;p id=&quot;p4&quot;&gt;&lt;/p&gt;        &lt;p id=&quot;p5&quot;&gt;&lt;/p&gt;        &lt;p id=&quot;p6&quot;&gt;&lt;/p&gt;        &lt;script&gt;        // 获取元素的内容        function getContent()&#123;            // 1、获取元素            var p = document.getElementById(&quot;p1&quot;);            // 2、获取元素的内容            console.log(&quot;innerHTML获取元素内容：&quot; + p.innerHTML);            console.log(&quot;innerText获取元素内容：&quot; + p.innerText);            // IE浏览器不支持textContent            console.log(&quot;textContent获取元素内容：&quot; + p.textContent);                                    var p2 = document.getElementById(&quot;p2&quot;);            // 如果元素内容中包含HTML标签，则innerHTML获取的内容是含HTML标签的，而innerText和textContent获取的内容是不含HTML标签的（只获取文本内容）            console.log(&quot;innerHTML获取元素内容：&quot; + p2.innerHTML);            console.log(&quot;innerText获取元素内容：&quot; + p2.innerText);            console.log(&quot;textContent获取元素内容：&quot; + p2.textContent);                                    var p3 = document.getElementById(&quot;p3&quot;);            p3.innerHTML = &quot;abc&quot;;            var p4 = document.getElementById(&quot;p4&quot;);            p4.innerText = &quot;abc&quot;;            var p5 = document.getElementById(&quot;p5&quot;);            // 如果设置的元素内容中包含HTML标签            // 使用innerHTML设置，则会解析HTML标签            // 使用innerText设置，不会解析HTML标签，而是将HTML标签作为字符串（文本）显示在页面上            p5.innerHTML = &quot;&lt;font color=&#39;red&#39;&gt; abc &lt;/font&gt;&quot;;            var p6 = document.getElementById(&quot;p6&quot;);            p6.innerText = &quot;&lt;font color=&#39;red&#39;&gt; abc &lt;/font&gt;&quot;;                    &#125;        getContent();        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>获取和设置元素的属性2</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;获取和设置元素的属性&lt;/title&gt;        &lt;style&gt;        .message&#123;            color: red;            padding: 0px 10px;            margin: 0px 5px;        &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--         id、class、style：大部分元素都有的原生属性        name、type、value：表单控件拥有的原生属性        src、title、alt：img元素的原生属性        href、target：a元素的原生属性        --&gt;        用户名：&lt;input id=&quot;username&quot; type=&quot;text&quot; /&gt;&lt;span id=&quot;username_msg&quot; class=&quot;message&quot;&gt;&lt;/span&gt;        &lt;br /&gt;        密码：&lt;input id=&quot;password&quot; name=&quot;pass&quot; type=&quot;password&quot; /&gt;&lt;span id=&quot;password_msg&quot; class=&quot;message&quot;&gt;&lt;/span&gt;        &lt;br /&gt;        &lt;!-- 点击该按钮时，触发onclick事件，事件被触发就会执行testAttribute() --&gt;        &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;testAttribute();&quot; /&gt;                &lt;span id=&quot;span1&quot; name=&quot;span_name&quot; value=&quot;span_value&quot;&gt;&lt;/span&gt;                &lt;script&gt;        function testAttribute()&#123;            // 1、获取元素对象            var username = document.getElementById(&quot;username&quot;);            // 2、获取元素的原生属性值：元素对象.原生属性名            var username_value = username.value;            if(username_value == &quot;&quot;)&#123;                document.getElementById(&quot;username_msg&quot;).innerHTML = &quot;用户名不能为空&quot;;            &#125; else &#123;                document.getElementById(&quot;username_msg&quot;).innerHTML = &quot;&quot;;                console.log(&quot;username = &quot; + username_value);            &#125;                        var password = document.getElementById(&quot;password&quot;);            var password_value = password.value;                console.log(&quot;password_name = &quot; + password.name);            if(password_value == &quot;&quot; || password_value == null)&#123;                document.getElementById(&quot;password_msg&quot;).innerHTML = &quot;密码不能为空&quot;;            &#125; else &#123;                document.getElementById(&quot;password_msg&quot;).innerHTML = &quot;&quot;;                password.value += &quot;456&quot;;                console.log(&quot;password = &quot; + password.value);            &#125;                        var span = document.getElementById(&quot;span1&quot;);            console.log(&quot;span的name值：&quot; + span.name);            // setAttribute(&quot;属性名&quot;,&quot;值&quot;); 设置属性值            span.setAttribute(&quot;value&quot;,&quot;aaaaaaaaaaaaaaaaa&quot;);            // getAttribute(&quot;非原生属性名&quot;)：获取指定的属性值（非原生属性）            // getAttribute(&quot;原生属性名&quot;)：IE支持、Google浏览器不支持            console.log(&quot;span的值：&quot; + span.getAttribute(&quot;value&quot;));                        // 获取元素属性的集合：元素对象.attributes;            var attrs = span.attributes;            console.log(attrs);            // 修改指定的属性值            attrs[1].value = &quot;bbbbbbbbbbbbb&quot;;            // 获取指定属性的值            console.log(&quot;id=&quot; + attrs[0].value);            console.log(&quot;value=&quot; + attrs[1].value);                                    console.log(&quot;getAttributeNode = &quot; + span.getAttributeNode(&quot;value&quot;).value)        &#125;                &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>获取单选框，复选框和下拉列表</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input name=&quot;sex&quot; type=&quot;radio&quot; value=&quot;男&quot; /&gt;男        &lt;input name=&quot;sex&quot; type=&quot;radio&quot; value=&quot;女&quot; /&gt;女        &lt;br /&gt;        &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; value=&quot;吃饭&quot; /&gt;吃饭        &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; value=&quot;睡觉&quot; /&gt;睡觉        &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; value=&quot;打豆豆&quot; /&gt;打豆豆        &lt;br /&gt;        &lt;select id=&quot;city&quot; name=&quot;city&quot;&gt;            &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;            &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt;            &lt;option value=&quot;guangzhou&quot;&gt;广州&lt;/option&gt;        &lt;/select&gt;        &lt;br /&gt;        &lt;input type=&quot;button&quot; value=&quot;测试&quot; onclick=&quot;test()&quot;/&gt;                &lt;script&gt;        function test()&#123;            var sex = document.getElementsByName(&quot;sex&quot;);            for(var i = 0; i &lt; sex.length; i++ )&#123;                // 获取单选框是否被选中的状态                console.log(sex[i].checked);                // 输出被选中的值            &#125;            var hobby = document.getElementsByName(&quot;hobby&quot;);            for(var i = 0; i &lt; hobby.length; i++ )&#123;                // 获取复选框是否被选中的状态                console.log(hobby[i].checked);                // 输出被选中的值            &#125;                        var select = document.getElementById(&quot;city&quot;);            // 获取被选中的option的value值                console.log(select.value);                                &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="子元素"><a href="#子元素" class="headerlink" title="子元素"></a>子元素</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;子元素&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;ul id=&quot;list&quot;&gt;            &lt;li id=&quot;li_id&quot; class=&quot;li_class&quot; onclick=&quot;changeColor(this)&quot;&gt;电脑数码&lt;/li&gt;            &lt;li class=&quot;li_class&quot; onclick=&quot;changeColor(this)&quot;&gt;大小家电&lt;/li&gt;            &lt;li onclick=&quot;changeColor(this)&quot;&gt;厨卫用品&lt;/li&gt;            &lt;li onclick=&quot;changeColor(this)&quot;&gt;母婴用品&lt;/li&gt;            &lt;li onclick=&quot;changeColor(this)&quot;&gt;户外用品&lt;/li&gt;        &lt;/ul&gt;        &lt;div&gt;&lt;/div&gt;        &lt;script&gt;        function changeColor(li)&#123;            var ul = document.getElementById(&quot;list&quot;);            var childs = ul.children;            // 现将所有的li都设置成蓝色            for(var i=0;i&lt;childs.length;i++)&#123;                childs[i].style.color = &quot;blue&quot;;            &#125;            // 再将被点击的li元素设置成红色            li.style.color = &quot;red&quot;;        &#125;        // 获取ul元素        var ul = document.getElementById(&quot;list&quot;);        var list = ul.getElementsByTagName(&quot;li&quot;);        console.log(list);        list = ul.getElementsByClassName(&quot;li_class&quot;);        console.log(list);        // hidden：获取和设置隐藏的状态                // childElementCount:获取子元素的个数        // parentNode：父节点        // childNodes（集合类型：NodeList）：获取子节点的集合（集合中的每个元素都是一个Node（节点）对象）（注意：HTML中的换行会被当做文本节点（Text Node））        // firstChild：获取第一个节点        // lastChild：获取最后一个节点        // previousSibling：当前节点的前一个节点        // nextSibling：当前节点的下个节点                // parentElement：父元素        // children（集合类型：HTMLCollection）：获取子元素的集合（只获取HTML元素，不包含换行空格等）        // firstElementChild:获取第一个元素（IE不支持）        // lastElementChild：获取最后一个元素（IE不支持）        // previousElementSibling：当前元素的前一个元素（IE不支持）        // nextElementSibling：当前元素的下一个元素（IE不支持）        console.log(ul);        console.log(ul.children);        var childs = ul.children;        for(var i=0;i&lt;childs.length;i++)&#123;            childs[i].style.color = &quot;blue&quot;;        &#125;        var firstLi = ul.firstElementChild;        firstLi.style.color = &quot;red&quot;;                &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="创建和删除子元素"><a href="#创建和删除子元素" class="headerlink" title="创建和删除子元素"></a>创建和删除子元素</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;创建和添加子元素&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;parent_div&quot;&gt;            &lt;input type=&quot;button&quot; value=&quot;添加用户&quot; onclick=&quot;addUser();&quot; /&gt;            &lt;div id=&quot;title&quot;&gt;                &lt;span&gt; 用户名 &lt;/span&gt;                &lt;span&gt; 密码 &lt;/span&gt;                &lt;span&gt; 操作 &lt;/span&gt;            &lt;/div&gt;            &lt;div id=&quot;content&quot;&gt;                &lt;div&gt;                    &lt;span&gt; 张三 &lt;/span&gt;                    &lt;span&gt; abc &lt;/span&gt;                    &lt;span&gt;                         &lt;input type=&quot;button&quot; value=&quot;删除用户&quot; onclick=&quot;delUser(this.parentElement.parentElement);&quot; /&gt;                    &lt;/span&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;script&gt;        function addUser()&#123;            var content = document.getElementById(&quot;content&quot;);            // 方式一：通过innerHTML属性添加子元素            // 1、首先获取原内容            // var html = content.innerHTML;            // // 追加内容            // html += &quot;&lt;div&gt;&quot;             //     + &quot;&lt;span&gt; &lt;input id=&#39;username&#39; type=&#39;text&#39; /&gt; &lt;/span&gt;&quot;            //     + &quot;&lt;span&gt; &lt;input id=&#39;password&#39; type=&#39;text&#39; /&gt; &lt;/span&gt;&quot;            //     + &quot;&lt;span&gt; &lt;input type=&#39;button&#39; value=&#39;保存&#39; onclick=&#39;save(this);&#39; /&gt;&quot;             //     + &quot;&lt;input type=&#39;button&#39; value=&#39;删除&#39;  onclick=&#39;del(this);&#39; /&gt; &lt;/span&gt;&quot;            //     + &quot;&lt;/div&gt;&quot;;            // // 将追加后的内容赋值到innerHTML上            // content.innerHTML = html;                        // 方式二：通过JavaScript代码创建            // 创建元素            var div = document.createElement(&quot;div&quot;);            var spanUsername = document.createElement(&quot;span&quot;);            var spanPassword = document.createElement(&quot;span&quot;);            var spanButton = document.createElement(&quot;span&quot;);            var inputUsername = document.createElement(&quot;input&quot;);            var inputPassword = document.createElement(&quot;input&quot;);            var inputSave = document.createElement(&quot;input&quot;);            inputSave.value = &#39;保存&#39;;            inputSave.type = &#39;button&#39;;            inputSave.setAttribute(&quot;onclick&quot;,&#39;save(this);&#39;);            var inputDelete = document.createElement(&quot;input&quot;);            inputDelete.value = &#39;删除&#39;;            inputDelete.type = &#39;button&#39;;            inputDelete.setAttribute(&quot;onclick&quot;,&#39;del(this);&#39;);            // inputDelete.onclick = &quot;del(this);&quot;;            // 组装对象            spanUsername.appendChild(inputUsername);            spanPassword.appendChild(inputPassword);            spanButton.appendChild(inputSave);            spanButton.appendChild(inputDelete);            div.appendChild(spanUsername);            div.appendChild(spanPassword);            div.appendChild(spanButton);            content.appendChild(div);        &#125;        function delUser(div)&#123;            // 删除当前元素            div.remove();        &#125;        function del(btn)&#123;            // 删除元素            btn.parentElement.parentElement.remove();        &#125;        function save(btn)&#123;            // 获取保存按钮的父元素            var btnSpan = btn.parentElement;            // 获取password的父元素            var passwrodSpan = btnSpan.previousElementSibling;            // 获取password输入框            var passwordInput = passwrodSpan.firstElementChild;            // 获取密码框输入的值            var passwrodValue = passwordInput.value;            // 将密码框替换成密码框中输入的值            passwrodSpan.innerHTML = passwrodValue;                                    // 获取username的父元素            var usernameSpan = passwrodSpan.previousElementSibling;            // 获取username输入框            var usernameInput = usernameSpan.firstElementChild;            // 获取文本框输入的值            var usernameValue = usernameInput.value;            // 将文本框替换成文本框中输入的值            usernameSpan.innerHTML = usernameValue;                        btn.remove();        &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="获取焦点的事件-和-失去焦点的事件"><a href="#获取焦点的事件-和-失去焦点的事件" class="headerlink" title="获取焦点的事件 和 失去焦点的事件"></a>获取焦点的事件 和 失去焦点的事件</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--         onfocus：获取焦点的事件        onblur：失去焦点的事件        --&gt;        &lt;input id=&quot;username&quot; value=&quot;请输入用户名&quot;         onfocus=&quot;clearValue(this)&quot;         onblur=&quot;fillValue(this)&quot; /&gt;        &lt;!-- html5中提供placeholder属性可以实现相同的功能 --&gt;        &lt;input placeholder=&quot;请输入&quot; /&gt;        &lt;script&gt;            function clearValue(input)&#123;                if(input.value == &quot;请输入用户名&quot;)&#123;                    input.value = &quot;&quot;;                &#125;            &#125;            function fillValue(input)&#123;                if(input.value == &quot;&quot;)&#123;                    input.value = &quot;请输入用户名&quot;;                &#125;            &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="change事件"><a href="#change事件" class="headerlink" title="change事件"></a>change事件</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;select onchange=&quot;ch(this)&quot;&gt;            &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;            &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt;            &lt;option value=&quot;guangzhou&quot;&gt;广州&lt;/option&gt;        &lt;/select&gt;        &lt;script&gt;        function ch(select)&#123;            console.log(select.value);        &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="级联联动"><a href="#级联联动" class="headerlink" title="级联联动"></a>级联联动</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;三级联动&lt;/title&gt;    &lt;/head&gt;    &lt;body onload=&quot;init()&quot;&gt;        &lt;select id=&quot;provinces&quot; onchange=&quot;changeProvincesOption(this)&quot;&gt;&lt;/select&gt;        &lt;select id=&quot;city&quot; onchange=&quot;changeCityOption(this)&quot;&gt;&lt;/select&gt;        &lt;select id=&quot;area&quot;&gt;&lt;/select&gt;        &lt;script&gt;        // 声明在方法外，是全局变量        // 声明在方法内，是局部变量        // 创建一个country对象        var country = &#123;&quot;provinces&quot;:[                &#123;                    &quot;name&quot;:&quot;北京&quot;,                    &quot;value&quot;:&quot;beijing&quot;,                    &quot;city&quot;:[                        &#123;                            &quot;name&quot;:&quot;北京&quot;,                            &quot;value&quot;:&quot;beijing&quot;,                            &quot;area&quot;:[                                &#123;                                    &quot;name&quot;:&quot;海淀区&quot;,                                    &quot;value&quot;:&quot;haidian&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;朝阳区&quot;,                                    &quot;value&quot;:&quot;chaoyang&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;昌平区&quot;,                                    &quot;value&quot;:&quot;changping&quot;                                &#125;]                        &#125;                    ]                &#125;,&#123;                    &quot;name&quot;:&quot;上海&quot;,                    &quot;value&quot;:&quot;shanghai&quot;,                    &quot;city&quot;:[                        &#123;                            &quot;name&quot;:&quot;上海&quot;,                            &quot;value&quot;:&quot;shanghai&quot;,                            &quot;area&quot;:[                                &#123;                                    &quot;name&quot;:&quot;浦东区&quot;,                                    &quot;value&quot;:&quot;pudong&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;宝山区&quot;,                                    &quot;value&quot;:&quot;baoshan&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;虹口区&quot;,                                    &quot;value&quot;:&quot;hongkou&quot;                                &#125;]                        &#125;                    ]                &#125;,&#123;                    &quot;name&quot;:&quot;广州&quot;,                    &quot;value&quot;:&quot;guangzhou&quot;,                    &quot;city&quot;:[                        &#123;                            &quot;name&quot;:&quot;广州&quot;,                            &quot;value&quot;:&quot;guangzhou&quot;,                            &quot;area&quot;:[                                &#123;                                    &quot;name&quot;:&quot;白云区&quot;,                                    &quot;value&quot;:&quot;baiyun&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;朝阳区&quot;,                                    &quot;value&quot;:&quot;chaoyang&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;昌平区&quot;,                                    &quot;value&quot;:&quot;changping&quot;                                &#125;]                        &#125;                    ]                &#125;,&#123;                    &quot;name&quot;:&quot;内蒙古&quot;,                    &quot;value&quot;:&quot;neimenggu&quot;,                    &quot;city&quot;:[                        &#123;                            &quot;name&quot;:&quot;呼和浩特&quot;,                            &quot;value&quot;:&quot;huhehaote&quot;,                            &quot;area&quot;:[                                &#123;                                    &quot;name&quot;:&quot;新城区&quot;,                                    &quot;value&quot;:&quot;xingcheng&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;赛罕区&quot;,                                    &quot;value&quot;:&quot;saihan&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;回民区&quot;,                                    &quot;value&quot;:&quot;huimin&quot;                                &#125;]                        &#125;,                        &#123;                            &quot;name&quot;:&quot;赤峰市&quot;,                            &quot;value&quot;:&quot;chifeng&quot;,                            &quot;area&quot;:[                                &#123;                                    &quot;name&quot;:&quot;阿鲁科尔沁旗&quot;,                                    &quot;value&quot;:&quot;alukeerqinqi&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;红山区&quot;,                                    &quot;value&quot;:&quot;hongshan&quot;                                &#125;]                        &#125;                    ]                &#125;            ]&#125;;                    // 初始化的方法（将数据填充到select中）        // 声明一个用于保存省份全局变量，用来保存当前选中的省份对象        var provinces = null;        function init()&#123;            // 获取省份的select            var provinces = document.getElementById(&quot;provinces&quot;);            // 获取城市的select            var city = document.getElementById(&quot;city&quot;);            // 获取行政区的select            var area = document.getElementById(&quot;area&quot;);                        /*************************** 填充省份的select - 开始 *******************************/            var provincesOption = &quot;&quot;;            // 循环填充省份            for(var i=0;i&lt;country.provinces.length;i++)&#123;                provincesOption += &quot;&lt;option value=&#39;&quot;                                 + country.provinces[i].value                                + &quot;&#39;&gt;&quot;                                + country.provinces[i].name                                + &quot;&lt;/option&gt;&quot;;            &#125;            provinces.innerHTML = provincesOption;            /*************************** 填充省份的select - 结束 *******************************/                                    changeProvincesOption(provinces);                    &#125;                /*            参数：省份select对象        */        function changeProvincesOption(provincesSelect)&#123;                        /*************************** 循环查找被选中的省份对象 - 开始 *******************************/            // 获取被选中省份的option的value值            var provincesValue = provincesSelect.value;            // var provinces = null;            for(var i = 0;i &lt; country.provinces.length;i++)&#123;                if(country.provinces[i].value == provincesValue)&#123;                    // 给全局变量provinces赋值（当前选中的对象）                    provinces = country.provinces[i];                &#125;            &#125;            /*************************** 循环查找被选中的省份对象 - 结束 *******************************/                                    /*************************** 填充城市的select - 开始 *******************************/            // 获取当前选中的省份下，所有的城市            var cityList = provinces.city;            var cityOption = &quot;&quot;;            // 循环填充城市            for(var i=0;i&lt;cityList.length;i++)&#123;                cityOption += &quot;&lt;option value=&#39;&quot;                                 + cityList[i].value                                + &quot;&#39;&gt;&quot;                                + cityList[i].name                                + &quot;&lt;/option&gt;&quot;;            &#125;            document.getElementById(&quot;city&quot;).innerHTML = cityOption;            /*************************** 填充城市的select - 开始 *******************************/                        changeCityOption(provinces.city[0]);        &#125;                /*        参数：当前被选中的城市select对象        */        function changeCityOption(citySelect)&#123;            /*************************** 查找当前被选中的city对象 - 开始 *******************************/            // 获取当前选中的城市的option的value值            var cityValue = citySelect.value;            for(var i=0;i&lt;provinces.city.length;i++)&#123;                if(cityValue == provinces.city[i].value)&#123;                    changeCity(provinces,provinces.city[i]);                    break;                &#125;            &#125;            /*************************** 查找当前被选中的city对象 - 开始 *******************************/        &#125;        /*        参数一：当前选中的省份        参数二：当前选中的城市        */        function changeCity(provinces,city)&#123;            // 获取第一个省份的所有城市的集合            var cityList = provinces.city;                        if(city)&#123;                changeArea(city);            &#125; else &#123;                changeArea(cityList[0]);            &#125;        &#125;                /*        参数：当前选中的城市对象        */        function changeArea(city)&#123;            /*************************** 填充行政区的select - 开始 *******************************/            // 获取第一个省份的第一个城市的所有行政区的集合            var areaList = city.area;            var areaOption = &quot;&quot;;            // 循环填充城市            for(var i=0;i&lt;areaList.length;i++)&#123;                areaOption += &quot;&lt;option value=&#39;&quot;                                 + areaList[i].value                                + &quot;&#39;&gt;&quot;                                + areaList[i].name                                + &quot;&lt;/option&gt;&quot;;            &#125;            area.innerHTML = areaOption;            /*************************** 填充行政区的select - 结束 *******************************/        &#125;                &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="三级联动"><a href="#三级联动" class="headerlink" title="三级联动"></a>三级联动</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;三级联动&lt;/title&gt;    &lt;/head&gt;    &lt;body onload=&quot;init()&quot;&gt;        &lt;span id=&quot;provincesSpan&quot;&gt;&lt;/span&gt;        &lt;span id=&quot;citySpan&quot;&gt;&lt;/span&gt;        &lt;span id=&quot;areaSpan&quot;&gt;&lt;/span&gt;        &lt;script&gt;        // 声明在方法外，是全局变量        // 声明在方法内，是局部变量        // 创建一个country对象        var country = &#123;&quot;provinces&quot;:[                &#123;                    &quot;name&quot;:&quot;北京&quot;,                    &quot;value&quot;:&quot;beijing&quot;,                    &quot;city&quot;:[                        &#123;                            &quot;name&quot;:&quot;北京&quot;,                            &quot;value&quot;:&quot;beijing&quot;,                            &quot;area&quot;:[                                &#123;                                    &quot;name&quot;:&quot;海淀区&quot;,                                    &quot;value&quot;:&quot;haidian&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;朝阳区&quot;,                                    &quot;value&quot;:&quot;chaoyang&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;昌平区&quot;,                                    &quot;value&quot;:&quot;changping&quot;                                &#125;]                        &#125;                    ]                &#125;,&#123;                    &quot;name&quot;:&quot;上海&quot;,                    &quot;value&quot;:&quot;shanghai&quot;,                    &quot;city&quot;:[                        &#123;                            &quot;name&quot;:&quot;上海&quot;,                            &quot;value&quot;:&quot;shanghai&quot;,                            &quot;area&quot;:[                                &#123;                                    &quot;name&quot;:&quot;浦东区&quot;,                                    &quot;value&quot;:&quot;pudong&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;宝山区&quot;,                                    &quot;value&quot;:&quot;baoshan&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;虹口区&quot;,                                    &quot;value&quot;:&quot;hongkou&quot;                                &#125;]                        &#125;                    ]                &#125;,&#123;                    &quot;name&quot;:&quot;广州&quot;,                    &quot;value&quot;:&quot;guangzhou&quot;,                    &quot;city&quot;:[                        &#123;                            &quot;name&quot;:&quot;广州&quot;,                            &quot;value&quot;:&quot;guangzhou&quot;,                            &quot;area&quot;:[                                &#123;                                    &quot;name&quot;:&quot;白云区&quot;,                                    &quot;value&quot;:&quot;baiyun&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;朝阳区&quot;,                                    &quot;value&quot;:&quot;chaoyang&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;昌平区&quot;,                                    &quot;value&quot;:&quot;changping&quot;                                &#125;]                        &#125;                    ]                &#125;,&#123;                    &quot;name&quot;:&quot;内蒙古&quot;,                    &quot;value&quot;:&quot;neimenggu&quot;,                    &quot;city&quot;:[                        &#123;                            &quot;name&quot;:&quot;呼和浩特&quot;,                            &quot;value&quot;:&quot;huhehaote&quot;,                            &quot;area&quot;:[                                &#123;                                    &quot;name&quot;:&quot;新城区&quot;,                                    &quot;value&quot;:&quot;xingcheng&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;赛罕区&quot;,                                    &quot;value&quot;:&quot;saihan&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;回民区&quot;,                                    &quot;value&quot;:&quot;huimin&quot;                                &#125;]                        &#125;,                        &#123;                            &quot;name&quot;:&quot;赤峰市&quot;,                            &quot;value&quot;:&quot;chifeng&quot;,                            &quot;area&quot;:[                                &#123;                                    &quot;name&quot;:&quot;阿鲁科尔沁旗&quot;,                                    &quot;value&quot;:&quot;alukeerqinqi&quot;                                &#125;,&#123;                                    &quot;name&quot;:&quot;红山区&quot;,                                    &quot;value&quot;:&quot;hongshan&quot;                                &#125;]                        &#125;                    ]                &#125;            ]&#125;;                                                            function init()&#123;                        // 获取省份的select            var provincesSpan = document.getElementById(&quot;provincesSpan&quot;);                        /*************************** 创建省份的select - 开始 *******************************/            var provincesSelect = &#39;&lt;select id=&quot;provinces&quot; onchange=&quot;changeProvinces(this)&quot;&gt;&#39;;            // 循环创建省份的option            for(var i=0;i&lt;country.provinces.length;i++)&#123;                provincesSelect += &quot;&lt;option value=&#39;&quot;                                 + country.provinces[i].value                                + &quot;&#39;&gt;&quot;                                + country.provinces[i].name                                + &quot;&lt;/option&gt;&quot;;            &#125;            provincesSelect += &#39;&lt;/select&gt;&#39;;            provincesSpan.innerHTML = provincesSelect;            /*************************** 创建省份的select - 结束 *******************************/                        changeProvinces(provincesSpan.firstChild);                    &#125;                /*            参数：省份select对象        */        function changeProvinces(provincesSelect)&#123;        // 获取城市的select        var citySpan = document.getElementById(&quot;citySpan&quot;);                        /*************************** 循环查找被选中的省份对象 - 开始 *******************************/            var provincesIndex = provincesSelect.selectedIndex;            provincesIndex = (provincesIndex &lt; 0 ? 0 : provincesIndex);            /*************************** 循环查找被选中的省份对象 - 结束 *******************************/                                    /*************************** 创建城市的select - 开始 *******************************/            // 获取当前选中的省份下，所有的城市            var cityList = country.provinces[provincesIndex].city;            var citySelect = &#39;&lt;select id=&quot;city&quot; onchange=&quot;changeCity(this)&quot;&gt;&#39;;            // 循环创建城市的option            for(var i=0;i&lt;cityList.length;i++)&#123;                citySelect += &quot;&lt;option value=&#39;&quot;                                 + cityList[i].value                                + &quot;&#39;&gt;&quot;                                + cityList[i].name                                + &quot;&lt;/option&gt;&quot;;            &#125;            citySelect += &#39;&lt;/select&gt;&#39;;            citySpan.innerHTML = citySelect;            /*************************** 创建城市的select - 开始 *******************************/                        changeCity(citySpan.firstChild);        &#125;                /*        参数：当前被选中的城市select对象        */        function changeCity(citySelect)&#123;        // 获取行政区的select        var areaSpan = document.getElementById(&quot;areaSpan&quot;);            var provincesIndex = provinces.selectedIndex;            var cityIndex = citySelect.selectedIndex;            provincesIndex = (provincesIndex &lt; 0 ? 0 : provincesIndex);            cityIndex = (cityIndex &lt; 0 ? 0 : cityIndex);                        var city = country.provinces[provincesIndex].city[cityIndex];                /*************************** 创建行政区的select - 开始 *******************************/                // 获取第一个省份的第一个城市的所有行政区的集合                var areaList = city.area;                var areaOption = &#39;&lt;select id=&quot;area&quot;&gt;&#39;;                // 循环创建行政区的option                for(var i=0;i&lt;areaList.length;i++)&#123;                    areaOption += &quot;&lt;option value=&#39;&quot;                                     + areaList[i].value                                    + &quot;&#39;&gt;&quot;                                    + areaList[i].name                                    + &quot;&lt;/option&gt;&quot;;                &#125;                areaOption += &#39;&lt;/select&gt;&#39;;                areaSpan.innerHTML = areaOption;                /*************************** 创建行政区的select - 结束 *******************************/                    &#125;                &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;鼠标事件&lt;/title&gt;        &lt;style&gt;        div&#123;            width: 200px;            height: 200px;            background-color: aqua;        &#125;        .inner_div&#123;            width: 100px;            height: 100px;            background-color: red;        &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--         onmouseenter：鼠标移入元素的事件（只要没有移出父元素的范围，就不会再次执行）        mouseleave：鼠标移出元素的事件（在父元素和子元素之间移入移出不会触发onmouseenter和mouseleave事件）        onmouseover：鼠标移入元素的事件（在父元素和子元素之间移入移出也会触发onmouseover和onmouseout事件）        onmouseout：鼠标移出元素的事件        onmousemove：鼠标在元素中移动的事件        onmousedown：鼠标按键按下的事件        onmouseup：松开鼠标按键的事件        --&gt;        &lt;div         onmouseover=&quot;mouseIn()&quot;         onmouseout=&quot;mouseOut()&quot;        onmousemove=&quot;mouseMove()&quot;        onmousedown=&quot;mouseDown()&quot;        onmouseup=&quot;mouseUp()&quot;        onmouseenter=&quot;mouseEnter()&quot;&gt;         &lt;div class=&quot;inner_div&quot;&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;!-- event：当前发生的事件对象 --&gt;        &lt;div onmousedown=&quot;mouseDown(event)&quot;&gt; div &lt;/div&gt;        &lt;script&gt;        function mouseIn()&#123;            console.log(&quot;mouse in&quot;);        &#125;        function mouseOut()&#123;            console.log(&quot;mouse Out&quot;);        &#125;        function mouseMove()&#123;            console.log(&quot;mouse Move&quot;);        &#125;        function mouseDown(event)&#123;            // event.button: 0:鼠标左键  1：鼠标滚轮  2：鼠标右键            // event.altKey: 按下鼠标时，是否按住了Alt建            // event.ctrlKey: 按下鼠标时，是否按住了Ctrl建            // event.shiftKey: 按下鼠标时，是否按住了Shift建            // event.target：发送事件的目标对象（被点击的元素对象）            console.log(event);            // console.log(&quot;mouse Down&quot;);        &#125;        function mouseUp()&#123;            console.log(&quot;mouse Up&quot;);        &#125;        function mouseEnter()&#123;            console.log(&quot;mouse Enter&quot;);        &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;键盘事件&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--         onkeydown：键盘的按键按下时触发的事件        onkeyup：键盘的按键松开（释放）时触发的事件        onkeypress：键盘的按键按下并松开（释放）时触发的事件        --&gt;        &lt;input id=&quot;password&quot; onkeydown=&quot;keyDown(event)&quot;         onkeyup=&quot;keyUp(event)&quot;         onkeypress=&quot;keyPress(event)&quot; /&gt;        &lt;span id=&quot;message&quot;&gt;&lt;/span&gt;        &lt;script&gt;        function keyDown(e)&#123;            // e.altKey: 按下键盘的按键时，是否按住了Alt建            // e.ctrlKey: 按下键盘的按键时，是否按住了Ctrl建            // e.shiftKey: 按下键盘的按键时，是否按住了Shift建            // e.key: 获取按下的按键字符            // e.keyCode: 获取按下的按键字符的ASCII码值            // e.KeyA: 获取键盘按键的编码            // console.log(e);            // 每次按下得到的文本框的值，都是按下之前的值            // var password = document.getElementById(&quot;password&quot;);            // console.log(password.value);        &#125;        function keyUp(e)&#123;            console.log(&quot;up&quot;);            // 每次按键抬起得到的文本框的值，都是输入之后的值            // var password = document.getElementById(&quot;password&quot;);            // console.log(password.value);        &#125;        function keyPress(e)&#123;            // console.log(&quot;press&quot;);            // 每次按下得到的文本框的值，都是按下之前的值            var password = document.getElementById(&quot;password&quot;);            console.log(password.value);            var message = document.getElementById(&quot;message&quot;);            if(password.value.length + 1 &lt; 6 || password.value.length &gt; 19)&#123;                message.innerHTML = &quot;密码的长度应在6~20之间&quot;;            &#125; else &#123;                message.innerHTML = &quot;&quot;;            &#125;        &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="selet-事件"><a href="#selet-事件" class="headerlink" title="selet 事件"></a>selet 事件</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--         checkbox、radio、select选中状态发送变化时，触发的是 change事件，而不是 select事件        onselect：文本被选中的事件（&lt;input&gt;和&lt;textarea&gt;支持）        --&gt;        &lt;input id=&quot;input&quot; type=&quot;text&quot; onselect=&quot;sel(event);sel1();&quot; /&gt;        &lt;div onselect=&quot;sel(event)&quot;&gt;            fjdklsajflkdsajkfjkldsajl        &lt;/div&gt;        &lt;select onchange=&quot;sel(event)&quot;&gt;            &lt;option&gt;1&lt;/option&gt;            &lt;option&gt;2&lt;/option&gt;            &lt;option&gt;3&lt;/option&gt;        &lt;/select&gt;        &lt;script&gt;        function sel(event)&#123;            var input = document.getElementById(&quot;input&quot;);            console.log(input.value);            console.log(event);        &#125;        function sel1(event)&#123;            console.log(&quot;11111&quot;);        &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="表单验证（sumbit事件）"><a href="#表单验证（sumbit事件）" class="headerlink" title="表单验证（sumbit事件）"></a>表单验证（sumbit事件）</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;表单验证&lt;/title&gt;        &lt;style&gt;        span&#123;            color:red;        &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- &lt;form action=&quot;http://www.baidu.com&quot; onsubmit=&quot;return sub();&quot;&gt; --&gt;        &lt;form id=&quot;myform&quot; action=&quot;http://www.baidu.com&quot; onsubmit=&quot;return false;&quot;&gt;            &lt;!-- HTML5中新增required属性，如果表单控件中使用required，表示该控件必须输入值 --&gt;            用户名：&lt;input id=&quot;username&quot; required=&quot;required&quot; /&gt;&lt;span id=&quot;username_msg&quot;&gt;&lt;/span&gt;&lt;br /&gt;            密 码：&lt;input id=&quot;password&quot; type=&quot;password&quot; /&gt;&lt;span id=&quot;password_msg&quot;&gt;&lt;/span&gt;&lt;br /&gt;            爱 好：            &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; value=&quot;吃饭&quot; /&gt;吃饭            &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; value=&quot;睡觉&quot; /&gt;睡觉            &lt;input name=&quot;hobby&quot; type=&quot;checkbox&quot; value=&quot;打豆豆&quot; /&gt;打豆豆            &lt;span id=&quot;hobby_msg&quot;&gt;&lt;/span&gt;&lt;br /&gt;            &lt;!--             type=&quot;submit&quot;：被点击时，默认会触发form的sumbit事件            注意：只有在form元素内，才会触发form的submit事件            --&gt;            &lt;!-- &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; --&gt;            &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;sub()&quot; /&gt;        &lt;/form&gt;        &lt;script&gt;        function sub()&#123;            var username = document.getElementById(&quot;username&quot;);            var password = document.getElementById(&quot;password&quot;);            var hobbys = document.getElementsByName(&quot;hobby&quot;);            var username_msg = document.getElementById(&quot;username_msg&quot;);            var username_msg = document.getElementById(&quot;username_msg&quot;);            var hobby_msg = document.getElementById(&quot;hobby_msg&quot;);            if(username.value == &quot;&quot;)&#123;                username_msg.innerHTML = &quot;用户名不能为空！&quot;;                return false;            &#125; else &#123;                username_msg.innerHTML = &quot;&quot;;            &#125;            if(password.value == &quot;&quot;)&#123;                password_msg.innerHTML = &quot;密码不能为空！&quot;;                return false;            &#125; else &#123;                password_msg.innerHTML = &quot;&quot;;            &#125;            if(password.value.length &lt; 6 || password.value.length &gt; 20)&#123;                password_msg.innerHTML = &quot;密码长度必须在 6 ~ 20 之间！&quot;;                return false;            &#125; else &#123;                password_msg.innerHTML = &quot;&quot;;            &#125;                        var result = false;            // 如果所有的复选框都没有选中，则循环 或 完之后，result为false            // 如果只要有一个复选框被选中，则循环 或 完之后，result为true            for(var i=0;i&lt;hobbys.length;i++)&#123;                var hobby = hobbys[i];                result = result || hobby.checked;            &#125;            if(!result)&#123;                hobby_msg.innerHTML = &quot;至少要选一个爱好&quot;;            &#125; else &#123;                hobby_msg.innerHTML = &quot;&quot;;            &#125;                        console.log(&quot;表单被提交了&quot;);                        // 获取form对象            // var myform = document.getElementById(&quot;myform&quot;);            // var myform = document.forms.myform;            // var myform = document.forms[0];            var myform = document.forms[&quot;myform&quot;];            // 提交表单            myform.submit();                        // 方法中return返回boolean值   true：提交表单   false：不提交表单            return result;        &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="输出信息"><a href="#输出信息" class="headerlink" title="输出信息"></a>输出信息</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--         alert：弹出的消息框，只有一个ok（确认）按钮        confirm：弹出的消息框，有一个ok（确认）按钮 和 一个cancel（取消）按钮                    如果点击ok（确认）按钮，该方法的返回值为true                      如果点击cancel（取消）按钮，该方法的返回值为false        prompt：弹出的消息框，有一个ok（确认）按钮 和 一个cancel（取消）按钮 和 一个输入框                    如果点击ok（确认）按钮，该方法的返回值为 用户输入的 值                      如果点击cancel（取消）按钮，该方法的返回值为 null        --&gt;        &lt;input type=&quot;button&quot; value=&quot;alert&quot; onclick=&quot;alert(&#39;弹出提示框&#39;)&quot; /&gt;        &lt;input type=&quot;button&quot; value=&quot;confirm&quot; onclick=&quot;var r = confirm(&#39;弹出提示框&#39;);alert(r)&quot; /&gt;        &lt;input type=&quot;button&quot; value=&quot;prompt&quot; onclick=&quot;var r = prompt(&#39;弹出提示框&#39;);alert(r)&quot; /&gt;        &lt;input type=&quot;button&quot; value=&quot;document.write&quot; onclick=&quot;w()&quot; /&gt;        &lt;script&gt;        function w()&#123;            // 向页面写入指定的内容（会覆盖文档中原有的所有内容）            document.write(&quot;&lt;div&gt;动态向页面中写入的内容&lt;/div&gt;&quot;);            console.log(&quot;向控制台输出的内容&quot;);                        var x = 9.656;            x.toFixed(0);           // 返回 10            x.toFixed(2);           // 返回 9.66            x.toFixed(4);           // 返回 9.6560            x.toFixed(6);           // 返回 9.656000        &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="搜索元素"><a href="#搜索元素" class="headerlink" title="搜索元素"></a>搜索元素</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;通过选择器获取元素对象&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;div1&quot; class=&quot;myclass&quot;&gt; div1 &lt;/div&gt;        &lt;div id=&quot;div2&quot; class=&quot;myclass&quot;&gt; div2 &lt;/div&gt;        &lt;div id=&quot;div3&quot;&gt; div3 &lt;/div&gt;                &lt;script&gt;        // querySelector:根据选择器，查找第一个匹配的元素对象        // querySelectorAll:根据选择器，查找所有匹配的元素对象        // 根据ID搜索元素（使用css中的ID选择器获取元素）        var searchById = document.querySelector(&quot;#div1&quot;);        console.log(searchById);                // 根据class搜索元素（使用css中的类选择器获取元素）        var searchByFirstClass = document.querySelector(&quot;.myclass&quot;);        console.log(searchByFirstClass);                var searchByAllClass = document.querySelectorAll(&quot;.myclass&quot;);        console.log(searchByAllClass);                        // 根据标签搜索元素（使用css中的标签选择器获取元素）        var searchByFirstTagName = document.querySelector(&quot;div&quot;);        console.log(searchByFirstTagName);                var searchByAllTagName = document.querySelectorAll(&quot;div&quot;);        console.log(searchByAllTagName);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="math"><a href="#math" class="headerlink" title="math"></a>math</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script&gt;        var random = Math.random();         document.write(random);        document.write(&quot;&lt;br/&gt;&quot;);        // 返回 0 至 100 之间的数        document.write(Math.floor(Math.random() * 101));        document.write(&quot;&lt;br/&gt;&quot;);        // 返回 1 至 10 之间的数        document.write(Math.floor(Math.random() * 10) + 1);            &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="js中的BOM对象"><a href="#js中的BOM对象" class="headerlink" title="js中的BOM对象"></a>js中的BOM对象</h1><h2 id="打开关闭窗口"><a href="#打开关闭窗口" class="headerlink" title="打开关闭窗口"></a>打开关闭窗口</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;button&quot; value=&quot;打开&quot; onclick=&quot;window.open(&#39;http://www.baidu.com&#39;)&quot; /&gt;        &lt;input type=&quot;button&quot; value=&quot;关闭&quot; onclick=&quot;window.close()&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="当前屏幕的参数"><a href="#当前屏幕的参数" class="headerlink" title="当前屏幕的参数"></a>当前屏幕的参数</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;当前屏幕的参数&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script&gt;        document.write(screen.width);        document.write(&quot;&lt;br /&gt;&quot;);        document.write(screen.height);        document.write(&quot;&lt;br /&gt;&quot;);        document.write(screen.availWidth);        document.write(&quot;&lt;br /&gt;&quot;);        document.write(screen.availHeight);        document.write(&quot;&lt;br /&gt;&quot;);        document.write(screen.colorDepth);        document.write(&quot;&lt;br /&gt;&quot;);        document.write(screen.pixelDepth);        document.write(&quot;&lt;br /&gt;&quot;);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="使用location的href属性连接页面"><a href="#使用location的href属性连接页面" class="headerlink" title="使用location的href属性连接页面"></a>使用location的href属性连接页面</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;button&quot; value=&quot;打开&quot; onclick=&quot;location.href = &#39;http://www.baidu.com&#39;&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="访问历史，前进和后退"><a href="#访问历史，前进和后退" class="headerlink" title="访问历史，前进和后退"></a>访问历史，前进和后退</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;a href=&quot;third.html&quot;&gt;第三页&lt;/a&gt;        &lt;input type=&quot;button&quot; value=&quot;前进&quot; onclick=&quot;history.go(1)&quot; /&gt;        &lt;!--         go(参数):正值（前进）  负值（后退）        --&gt;        &lt;input type=&quot;button&quot; value=&quot;后退&quot; onclick=&quot;history.go(-1)&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;content&quot;&gt;&lt;/div&gt;        &lt;script&gt;        // json格式的字符串（JSON串）        var jsonStr = &#39;&#123;&quot;id&quot;:1,&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;abc123&quot;,&quot;hobby&quot;:[&quot;吃饭&quot;,&quot;睡觉&quot;],&quot;type&quot;:&#123;&#125;&#125;&#39;;        // 将JSON串转换成JavaScript中的对象        // eval方法转换时，JSON串必须使用()括起来，不推荐使用        // var user = eval(&quot;(&quot; + jsonStr + &quot;)&quot;);        // JSON.parse()方法：将JSON格式的字符串转换成JavaScript的对象        var user = JSON.parse(jsonStr);        console.log(user.id);        console.log(user.username);        console.log(user.password);        console.log(user);        // 将JavaScript中的对象转换成JSON格式的字符串        var str = JSON.stringify(user);        console.log(str);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form&gt;            手机号：&lt;input type=&quot;text&quot; id=&quot;phone&quot; name=&quot;phone&quot; /&gt;&lt;span id=&quot;phone_msg&quot;&gt;&lt;/span&gt;&lt;br/&gt;            密 码：&lt;input type=&quot;text&quot; id=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;span id=&quot;password_msg&quot;&gt;&lt;/span&gt;&lt;br/&gt;            邮 箱：&lt;input type=&quot;text&quot; id=&quot;email&quot; name=&quot;email&quot; /&gt;&lt;span id=&quot;email_msg&quot;&gt;&lt;/span&gt;&lt;br/&gt;            &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;sub()&quot;/&gt;        &lt;/form&gt;        &lt;script&gt;        function sub()&#123;            var phone = document.getElementById(&quot;phone&quot;).value;            var password = document.getElementById(&quot;password&quot;).value;            var email = document.getElementById(&quot;email&quot;).value;            var phone_msg = document.getElementById(&quot;phone_msg&quot;);            var password_msg = document.getElementById(&quot;password_msg&quot;);            var email_msg = document.getElementById(&quot;email_msg&quot;);            /********************* 验证手机 *********************/            // 手机号：1、必须是纯数字  2、必须以数字 1 开头  3、第二位：3、4、5、6、7、8、9    4、从第三位开始剩余的 9 位都可以是 0-9              // 创建验证手机号的正则表达式对象            // ^字符:是否以指定的字符开头            // 字符$:是否以指定的字符结尾            var phoneExp = /^1[3-9]\d&#123;9&#125;$/ ;            if(phoneExp.test(phone))&#123;                phone_msg.innerHTML = &quot;&quot;;            &#125; else &#123;                phone_msg.innerHTML = &quot;手机号的格式不匹配&quot;;            &#125;                        // var passwordExp = /^[0-9A-z@]&#123;6,20&#125;$/;            var passwordExp = /^[A-z0-9]&#123;3,10&#125;@&#123;1&#125;[A-z0-9]&#123;2,9&#125;$/;            if(passwordExp.test(password))&#123;                password_msg.innerHTML = &quot;&quot;;            &#125; else &#123;                password_msg.innerHTML = &quot;密码格式不匹配&quot;;            &#125;                        // 1.@之前可以是数字和字符  2.@  3.至少要有一个字符 4.可以是.com .cn .net .com.cn            var emailExp = /^[0-9A-z]&#123;3,&#125;@[A-z]+(.com|.cn|.net|.com.cn)$/;            if(emailExp.test(email))&#123;                email_msg.innerHTML = &quot;&quot;;            &#125; else &#123;                email_msg.innerHTML = &quot;邮箱格式不正确&quot;;            &#125;                                &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JavaScript笔记&quot;&gt;&lt;a href=&quot;#JavaScript笔记&quot; class=&quot;headerlink&quot; title=&quot;JavaScript笔记&quot;&gt;&lt;/a&gt;JavaScript笔记&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>HTML和CSS笔记</title>
    <link href="http://example.com/2021/08/28/html%E5%92%8Ccss%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/08/28/html%E5%92%8Ccss%E7%AC%94%E8%AE%B0/</id>
    <published>2021-08-28T08:27:31.000Z</published>
    <updated>2021-09-14T06:56:14.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Html和CSS笔记"><a href="#Html和CSS笔记" class="headerlink" title="Html和CSS笔记"></a>Html和CSS笔记</h1><span id="more"></span><h1 id="《《文章很长，目录在右下角》》"><a href="#《《文章很长，目录在右下角》》" class="headerlink" title="《《文章很长，目录在右下角》》"></a>《《文章很长，目录在右下角》》</h1><h2 id="Html"><a href="#Html" class="headerlink" title="Html"></a>Html</h2><h3 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h3><ul><li>开始标签：&lt;标签名&gt;</li><li>结束标签：&lt;/标签名&gt;</li><li>自封标签(自闭标签)：&lt;标签名/&gt;</li></ul><p>注意：开始标签和结束标签必须成对出现，必须正确的嵌套</p><h3 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h3><ul><li><p>开始标签 + 内容 + 结束标签 =  html元素</p></li><li><p>html元素也会被浏览器转换成对象</p><h3 id="HTML文档的基本结构"><a href="#HTML文档的基本结构" class="headerlink" title="HTML文档的基本结构"></a>HTML文档的基本结构</h3></li><li><p>必须具有一个跟元素html</p></li><li><p>html中包含head和body两个元素</p></li><li><p>head元素中包含title元素</p></li><li><p>body中是网页的主题内容<br><img src="https://s3.bmp.ovh/imgs/2021/08/f4e5efde428942f4.png"></p><h3 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h3><p><img src="https://s3.bmp.ovh/imgs/2021/08/1f280a630ccf3b3e.png"></p><h3 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h3><p><img src="https://s3.bmp.ovh/imgs/2021/08/bc435e33f2979402.png"></p><h3 id="锚点标签"><a href="#锚点标签" class="headerlink" title="锚点标签"></a>锚点标签</h3><p><img src="https://s3.bmp.ovh/imgs/2021/08/e20526113d57c444.png"><br><img src="https://s3.bmp.ovh/imgs/2021/08/efbb0245217289ba.png"></p><h3 id="img图片标签"><a href="#img图片标签" class="headerlink" title="img图片标签"></a>img图片标签</h3><p><img src="https://s3.bmp.ovh/imgs/2021/08/860cf643811db8c6.png"></p><h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><p><img src="https://s3.bmp.ovh/imgs/2021/08/2ea5843eb14e2e66.png"><br><img src="https://s3.bmp.ovh/imgs/2021/08/262413c26a4267f5.png"></p><h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><p><img src="https://s3.bmp.ovh/imgs/2021/08/0e7ba995503b267a.png"></p></li><li><p>静态网页：无法与服务器交互</p></li><li><pre><code>HTML</code></pre></li><li><p>动态网页：可以与服务器交互</p></li><li><pre><code>JSP、PHP、ASP、ASP .NET</code></pre><h3 id="form表单"><a href="#form表单" class="headerlink" title="form表单"></a>form表单</h3></li></ul><pre><code>&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;表单控件&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!--     HTML标签通用的属性        id：唯一标识一个标签的标志（HTML规范要求id必须唯一）        name：指定元素的名称        class：css常用该属性设置样式        表单控件的disabled属性：禁用表单控件        form：表单标签        action：指定接收请求的url（地址）        method：提交请求的方式    input：表单控件标签        value：表单控件的值        type：            text（默认值：可以被省略）：文本框（输入单行文本）            password：密码输入框                        submit：提交表单按钮            reset：重置表单按钮            button：普通按钮                        radio：单选按钮                 name：属性值一致的单选按钮会被自动分为一组，一组单选按钮只能有一个被选中                value：指定提交到后台（服务器）的值                checked：设置当前按钮默认被选中            checkbox：复选框                name：同一组复选框name值要一致                value：指定提交到后台（服务器）的值                checked：设置当前按钮默认被选中            hidden：隐藏域            file：文件控件                    select：下拉列表框标签        name：提交到后的名称（key）    option：下拉列表框中的选项（select子标签）        value：提交到后台的值（value）    textarea：文本域标签（用于输入多行文本）        cols：一行显示的英文字符数（中文一个字符占两个英文字符的空间）        rows：显示内容的行数（一旦内容行数超出rows的指定值，就会自动出现滚动条）            button：按钮标签    --&gt;    &lt;form action=&quot;url&quot; method=&quot;get&quot; enctype=&quot;multipart/form-data&quot;&gt;        隐藏域：&lt;input type=&quot;hidden&quot; name=&quot;&quot; value=&quot;&quot; /&gt; &lt;br /&gt;        头像：&lt;input type=&quot;file&quot; name=&quot;upload_file&quot; /&gt; &lt;br /&gt;        手机号：&lt;input type=&quot;text&quot; id=&quot;phone&quot; name=&quot;phone&quot; disabled=&quot;disabled&quot; /&gt; &lt;br /&gt;        密码：&lt;input type=&quot;password&quot; /&gt; &lt;br /&gt;        性别：        &lt;input name=&quot;sex&quot; type=&quot;radio&quot; id=&quot;man&quot; checked=&quot;checked&quot; value=&quot;男&quot; /&gt;&lt;label for=&quot;man&quot;&gt;男&lt;/label&gt;         &lt;input name=&quot;sex&quot; type=&quot;radio&quot; id=&quot;woman&quot; value=&quot;女&quot; /&gt;&lt;label for=&quot;woman&quot;&gt;女&lt;/label&gt; &lt;br /&gt;        爱好：        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;chifan&quot; checked=&quot;checked&quot;/&gt;吃饭        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;shuijiao&quot;/&gt;睡觉        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;dadoudou&quot;/&gt;打豆豆        &lt;br /&gt;        家乡：        &lt;select name=&quot;city&quot;&gt;            &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;            &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt;            &lt;option value=&quot;guangzhou&quot;&gt;广州&lt;/option&gt;            &lt;option value=&quot;shenzhen&quot;&gt;深圳&lt;/option&gt;        &lt;/select&gt;        &lt;select name=&quot;area&quot;&gt;            &lt;option&gt;海淀&lt;/option&gt;            &lt;option&gt;朝阳&lt;/option&gt;            &lt;option&gt;丰台&lt;/option&gt;            &lt;option&gt;昌平&lt;/option&gt;        &lt;/select&gt;        &lt;br /&gt;        个人简介：        &lt;textarea name=&quot;info&quot; cols=&quot;20&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;        &lt;br /&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交表单按钮&quot; /&gt;        &lt;input type=&quot;reset&quot; value=&quot;重置表单按钮&quot; /&gt;        &lt;input type=&quot;button&quot; value=&quot;普通按钮&quot; /&gt;        &lt;br /&gt;        图片按钮：&lt;input type=&quot;image&quot; src=&quot;./04、image/img10.jpg&quot; width=&quot;100&quot; height=&quot;100&quot; /&gt;        &lt;br /&gt;        &lt;button&gt;普通按钮&lt;/button&gt;        &lt;button type=&quot;submit&quot;&gt;提交表单按钮&lt;/button&gt;        &lt;button type=&quot;reset&quot;&gt;重置表单按钮&lt;/button&gt;        &lt;br /&gt;                &lt;!-- 以下是HTML5中增加的表单控件 --&gt;        只能输入数字：&lt;input type=&quot;number&quot; /&gt;        &lt;br /&gt;        输入邮箱地址（自带邮箱验证功能）：&lt;input type=&quot;email&quot; /&gt;        &lt;br /&gt;        颜色面板：&lt;input type=&quot;color&quot; /&gt;        &lt;br /&gt;        日期（自带日历面板（不含时间））：&lt;input type=&quot;date&quot; /&gt;        &lt;br /&gt;        日期+时间（自带日历面板）：&lt;input type=&quot;datetime&quot; /&gt;        &lt;br /&gt;        本地时间：&lt;input type=&quot;datetime-local&quot; /&gt;        &lt;br /&gt;        月份：&lt;input type=&quot;month&quot; /&gt;        &lt;br /&gt;        周：&lt;input type=&quot;week&quot; /&gt;        &lt;br /&gt;        时间：&lt;input type=&quot;time&quot; /&gt;        &lt;br /&gt;        滑块：&lt;input type=&quot;range&quot; /&gt;        &lt;br /&gt;        搜索框：&lt;input type=&quot;search&quot; /&gt;        &lt;br /&gt;        电话号码（自带电话验证功能）：&lt;input type=&quot;tel&quot; /&gt;        &lt;br /&gt;        URL：&lt;input type=&quot;url&quot; /&gt;        &lt;br /&gt;                    &lt;/form&gt;&lt;/body&gt;</code></pre><p><img src="https://s3.bmp.ovh/imgs/2021/08/4e91a1fba74e892f.png"><br><img src="https://s3.bmp.ovh/imgs/2021/08/08a7efb4b6ab5a0a.png"></p><h3 id="framset（不常用）"><a href="#framset（不常用）" class="headerlink" title="framset（不常用）"></a>framset（不常用）</h3><p>目录： D:\中软学习篇\赵灿老师代码\html\09、frameset</p><h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h3><p>目录： D:\中软学习篇\赵灿老师代码\html\10、iframe</p><h3 id="文本格式"><a href="#文本格式" class="headerlink" title="文本格式"></a>文本格式</h3><p><img src="https://s3.bmp.ovh/imgs/2021/08/61b5247061266679.png"></p><h3 id="打开方式"><a href="#打开方式" class="headerlink" title="打开方式"></a>打开方式</h3><p><img src="https://s3.bmp.ovh/imgs/2021/08/61ca88b184f29042.png"></p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h2 id="CSS-1"><a href="#CSS-1" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS-级联样式表"><a href="#CSS-级联样式表" class="headerlink" title="CSS(级联样式表)"></a>CSS(级联样式表)</h3><p>作用：用于美化html页面</p><h3 id="使用CSS的三种方式"><a href="#使用CSS的三种方式" class="headerlink" title="使用CSS的三种方式"></a>使用CSS的三种方式</h3><ul><li>内联式（行内样式）</li></ul><ol><li>优点：使用简单</li><li>缺点：维护麻烦，无法复用代码<br><img src="https://s3.bmp.ovh/imgs/2021/08/8882ef54aa4acaaa.png"></li></ol><ul><li>嵌入式（内嵌样式）</li></ul><ol><li>使用相对简单，难于维护，无法复用代码（只能在当前页内复用）<br><img src="https://s3.bmp.ovh/imgs/2021/08/5d4646575120fa81.png"></li></ol><ul><li>外部样式</li></ul><ol><li>优点：维护方便、代码可复用</li><li>缺点： 使用时需要注意选择器选中的范围<br><img src="https://s3.bmp.ovh/imgs/2021/08/4a12ff25c05ce8c6.png"><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3>：只能使用多行注释/<em>注释内容</em>/<h3 id="CSS语法"><a href="#CSS语法" class="headerlink" title="CSS语法"></a>CSS语法</h3></li></ol><ul><li><p>语法格式：选择器{语句1;…语句n;}</p></li><li><p>语句 =  属性:值;<br><img src="https://s3.bmp.ovh/imgs/2021/08/573d62c36b92e462.png"></p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3></li><li><p>作用：指向您需要设置样式的 HTML 元素</p></li><li><p>标签选择器（元素选择器）</p><p>  标签名{</p><pre><code>  属性:值;</code></pre><p>  }</p></li></ul><p><img src="https://s3.bmp.ovh/imgs/2021/08/8078673719bc7ebd.png"></p><h3 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h3><p>#标签的id属性的值{<br>}<br><img src="https://s3.bmp.ovh/imgs/2021/08/05ebe1d2e86f8b05.png"></p><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><ul><li>HTML规范：要是id在一个页面中要保证唯一性</li><li>CSS中id选择器，没遵守HTML的规范，如果有多个相同的id，都会被id选择器选中</li><li>JavaScript中：遵守了HTML的规范，当出现重复的id时，获取的元素对象为第一个出现的id<h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3></li><li>.标签的class属性的值{}<br><img src="https://s3.bmp.ovh/imgs/2021/08/e5166660d1467d79.png"><h3 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h3><img src="https://s3.bmp.ovh/imgs/2021/08/b49ab61d2c64491c.png"><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><img src="https://s3.bmp.ovh/imgs/2021/08/39db5d5b50989554.png"><h3 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h3><img src="https://s3.bmp.ovh/imgs/2021/08/16efc3aab28084ba.png"><h3 id="选择器分组"><a href="#选择器分组" class="headerlink" title="选择器分组"></a>选择器分组</h3><img src="https://s3.bmp.ovh/imgs/2021/08/99b338690e4b74a4.png"><h3 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h3><img src="https://s3.bmp.ovh/imgs/2021/08/3b49e8dbe51dbf27.png"><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3>  <!DOCTYPE html>  <html>      <head>          <meta charset="utf-8">          <title>伪类选择器</title>          <style type="text/css">          /* 初始状态 */          a:link{              color:black;          }          /* 鼠标移入的样式 */          a:hover{              color:blue;          }          /* 鼠标按下未松开 */          a:active{              color:red;          }          /* 被点击之后的样式 */          a:visited{              color:#0f0;          }          /* 获取焦点的伪类 */          #username:focus{              background-color: #FF0000;          }          </style>      </head>      <body>          <a href="./target.html"> target.html </a>          <input id="username">      </body>  </html></li></ul><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><ul><li>margin（外边距：边框和其他元素之间的距离）、padding（内边距：边框和元素内容之间的距离）、border（边框）<br><img src="https://s3.bmp.ovh/imgs/2021/08/68139e6115b9707c.png"><br><img src="https://s3.bmp.ovh/imgs/2021/08/297db6ebd7080f6f.png"><br><img src="https://s3.bmp.ovh/imgs/2021/08/2ce42d23b028e9c2.png"></li><li>代码<pre><code>  &lt;head&gt;      &lt;meta charset=&quot;utf-8&quot;&gt;      &lt;title&gt;盒子模型&lt;/title&gt;      &lt;style type=&quot;text/css&quot;&gt;      /*       span是行内元素，div是块元素      行内元素是不支持设置width和height的      */      span&#123;          width: 100px;          height: 100px;          background-color: #0000FF;          /* 将当前选择器选中的元素设置为块元素 */          display: block;      &#125;      /* 使用width和height设置元素的宽和高时，是不包含边框的宽度的 */      div&#123;          width: 100px;          height: 100px;      &#125;      .div1&#123;          background-color: #ffDDDD;          border: solid #FF0000 100px;      &#125;      .div2&#123;          background-color: #DDFFDD;          border: solid #00FF00 10px;      &#125;      .div3&#123;          background-color: #DDF;          border: solid #00F 10px;          /*           html文件解析的顺序是从上到下一条一条解析的，所以，如果相同属性，设置多次，下面的设置会覆盖上面的设置          内边距：内容到边框内边缘之间的距离          padding:值; 一次性设置四边的内边距          padding:值1 值2; 值1：上下  值2：左右          padding:值1 值2 值3 值4;  值1：上  值2：右  值3:下  值4：左          padding-left:设置左边的内边距          padding-top:设置上边的内边距          padding-right:设置右边的内边距          padding-bottom:设置下边的内边距          */          padding: 10px 50px 100px 150px;          /* padding-left: 500px; */          /*           外边距：边框的外边缘到占用的空间的边缘的距离          margin:值; 一次性设置四边的外边距          margin:值1 值2; 值1：上下  值2：左右          margin:值1 值2 值3 值4;  值1：上  值2：右  值3:下  值4：左          margin-left:设置左边的外边距          margin-top:设置上边的外边距          margin-right:设置右边的外边距          margin-bottom:设置下边的外边距          */          margin: 10px 50px 100px 50px;      &#125;      &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;      &lt;div class=&quot;div1&quot;&gt; div1 &lt;/div&gt;      &lt;div class=&quot;div2&quot;&gt; div2 &lt;/div&gt;      &lt;div class=&quot;div3&quot;&gt; div3 &lt;/div&gt;            &lt;span&gt;span&lt;/span&gt;  &lt;/body&gt;</code></pre></li></ul><h3 id="内容溢出"><a href="#内容溢出" class="headerlink" title="内容溢出"></a>内容溢出</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;内容溢出&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;        div&#123;            width: 200px;            height: 200px;            background-color: #F00;            /*             内容溢出（overflow）：            visible（默认值）：内容溢出后，在元素外显示溢出的内容，但溢出的内容不占空间;            auto:内容没有溢出时，不会显示滚动条；内容有溢出时，自动显示滚动条            hidden：隐藏溢出的内容            scroll：不管内容是否溢出，都显示滚动条            inherit：从父元素继承overflow的设置            */            overflow: visible;        &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div&gt;            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv            divdivdivdivdivdivdivdivdivdivdivdivdivdivdiv        &lt;/div&gt;        &lt;span&gt;            spanspanspanspanspanspanspanspanspanspanspan            spanspanspanspanspanspanspanspanspanspanspan            spanspanspanspanspanspanspanspanspanspanspan        &lt;/span&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;元素浮动&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;            /*             浏览器在解析HTML时，是自上而下的一句一句解析的，            元素的顺序（元素占用空间的顺序）自上而下，自左而右进行排列的                        float:元素浮动（浮动以后，元素会脱离正常（默认）的文档流）                left:被选择器选中的元素漂浮到期后元素的左边                right:被选择器选中的元素漂浮到期后元素的由边            */            ul li&#123;                float: right;                background-color: aqua;                padding: 5px;                margin: 5px;                /* list-style设置为none，去除li默认的样式 */                list-style: none;            &#125;            /*             clear:清除浮动（不允许其他元素浮动到当前元素的左边或右边）                none(默认值)：允许漂浮                right:禁止其他元素漂浮到当前元素的右侧                left:禁止其他元素漂浮到当前元素的左侧                both:禁止其他元素漂浮到当前元素的两侧            */            div&#123;                clear: both;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;ul&gt;            &lt;li class=&quot;first&quot;&gt; 首页 &lt;/li&gt;            &lt;li&gt; HTML&lt;/li&gt;            &lt;li&gt; CSS &lt;/li&gt;            &lt;li class=&quot;last&quot;&gt; JAVASCRIPT &lt;/li&gt;        &lt;/ul&gt;        &lt;div&gt;div&lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><pre><code>!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;元素定位&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;        .container&#123;            background-color: #0f0;            height: 1000px;        &#125;        .container div&#123;            width: 200px;            height: 200px;            background-color: azure;            border: solid #f00 2px;        &#125;        /*         position(元素定位)：设置元素显示的起始位置（左上角）            static：以正常的文档流为左上角起点（上一个元素的结束位置）                    不支持left、right、top、bottom四个属性的            relative（相对定位）：相对于当前元素在正常文档流中的起点进行定位                    定位后元素会脱离正常的文档流，原来应该占用的元素空间依然会被占用            fixed（绝对定位）：以浏览器的左上角作为原点进行定位                    定位后元素会脱离正常的文档流，原来应该占用的元素空间不会再被占用            absolute(绝对定位):以第一个position不为static的父元素的左上角作为原点进行定位                    定位后元素会脱离正常的文档流，原来应该占用的元素空间不会再被占用            sticky(粘性定位):基于用户的滚动位置来定位。                    粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。            inherit：继承父元素的定位方式        */                .div2&#123;            position: absolute;            left:20px;            top:20px;        &#125;        .div3&#123;            position: fixed;            right: 0px;            bottom: 0px;        &#125;        .div4&#123;            /*             先以relative方式定位，当用户拖动滚动条的时候，            元素据浏览器可见区域上边缘的距离等于top的值时，自动切换成fixed定位            */            position: sticky;            top:10px;        &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body style=&quot;position: static;&quot;&gt;        &lt;div class = &quot;outer&quot; style=&quot;position: static;&quot;&gt;            &lt;div class = &quot;container&quot; style=&quot;position: static;left:50px;top:50px&quot;&gt;                &lt;div class=&quot;div1&quot;&gt;div1&lt;/div&gt;                &lt;div class=&quot;div2&quot;&gt;div2 &lt;/div&gt;                &lt;div class=&quot;div3&quot;&gt;div3 我是一个小广告 &lt;/div&gt;                &lt;div class=&quot;div4&quot;&gt;div4&lt;/div&gt;                &lt;span&gt; span1 &lt;/span&gt;                &lt;span&gt; span2 &lt;/span&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;        &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;        &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;        &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;        &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;        &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;        &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="元素重叠"><a href="#元素重叠" class="headerlink" title="元素重叠"></a>元素重叠</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;元素重叠&lt;/title&gt;                &lt;style type=&quot;text/css&quot;&gt;        div&#123;            width:200px;            height:200px;        &#125;        /*         z-index（默认值为0）值大的在上面，值小的在下面        没有定位的元素不支持z-index属性        */        #div1&#123;            background-color: aqua;            z-index: 1;        &#125;        #div2&#123;            background-color: red;            z-index: -2;            position: absolute;            top: 20px;            left:20px        &#125;        #div3&#123;            background-color: #0f0;            z-index: 3;            position: absolute;            top: 40px;            left:40px        &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;div1&quot;&gt;div1&lt;/div&gt;        &lt;div id=&quot;div2&quot;&gt;div2&lt;/div&gt;        &lt;div id=&quot;div3&quot;&gt;div3&lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Html和CSS笔记&quot;&gt;&lt;a href=&quot;#Html和CSS笔记&quot; class=&quot;headerlink&quot; title=&quot;Html和CSS笔记&quot;&gt;&lt;/a&gt;Html和CSS笔记&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
